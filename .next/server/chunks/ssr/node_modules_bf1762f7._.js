module.exports = [
"[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ("TURBOPACK compile-time truthy", 1) {
                module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)");
            } else //TURBOPACK unreachable
            ;
        } else //TURBOPACK unreachable
        ;
    }
} //# sourceMappingURL=module.compiled.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].React; //# sourceMappingURL=react.js.map
}),
"[project]/node_modules/dexie/dist/dexie.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 4.2.0, Wed Aug 13 2025
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */ (function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */ var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for(var s, i = 1, n = arguments.length; i < n; i++){
                s = arguments[i];
                for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    var _global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : /*TURBOPACK member replacement*/ __turbopack_context__.g;
    var keys = Object.keys;
    var isArray = Array.isArray;
    if (typeof Promise !== 'undefined' && !_global.Promise) {
        _global.Promise = Promise;
    }
    function extend(obj, extension) {
        if (typeof extension !== 'object') return obj;
        keys(extension).forEach(function(key) {
            obj[key] = extension[key];
        });
        return obj;
    }
    var getProto = Object.getPrototypeOf;
    var _hasOwn = {}.hasOwnProperty;
    function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
    }
    function props(proto, extension) {
        if (typeof extension === 'function') extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function(key) {
            setProp(proto, key, extension[key]);
        });
    }
    var defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ? {
            get: functionOrGetSet.get,
            set: functionOrGetSet.set,
            configurable: true
        } : {
            value: functionOrGetSet,
            configurable: true,
            writable: true
        }, options));
    }
    function derive(Child) {
        return {
            from: function(Parent) {
                Child.prototype = Object.create(Parent.prototype);
                setProp(Child.prototype, "constructor", Child);
                return {
                    extend: props.bind(null, Child.prototype)
                };
            }
        };
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
    }
    var _slice = [].slice;
    function slice(args, start, end) {
        return _slice.call(args, start, end);
    }
    function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
    }
    function assert(b) {
        if (!b) throw new Error("Assertion Failed");
    }
    function asap$1(fn) {
        if (_global.setImmediate) setImmediate(fn);
        else setTimeout(fn, 0);
    }
    function arrayToObject(array, extractor) {
        return array.reduce(function(result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];
            return result;
        }, {});
    }
    function getByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string' && hasOwn(obj, keyPath)) return obj[keyPath];
        if (!keyPath) return obj;
        if (typeof keyPath !== 'string') {
            var rv = [];
            for(var i = 0, l = keyPath.length; i < l; ++i){
                var val = getByKeyPath(obj, keyPath[i]);
                rv.push(val);
            }
            return rv;
        }
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return undefined;
    }
    function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === undefined) return;
        if ('isFrozen' in Object && Object.isFrozen(obj)) return;
        if (typeof keyPath !== 'string' && 'length' in keyPath) {
            assert(typeof value !== 'string' && 'length' in value);
            for(var i = 0, l = keyPath.length; i < l; ++i){
                setByKeyPath(obj, keyPath[i], value[i]);
            }
        } else {
            var period = keyPath.indexOf('.');
            if (period !== -1) {
                var currentKeyPath = keyPath.substr(0, period);
                var remainingKeyPath = keyPath.substr(period + 1);
                if (remainingKeyPath === "") if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);
                    else delete obj[currentKeyPath];
                } else obj[currentKeyPath] = value;
                else {
                    var innerObj = obj[currentKeyPath];
                    if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};
                    setByKeyPath(innerObj, remainingKeyPath, value);
                }
            } else {
                if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);
                    else delete obj[keyPath];
                } else obj[keyPath] = value;
            }
        }
    }
    function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);
        else if ('length' in keyPath) [].map.call(keyPath, function(kp) {
            setByKeyPath(obj, kp, undefined);
        });
    }
    function shallowClone(obj) {
        var rv = {};
        for(var m in obj){
            if (hasOwn(obj, m)) rv[m] = obj[m];
        }
        return rv;
    }
    var concat = [].concat;
    function flatten(a) {
        return concat.apply([], a);
    }
    var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(',').concat(flatten([
        8,
        16,
        32,
        64
    ].map(function(num) {
        return [
            "Int",
            "Uint",
            "Float"
        ].map(function(t) {
            return t + num + "Array";
        });
    }))).filter(function(t) {
        return _global[t];
    });
    var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
        return _global[t];
    }));
    function cloneSimpleObjectTree(o) {
        var rv = {};
        for(var k in o)if (hasOwn(o, k)) {
            var v = o[k];
            rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
        }
        return rv;
    }
    function objectIsEmpty(o) {
        for(var k in o)if (hasOwn(o, k)) return false;
        return true;
    }
    var circularRefs = null;
    function deepClone(any) {
        circularRefs = new WeakMap();
        var rv = innerDeepClone(any);
        circularRefs = null;
        return rv;
    }
    function innerDeepClone(x) {
        if (!x || typeof x !== 'object') return x;
        var rv = circularRefs.get(x);
        if (rv) return rv;
        if (isArray(x)) {
            rv = [];
            circularRefs.set(x, rv);
            for(var i = 0, l = x.length; i < l; ++i){
                rv.push(innerDeepClone(x[i]));
            }
        } else if (intrinsicTypes.has(x.constructor)) {
            rv = x;
        } else {
            var proto = getProto(x);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs.set(x, rv);
            for(var prop in x){
                if (hasOwn(x, prop)) {
                    rv[prop] = innerDeepClone(x[prop]);
                }
            }
        }
        return rv;
    }
    var toString = {}.toString;
    function toStringTag(o) {
        return toString.call(o).slice(8, -1);
    }
    var iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
    var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
    } : function() {
        return null;
    };
    function delArrayItem(a, x) {
        var i = a.indexOf(x);
        if (i >= 0) a.splice(i, 1);
        return i >= 0;
    }
    var NO_CHAR_ARRAY = {};
    function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
            if (isArray(arrayLike)) return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [
                arrayLike
            ];
            if (it = getIteratorOf(arrayLike)) {
                a = [];
                while(x = it.next(), !x.done)a.push(x.value);
                return a;
            }
            if (arrayLike == null) return [
                arrayLike
            ];
            i = arrayLike.length;
            if (typeof i === 'number') {
                a = new Array(i);
                while(i--)a[i] = arrayLike[i];
                return a;
            }
            return [
                arrayLike
            ];
        }
        i = arguments.length;
        a = new Array(i);
        while(i--)a[i] = arguments[i];
        return a;
    }
    var isAsyncFunction = typeof Symbol !== 'undefined' ? function(fn) {
        return fn[Symbol.toStringTag] === 'AsyncFunction';
    } : function() {
        return false;
    };
    var dexieErrorNames = [
        'Modify',
        'Bulk',
        'OpenFailed',
        'VersionChange',
        'Schema',
        'Upgrade',
        'InvalidTable',
        'MissingAPI',
        'NoSuchDatabase',
        'InvalidArgument',
        'SubTransaction',
        'Unsupported',
        'Internal',
        'DatabaseClosed',
        'PrematureCommit',
        'ForeignAwait'
    ];
    var idbDomErrorNames = [
        'Unknown',
        'Constraint',
        'Data',
        'TransactionInactive',
        'ReadOnly',
        'Version',
        'NotFound',
        'InvalidState',
        'InvalidAccess',
        'Abort',
        'Timeout',
        'QuotaExceeded',
        'Syntax',
        'DataClone'
    ];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
    };
    function DexieError(name, msg) {
        this.name = name;
        this.message = msg;
    }
    derive(DexieError).from(Error).extend({
        toString: function() {
            return this.name + ": " + this.message;
        }
    });
    function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures).map(function(key) {
            return failures[key].toString();
        }).filter(function(v, i, s) {
            return s.indexOf(v) === i;
        }).join('\n');
    }
    function ModifyError(msg, failures, successCount, failedKeys) {
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function(pos) {
            return failures[pos];
        });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, this.failures);
    }
    derive(BulkError).from(DexieError);
    var errnames = errorList.reduce(function(obj, name) {
        return obj[name] = name + "Error", obj;
    }, {});
    var BaseException = DexieError;
    var exceptions = errorList.reduce(function(obj, name) {
        var fullName = name + "Error";
        function DexieError(msgOrInner, inner) {
            this.name = fullName;
            if (!msgOrInner) {
                this.message = defaultTexts[name] || fullName;
                this.inner = null;
            } else if (typeof msgOrInner === 'string') {
                this.message = "".concat(msgOrInner).concat(!inner ? '' : '\n ' + inner);
                this.inner = inner || null;
            } else if (typeof msgOrInner === 'object') {
                this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
                this.inner = msgOrInner;
            }
        }
        derive(DexieError).from(BaseException);
        obj[name] = DexieError;
        return obj;
    }, {});
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
            setProp(rv, "stack", {
                get: function() {
                    return this.inner.stack;
                }
            });
        }
        return rv;
    }
    var fullNameExceptions = errorList.reduce(function(obj, name) {
        if ([
            "Syntax",
            "Type",
            "Range"
        ].indexOf(name) === -1) obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;
    function nop() {}
    function mirror(val) {
        return val;
    }
    function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror) return f2;
        return function(val) {
            return f2(f1(val));
        };
    }
    function callBoth(on1, on2) {
        return function() {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
        };
    }
    function hookCreatingChain(f1, f2) {
        if (f1 === nop) return f2;
        return function() {
            var res = f1.apply(this, arguments);
            if (res !== undefined) arguments[0] = res;
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== undefined ? res2 : res;
        };
    }
    function hookDeletingChain(f1, f2) {
        if (f1 === nop) return f2;
        return function() {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
    }
    function hookUpdatingChain(f1, f2) {
        if (f1 === nop) return f2;
        return function(modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res);
            var onsuccess = this.onsuccess, onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);
        };
    }
    function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop) return f2;
        return function() {
            if (f2.apply(this, arguments) === false) return false;
            return f1.apply(this, arguments);
        };
    }
    function promisableChain(f1, f2) {
        if (f1 === nop) return f2;
        return function() {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === 'function') {
                var thiz = this, i = arguments.length, args = new Array(i);
                while(i--)args[i] = arguments[i];
                return res.then(function() {
                    return f2.apply(thiz, args);
                });
            }
            return f2.apply(this, arguments);
        };
    }
    var debug = typeof location !== 'undefined' && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
        debug = value;
    }
    var INTERNAL = {};
    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ? [] : function() {
        var globalP = Promise.resolve();
        if (typeof crypto === 'undefined' || !crypto.subtle) return [
            globalP,
            getProto(globalP),
            globalP
        ];
        var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([
            0
        ]));
        return [
            nativeP,
            getProto(nativeP),
            globalP
        ];
    }(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    var patchGlobalPromise = !!resolvedGlobalPromise;
    function schedulePhysicalTick() {
        queueMicrotask(physicalTick);
    }
    var asap = function(callback, args) {
        microtickQueue.push([
            callback,
            args
        ]);
        if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
        }
    };
    var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
    var globalPSD = {
        id: 'global',
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: nop,
        pgp: false,
        env: {},
        finalize: nop
    };
    var PSD = globalPSD;
    var microtickQueue = [];
    var numScheduledCalls = 0;
    var tickFinalizers = [];
    function DexiePromise(fn) {
        if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
        this._listeners = [];
        this._lib = false;
        var psd = this._PSD = PSD;
        if (typeof fn !== 'function') {
            if (fn !== INTERNAL) throw new TypeError('Not a function');
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false) handleRejection(this, this._value);
            return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
    }
    var thenProp = {
        get: function() {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
                var _this = this;
                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                var cleanup = possibleAwait && !decrementExpectedAwaits();
                var rv = new DexiePromise(function(resolve, reject) {
                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
                });
                if (this._consoleTask) rv._consoleTask = this._consoleTask;
                return rv;
            }
            then.prototype = INTERNAL;
            return then;
        },
        set: function(value) {
            setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : {
                get: function() {
                    return value;
                },
                set: thenProp.set
            });
        }
    };
    props(DexiePromise.prototype, {
        then: thenProp,
        _then: function(onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function(onRejected) {
            if (arguments.length === 1) return this.then(null, onRejected);
            var type = arguments[0], handler = arguments[1];
            return typeof type === 'function' ? this.then(null, function(err) {
                return err instanceof type ? handler(err) : PromiseReject(err);
            }) : this.then(null, function(err) {
                return err && err.name === type ? handler(err) : PromiseReject(err);
            });
        },
        finally: function(onFinally) {
            return this.then(function(value) {
                return DexiePromise.resolve(onFinally()).then(function() {
                    return value;
                });
            }, function(err) {
                return DexiePromise.resolve(onFinally()).then(function() {
                    return PromiseReject(err);
                });
            });
        },
        timeout: function(ms, msg) {
            var _this = this;
            return ms < Infinity ? new DexiePromise(function(resolve, reject) {
                var handle = setTimeout(function() {
                    return reject(new exceptions.Timeout(msg));
                }, ms);
                _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
            }) : this;
        }
    });
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
    }
    props(DexiePromise, {
        all: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
                if (values.length === 0) resolve([]);
                var remaining = values.length;
                values.forEach(function(a, i) {
                    return DexiePromise.resolve(a).then(function(x) {
                        values[i] = x;
                        if (!--remaining) resolve(values);
                    }, reject);
                });
            });
        },
        resolve: function(value) {
            if (value instanceof DexiePromise) return value;
            if (value && typeof value.then === 'function') return new DexiePromise(function(resolve, reject) {
                value.then(resolve, reject);
            });
            var rv = new DexiePromise(INTERNAL, true, value);
            return rv;
        },
        reject: PromiseReject,
        race: function() {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
                values.map(function(value) {
                    return DexiePromise.resolve(value).then(resolve, reject);
                });
            });
        },
        PSD: {
            get: function() {
                return PSD;
            },
            set: function(value) {
                return PSD = value;
            }
        },
        totalEchoes: {
            get: function() {
                return totalEchoes;
            }
        },
        newPSD: newScope,
        usePSD: usePSD,
        scheduler: {
            get: function() {
                return asap;
            },
            set: function(value) {
                asap = value;
            }
        },
        rejectionMapper: {
            get: function() {
                return rejectionMapper;
            },
            set: function(value) {
                rejectionMapper = value;
            }
        },
        follow: function(fn, zoneProps) {
            return new DexiePromise(function(resolve, reject) {
                return newScope(function(resolve, reject) {
                    var psd = PSD;
                    psd.unhandleds = [];
                    psd.onunhandled = reject;
                    psd.finalize = callBoth(function() {
                        var _this = this;
                        run_at_end_of_this_or_next_physical_tick(function() {
                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                        });
                    }, psd.finalize);
                    fn();
                }, zoneProps, resolve, reject);
            });
        }
    });
    if (NativePromise) {
        if (NativePromise.allSettled) setProp(DexiePromise, "allSettled", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve) {
                if (possiblePromises.length === 0) resolve([]);
                var remaining = possiblePromises.length;
                var results = new Array(remaining);
                possiblePromises.forEach(function(p, i) {
                    return DexiePromise.resolve(p).then(function(value) {
                        return results[i] = {
                            status: "fulfilled",
                            value: value
                        };
                    }, function(reason) {
                        return results[i] = {
                            status: "rejected",
                            reason: reason
                        };
                    }).then(function() {
                        return --remaining || resolve(results);
                    });
                });
            });
        });
        if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, "any", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
                if (possiblePromises.length === 0) reject(new AggregateError([]));
                var remaining = possiblePromises.length;
                var failures = new Array(remaining);
                possiblePromises.forEach(function(p, i) {
                    return DexiePromise.resolve(p).then(function(value) {
                        return resolve(value);
                    }, function(failure) {
                        failures[i] = failure;
                        if (!--remaining) reject(new AggregateError(failures));
                    });
                });
            });
        });
        if (NativePromise.withResolvers) DexiePromise.withResolvers = NativePromise.withResolvers;
    }
    function executePromiseTask(promise, fn) {
        try {
            fn(function(value) {
                if (promise._state !== null) return;
                if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                if (value && typeof value.then === 'function') {
                    executePromiseTask(promise, function(resolve, reject) {
                        value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
                    });
                } else {
                    promise._state = true;
                    promise._value = value;
                    propagateAllListeners(promise);
                }
                if (shouldExecuteTick) endMicroTickScope();
            }, handleRejection.bind(null, promise));
        } catch (ex) {
            handleRejection(promise, ex);
        }
    }
    function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null) return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick) endMicroTickScope();
    }
    function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for(var i = 0, len = listeners.length; i < len; ++i){
            propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(function() {
                if (--numScheduledCalls === 0) finalizePhysicalTick();
            }, []);
        }
    }
    function propagateToListener(promise, listener) {
        if (promise._state === null) {
            promise._listeners.push(listener);
            return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap(callListener, [
            cb,
            promise,
            listener
        ]);
    }
    function callListener(cb, promise, listener) {
        try {
            var ret, value = promise._value;
            if (!promise._state && rejectingErrors.length) rejectingErrors = [];
            ret = debug && promise._consoleTask ? promise._consoleTask.run(function() {
                return cb(value);
            }) : cb(value);
            if (!promise._state && rejectingErrors.indexOf(value) === -1) {
                markErrorAsHandled(promise);
            }
            listener.resolve(ret);
        } catch (e) {
            listener.reject(e);
        } finally{
            if (--numScheduledCalls === 0) finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
        }
    }
    function physicalTick() {
        usePSD(globalPSD, function() {
            beginMicroTickScope() && endMicroTickScope();
        });
    }
    function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
    }
    function endMicroTickScope() {
        var callbacks, i, l;
        do {
            while(microtickQueue.length > 0){
                callbacks = microtickQueue;
                microtickQueue = [];
                l = callbacks.length;
                for(i = 0; i < l; ++i){
                    var item = callbacks[i];
                    item[0].apply(null, item[1]);
                }
            }
        }while (microtickQueue.length > 0)
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function(p) {
            p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while(i)finalizers[--i]();
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap(function() {
            if (--numScheduledCalls === 0) finalizePhysicalTick();
        }, []);
    }
    function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function(p) {
            return p._value === promise._value;
        })) unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while(i)if (unhandledErrors[--i]._value === promise._value) {
            unhandledErrors.splice(i, 1);
            return;
        }
    }
    function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function() {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
                switchToZone(psd, true);
                return fn.apply(this, arguments);
            } catch (e) {
                errorCatcher && errorCatcher(e);
            } finally{
                switchToZone(outerScope, false);
                if (wasRootExec) endMicroTickScope();
            }
        };
    }
    var task = {
        awaits: 0,
        echoes: 0,
        id: 0
    };
    var taskCounter = 0;
    var zoneStack = [];
    var zoneEchoes = 0;
    var totalEchoes = 0;
    var zone_id_counter = 0;
    function newScope(fn, props, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        globalPSD.env;
        psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: {
                value: DexiePromise,
                configurable: true,
                writable: true
            },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject
        } : {};
        if (props) extend(psd, props);
        ++parent.ref;
        psd.finalize = function() {
            --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0) psd.finalize();
        return rv;
    }
    function incrementExpectedAwaits() {
        if (!task.id) task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
    }
    function decrementExpectedAwaits() {
        if (!task.awaits) return false;
        if (--task.awaits === 0) task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
    }
    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
    }
    function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function(x) {
                decrementExpectedAwaits();
                return x;
            }, function(e) {
                decrementExpectedAwaits();
                return rejection(e);
            });
        }
        return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.awaits = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD) return;
        PSD = targetZone;
        if (currentZone === globalPSD) globalPSD.env = snapShot();
        if (patchGlobalPromise) {
            var GlobalPromise = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            if (currentZone.global || targetZone.global) {
                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                GlobalPromise.all = targetEnv.all;
                GlobalPromise.race = targetEnv.race;
                GlobalPromise.resolve = targetEnv.resolve;
                GlobalPromise.reject = targetEnv.reject;
                if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;
                if (targetEnv.any) GlobalPromise.any = targetEnv.any;
            }
        }
    }
    function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject
        } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
        } finally{
            switchToZone(outerScope, false);
        }
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== 'function' ? fn : function() {
            var outerZone = PSD;
            if (possibleAwait) incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
                return fn.apply(this, arguments);
            } finally{
                switchToZone(outerZone, false);
                if (cleanup) queueMicrotask(decrementExpectedAwaits);
            }
        };
    }
    function execInGlobalContext(cb) {
        if (Promise === NativePromise && task.echoes === 0) {
            if (zoneEchoes === 0) {
                cb();
            } else {
                enqueueNativeMicroTask(cb);
            }
        } else {
            setTimeout(cb, 0);
        }
    }
    var rejection = DexiePromise.reject;
    function tempTransaction(db, mode, storeNames, fn) {
        if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {
            if (db._state.openComplete) {
                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
            }
            if (!db._state.isBeingOpened) {
                if (!db._state.autoOpen) return rejection(new exceptions.DatabaseClosed());
                db.open().catch(nop);
            }
            return db._state.dbReadyPromise.then(function() {
                return tempTransaction(db, mode, storeNames, fn);
            });
        } else {
            var trans = db._createTransaction(mode, storeNames, db._dbSchema);
            try {
                trans.create();
                db._state.PR1398_maxLoop = 3;
            } catch (ex) {
                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                    console.warn('Dexie: Need to reopen db');
                    db.close({
                        disableAutoOpen: false
                    });
                    return db.open().then(function() {
                        return tempTransaction(db, mode, storeNames, fn);
                    });
                }
                return rejection(ex);
            }
            return trans._promise(mode, function(resolve, reject) {
                return newScope(function() {
                    PSD.trans = trans;
                    return fn(resolve, reject, trans);
                });
            }).then(function(result) {
                if (mode === 'readwrite') try {
                    trans.idbtrans.commit();
                } catch (_a) {}
                return mode === 'readonly' ? result : trans._completion.then(function() {
                    return result;
                });
            });
        }
    }
    var DEXIE_VERSION = '4.2.0';
    var maxString = String.fromCharCode(65535);
    var minKey = -Infinity;
    var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    var STRING_EXPECTED = "String expected.";
    var connections = [];
    var DBNAMES_DB = '__dbnames';
    var READONLY = 'readonly';
    var READWRITE = 'readwrite';
    function combine(filter1, filter2) {
        return filter1 ? filter2 ? function() {
            return filter1.apply(this, arguments) && filter2.apply(this, arguments);
        } : filter1 : filter2;
    }
    var AnyRange = {
        type: 3,
        lower: -Infinity,
        lowerOpen: false,
        upper: [
            []
        ],
        upperOpen: false
    };
    function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
            if (obj[keyPath] === undefined && keyPath in obj) {
                obj = deepClone(obj);
                delete obj[keyPath];
            }
            return obj;
        } : function(obj) {
            return obj;
        };
    }
    function Entity() {
        throw exceptions.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
    }
    function cmp(a, b) {
        try {
            var ta = type(a);
            var tb = type(b);
            if (ta !== tb) {
                if (ta === 'Array') return 1;
                if (tb === 'Array') return -1;
                if (ta === 'binary') return 1;
                if (tb === 'binary') return -1;
                if (ta === 'string') return 1;
                if (tb === 'string') return -1;
                if (ta === 'Date') return 1;
                if (tb !== 'Date') return NaN;
                return -1;
            }
            switch(ta){
                case 'number':
                case 'Date':
                case 'string':
                    return a > b ? 1 : a < b ? -1 : 0;
                case 'binary':
                    {
                        return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
                    }
                case 'Array':
                    return compareArrays(a, b);
            }
        } catch (_a) {}
        return NaN;
    }
    function compareArrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for(var i = 0; i < l; ++i){
            var res = cmp(a[i], b[i]);
            if (res !== 0) return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function compareUint8Arrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for(var i = 0; i < l; ++i){
            if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function type(x) {
        var t = typeof x;
        if (t !== 'object') return t;
        if (ArrayBuffer.isView(x)) return 'binary';
        var tsTag = toStringTag(x);
        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
    }
    function getUint8Array(a) {
        if (a instanceof Uint8Array) return a;
        if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
    }
    function builtInDeletionTrigger(table, keys, res) {
        var yProps = table.schema.yProps;
        if (!yProps) return res;
        if (keys && res.numFailures > 0) keys = keys.filter(function(_, i) {
            return !res.failures[i];
        });
        return Promise.all(yProps.map(function(_a) {
            var updatesTable = _a.updatesTable;
            return keys ? table.db.table(updatesTable).where('k').anyOf(keys).delete() : table.db.table(updatesTable).clear();
        })).then(function() {
            return res;
        });
    }
    var Table = function() {
        function Table() {}
        Table.prototype._trans = function(mode, fn, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask("Dexie: ".concat(mode === 'readonly' ? 'read' : 'write', " ").concat(this.name));
            function checkTableInTransaction(resolve, reject, trans) {
                if (!trans.schema[tableName]) throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                return fn(trans.idbtrans, trans);
            }
            var wasRootExec = beginMicroTickScope();
            try {
                var p = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
                    return trans._promise(mode, checkTableInTransaction, writeLocked);
                }, {
                    trans: trans,
                    transless: PSD.transless || PSD
                }) : tempTransaction(this.db, mode, [
                    this.name
                ], checkTableInTransaction);
                if (task) {
                    p._consoleTask = task;
                    p = p.catch(function(err) {
                        console.trace(err);
                        return rejection(err);
                    });
                }
                return p;
            } finally{
                if (wasRootExec) endMicroTickScope();
            }
        };
        Table.prototype.get = function(keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);
            if (keyOrCrit == null) return rejection(new exceptions.Type("Invalid argument to Table.get()"));
            return this._trans('readonly', function(trans) {
                return _this.core.get({
                    trans: trans,
                    key: keyOrCrit
                }).then(function(res) {
                    return _this.hook.reading.fire(res);
                });
            }).then(cb);
        };
        Table.prototype.where = function(indexOrCrit) {
            if (typeof indexOrCrit === 'string') return new this.db.WhereClause(this, indexOrCrit);
            if (isArray(indexOrCrit)) return new this.db.WhereClause(this, "[".concat(indexOrCrit.join('+'), "]"));
            var keyPaths = keys(indexOrCrit);
            if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
                if (ix.compound && keyPaths.every(function(keyPath) {
                    return ix.keyPath.indexOf(keyPath) >= 0;
                })) {
                    for(var i = 0; i < keyPaths.length; ++i){
                        if (keyPaths.indexOf(ix.keyPath[i]) === -1) return false;
                    }
                    return true;
                }
                return false;
            }).sort(function(a, b) {
                return a.keyPath.length - b.keyPath.length;
            })[0];
            if (compoundIndex && this.db._maxKey !== maxString) {
                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
                return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
                    return indexOrCrit[kp];
                }));
            }
            if (!compoundIndex && debug) console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join('+'), "]"));
            var idxByName = this.schema.idxByName;
            function equals(a, b) {
                return cmp(a, b) === 0;
            }
            var _a = keyPaths.reduce(function(_a, keyPath) {
                var prevIndex = _a[0], prevFilterFn = _a[1];
                var index = idxByName[keyPath];
                var value = indexOrCrit[keyPath];
                return [
                    prevIndex || index,
                    prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function(x) {
                        var prop = getByKeyPath(x, keyPath);
                        return isArray(prop) && prop.some(function(item) {
                            return equals(value, item);
                        });
                    } : function(x) {
                        return equals(value, getByKeyPath(x, keyPath));
                    }) : prevFilterFn
                ];
            }, [
                null,
                null
            ]), idx = _a[0], filterFunction = _a[1];
            return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals('');
        };
        Table.prototype.filter = function(filterFunction) {
            return this.toCollection().and(filterFunction);
        };
        Table.prototype.count = function(thenShortcut) {
            return this.toCollection().count(thenShortcut);
        };
        Table.prototype.offset = function(offset) {
            return this.toCollection().offset(offset);
        };
        Table.prototype.limit = function(numRows) {
            return this.toCollection().limit(numRows);
        };
        Table.prototype.each = function(callback) {
            return this.toCollection().each(callback);
        };
        Table.prototype.toArray = function(thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
        };
        Table.prototype.toCollection = function() {
            return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table.prototype.orderBy = function(index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? "[".concat(index.join('+'), "]") : index));
        };
        Table.prototype.reverse = function() {
            return this.toCollection().reverse();
        };
        Table.prototype.mapToClass = function(constructor) {
            var _a = this, db = _a.db, tableName = _a.name;
            this.schema.mappedClass = constructor;
            if (constructor.prototype instanceof Entity) {
                constructor = function(_super) {
                    __extends(class_1, _super);
                    function class_1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Object.defineProperty(class_1.prototype, "db", {
                        get: function() {
                            return db;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    class_1.prototype.table = function() {
                        return tableName;
                    };
                    return class_1;
                }(constructor);
            }
            var inheritedProps = new Set();
            for(var proto = constructor.prototype; proto; proto = getProto(proto)){
                Object.getOwnPropertyNames(proto).forEach(function(propName) {
                    return inheritedProps.add(propName);
                });
            }
            var readHook = function(obj) {
                if (!obj) return obj;
                var res = Object.create(constructor.prototype);
                for(var m in obj)if (!inheritedProps.has(m)) try {
                    res[m] = obj[m];
                } catch (_) {}
                return res;
            };
            if (this.schema.readHook) {
                this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
        };
        Table.prototype.defineClass = function() {
            function Class(content) {
                extend(this, content);
            }
            return this.mapToClass(Class);
        };
        Table.prototype.add = function(obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function(trans) {
                return _this.core.mutate({
                    trans: trans,
                    type: 'add',
                    keys: key != null ? [
                        key
                    ] : null,
                    values: [
                        objToAdd
                    ]
                });
            }).then(function(res) {
                return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    } catch (_) {}
                }
                return lastResult;
            });
        };
        Table.prototype.update = function(keyOrObject, modifications) {
            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                if (key === undefined) return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                return this.where(":id").equals(key).modify(modifications);
            } else {
                return this.where(":id").equals(keyOrObject).modify(modifications);
            }
        };
        Table.prototype.put = function(obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function(trans) {
                return _this.core.mutate({
                    trans: trans,
                    type: 'put',
                    values: [
                        objToAdd
                    ],
                    keys: key != null ? [
                        key
                    ] : null
                });
            }).then(function(res) {
                return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
            }).then(function(lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    } catch (_) {}
                }
                return lastResult;
            });
        };
        Table.prototype.delete = function(key) {
            var _this = this;
            return this._trans('readwrite', function(trans) {
                return _this.core.mutate({
                    trans: trans,
                    type: 'delete',
                    keys: [
                        key
                    ]
                }).then(function(res) {
                    return builtInDeletionTrigger(_this, [
                        key
                    ], res);
                }).then(function(res) {
                    return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;
                });
            });
        };
        Table.prototype.clear = function() {
            var _this = this;
            return this._trans('readwrite', function(trans) {
                return _this.core.mutate({
                    trans: trans,
                    type: 'deleteRange',
                    range: AnyRange
                }).then(function(res) {
                    return builtInDeletionTrigger(_this, null, res);
                });
            }).then(function(res) {
                return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;
            });
        };
        Table.prototype.bulkGet = function(keys) {
            var _this = this;
            return this._trans('readonly', function(trans) {
                return _this.core.getMany({
                    keys: keys,
                    trans: trans
                }).then(function(result) {
                    return result.map(function(res) {
                        return _this.hook.reading.fire(res);
                    });
                });
            });
        };
        Table.prototype.bulkAdd = function(objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function(trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys) throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
                return _this.core.mutate({
                    trans: trans,
                    type: 'add',
                    keys: keys,
                    values: objectsToAdd,
                    wantResults: wantResults
                }).then(function(_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0) return result;
                    throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                });
            });
        };
        Table.prototype.bulkPut = function(objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function(trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys) throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
                return _this.core.mutate({
                    trans: trans,
                    type: 'put',
                    keys: keys,
                    values: objectsToPut,
                    wantResults: wantResults
                }).then(function(_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0) return result;
                    throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                });
            });
        };
        Table.prototype.bulkUpdate = function(keysAndChanges) {
            var _this = this;
            var coreTable = this.core;
            var keys = keysAndChanges.map(function(entry) {
                return entry.key;
            });
            var changeSpecs = keysAndChanges.map(function(entry) {
                return entry.changes;
            });
            var offsetMap = [];
            return this._trans('readwrite', function(trans) {
                return coreTable.getMany({
                    trans: trans,
                    keys: keys,
                    cache: 'clone'
                }).then(function(objs) {
                    var resultKeys = [];
                    var resultObjs = [];
                    keysAndChanges.forEach(function(_a, idx) {
                        var key = _a.key, changes = _a.changes;
                        var obj = objs[idx];
                        if (obj) {
                            for(var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++){
                                var keyPath = _b[_i];
                                var value = changes[keyPath];
                                if (keyPath === _this.schema.primKey.keyPath) {
                                    if (cmp(value, key) !== 0) {
                                        throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                                    }
                                } else {
                                    setByKeyPath(obj, keyPath, value);
                                }
                            }
                            offsetMap.push(idx);
                            resultKeys.push(key);
                            resultObjs.push(obj);
                        }
                    });
                    var numEntries = resultKeys.length;
                    return coreTable.mutate({
                        trans: trans,
                        type: 'put',
                        keys: resultKeys,
                        values: resultObjs,
                        updates: {
                            keys: keys,
                            changeSpecs: changeSpecs
                        }
                    }).then(function(_a) {
                        var numFailures = _a.numFailures, failures = _a.failures;
                        if (numFailures === 0) return numEntries;
                        for(var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++){
                            var offset = _b[_i];
                            var mappedOffset = offsetMap[Number(offset)];
                            if (mappedOffset != null) {
                                var failure = failures[offset];
                                delete failures[offset];
                                failures[mappedOffset] = failure;
                            }
                        }
                        throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
                    });
                });
            });
        };
        Table.prototype.bulkDelete = function(keys) {
            var _this = this;
            var numKeys = keys.length;
            return this._trans('readwrite', function(trans) {
                return _this.core.mutate({
                    trans: trans,
                    type: 'delete',
                    keys: keys
                }).then(function(res) {
                    return builtInDeletionTrigger(_this, keys, res);
                });
            }).then(function(_a) {
                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;
                if (numFailures === 0) return lastResult;
                throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
            });
        };
        return Table;
    }();
    function Events(ctx) {
        var evs = {};
        var rv = function(eventName, subscriber) {
            if (subscriber) {
                var i = arguments.length, args = new Array(i - 1);
                while(--i)args[i - 1] = arguments[i];
                evs[eventName].subscribe.apply(null, args);
                return ctx;
            } else if (typeof eventName === 'string') {
                return evs[eventName];
            }
        };
        rv.addEventType = add;
        for(var i = 1, l = arguments.length; i < l; ++i){
            add(arguments[i]);
        }
        return rv;
        //TURBOPACK unreachable
        ;
        function add(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === 'object') return addConfiguredEvents(eventName);
            if (!chainFunction) chainFunction = reverseStoppableEventChain;
            if (!defaultFunction) defaultFunction = nop;
            var context = {
                subscribers: [],
                fire: defaultFunction,
                subscribe: function(cb) {
                    if (context.subscribers.indexOf(cb) === -1) {
                        context.subscribers.push(cb);
                        context.fire = chainFunction(context.fire, cb);
                    }
                },
                unsubscribe: function(cb) {
                    context.subscribers = context.subscribers.filter(function(fn) {
                        return fn !== cb;
                    });
                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
        }
        function addConfiguredEvents(cfg) {
            keys(cfg).forEach(function(eventName) {
                var args = cfg[eventName];
                if (isArray(args)) {
                    add(eventName, cfg[eventName][0], cfg[eventName][1]);
                } else if (args === 'asap') {
                    var context = add(eventName, mirror, function fire() {
                        var i = arguments.length, args = new Array(i);
                        while(i--)args[i] = arguments[i];
                        context.subscribers.forEach(function(fn) {
                            asap$1(function fireEvent() {
                                fn.apply(null, args);
                            });
                        });
                    });
                } else throw new exceptions.InvalidArgument("Invalid event config");
            });
        }
    }
    function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({
            prototype: prototype
        });
        return constructor;
    }
    function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
            this.db = db;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
                "creating": [
                    hookCreatingChain,
                    nop
                ],
                "reading": [
                    pureFunctionChain,
                    mirror
                ],
                "updating": [
                    hookUpdatingChain,
                    nop
                ],
                "deleting": [
                    hookDeletingChain,
                    nop
                ]
            });
        });
    }
    function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }
    function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
    }
    function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function() {
            return combine(curr(), factory());
        } : factory;
        ctx.justLimit = isLimitFilter && !curr;
    }
    function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
    }
    function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey) return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index) throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
    }
    function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
            trans: trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === 'prev',
            unique: !!ctx.unique,
            query: {
                index: index,
                range: ctx.range
            }
        });
    }
    function iter(ctx, fn, coreTrans, coreTable) {
        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
        } else {
            var set_1 = {};
            var union = function(item, cursor, advance) {
                if (!filter || filter(cursor, advance, function(result) {
                    return cursor.stop(result);
                }, function(err) {
                    return cursor.fail(err);
                })) {
                    var primaryKey = cursor.primaryKey;
                    var key = '' + primaryKey;
                    if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);
                    if (!hasOwn(set_1, key)) {
                        set_1[key] = true;
                        fn(item, cursor, advance);
                    }
                }
            };
            return Promise.all([
                ctx.or._iterate(union, coreTrans),
                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
        }
    }
    function iterate(cursorPromise, filter, fn, valueMapper) {
        var mappedFn = valueMapper ? function(x, c, a) {
            return fn(valueMapper(x), c, a);
        } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function(cursor) {
            if (cursor) {
                return cursor.start(function() {
                    var c = function() {
                        return cursor.continue();
                    };
                    if (!filter || filter(cursor, function(advancer) {
                        return c = advancer;
                    }, function(val) {
                        cursor.stop(val);
                        c = nop;
                    }, function(e) {
                        cursor.fail(e);
                        c = nop;
                    })) wrappedFn(cursor.value, cursor, function(advancer) {
                        return c = advancer;
                    });
                    c();
                });
            }
        });
    }
    var PropModification = function() {
        function PropModification(spec) {
            this["@@propmod"] = spec;
        }
        PropModification.prototype.execute = function(value) {
            var _a;
            var spec = this["@@propmod"];
            if (spec.add !== undefined) {
                var term = spec.add;
                if (isArray(term)) {
                    return __spreadArray(__spreadArray([], isArray(value) ? value : [], true), term, true).sort();
                }
                if (typeof term === 'number') return (Number(value) || 0) + term;
                if (typeof term === 'bigint') {
                    try {
                        return BigInt(value) + term;
                    } catch (_b) {
                        return BigInt(0) + term;
                    }
                }
                throw new TypeError("Invalid term ".concat(term));
            }
            if (spec.remove !== undefined) {
                var subtrahend_1 = spec.remove;
                if (isArray(subtrahend_1)) {
                    return isArray(value) ? value.filter(function(item) {
                        return !subtrahend_1.includes(item);
                    }).sort() : [];
                }
                if (typeof subtrahend_1 === 'number') return Number(value) - subtrahend_1;
                if (typeof subtrahend_1 === 'bigint') {
                    try {
                        return BigInt(value) - subtrahend_1;
                    } catch (_c) {
                        return BigInt(0) - subtrahend_1;
                    }
                }
                throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
            }
            var prefixToReplace = (_a = spec.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];
            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {
                return spec.replacePrefix[1] + value.substring(prefixToReplace.length);
            }
            return value;
        };
        return PropModification;
    }();
    var Collection = function() {
        function Collection() {}
        Collection.prototype._read = function(fn, cb) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readonly', fn).then(cb);
        };
        Collection.prototype._write = function(fn) {
            var ctx = this._ctx;
            return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readwrite', fn, "locked");
        };
        Collection.prototype._addAlgorithm = function(fn) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection.prototype._iterate = function(fn, coreTrans) {
            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection.prototype.clone = function(props) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props) extend(ctx, props);
            rv._ctx = ctx;
            return rv;
        };
        Collection.prototype.raw = function() {
            this._ctx.valueMapper = null;
            return this;
        };
        Collection.prototype.each = function(fn) {
            var ctx = this._ctx;
            return this._read(function(trans) {
                return iter(ctx, fn, trans, ctx.table.core);
            });
        };
        Collection.prototype.count = function(cb) {
            var _this = this;
            return this._read(function(trans) {
                var ctx = _this._ctx;
                var coreTable = ctx.table.core;
                if (isPlainKeyRange(ctx, true)) {
                    return coreTable.count({
                        trans: trans,
                        query: {
                            index: getIndexOrStore(ctx, coreTable.schema),
                            range: ctx.range
                        }
                    }).then(function(count) {
                        return Math.min(count, ctx.limit);
                    });
                } else {
                    var count = 0;
                    return iter(ctx, function() {
                        ++count;
                        return false;
                    }, trans, coreTable).then(function() {
                        return count;
                    });
                }
            }).then(cb);
        };
        Collection.prototype.sortBy = function(keyPath, cb) {
            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
                if (i) return getval(obj[parts[i]], i - 1);
                return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
                return cmp(aVal, bVal) * order;
            }
            return this.toArray(function(a) {
                return a.sort(sorter);
            }).then(cb);
        };
        Collection.prototype.toArray = function(cb) {
            var _this = this;
            return this._read(function(trans) {
                var ctx = _this._ctx;
                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                    var valueMapper_1 = ctx.valueMapper;
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        limit: ctx.limit,
                        values: true,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    }).then(function(_a) {
                        var result = _a.result;
                        return valueMapper_1 ? result.map(valueMapper_1) : result;
                    });
                } else {
                    var a_1 = [];
                    return iter(ctx, function(item) {
                        return a_1.push(item);
                    }, trans, ctx.table.core).then(function() {
                        return a_1;
                    });
                }
            }, cb);
        };
        Collection.prototype.offset = function(offset) {
            var ctx = this._ctx;
            if (offset <= 0) return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
                addReplayFilter(ctx, function() {
                    var offsetLeft = offset;
                    return function(cursor, advance) {
                        if (offsetLeft === 0) return true;
                        if (offsetLeft === 1) {
                            --offsetLeft;
                            return false;
                        }
                        advance(function() {
                            cursor.advance(offsetLeft);
                            offsetLeft = 0;
                        });
                        return false;
                    };
                });
            } else {
                addReplayFilter(ctx, function() {
                    var offsetLeft = offset;
                    return function() {
                        return --offsetLeft < 0;
                    };
                });
            }
            return this;
        };
        Collection.prototype.limit = function(numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function() {
                var rowsLeft = numRows;
                return function(cursor, advance, resolve) {
                    if (--rowsLeft <= 0) advance(resolve);
                    return rowsLeft >= 0;
                };
            }, true);
            return this;
        };
        Collection.prototype.until = function(filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function(cursor, advance, resolve) {
                if (filterFunction(cursor.value)) {
                    advance(resolve);
                    return bIncludeStopEntry;
                } else {
                    return true;
                }
            });
            return this;
        };
        Collection.prototype.first = function(cb) {
            return this.limit(1).toArray(function(a) {
                return a[0];
            }).then(cb);
        };
        Collection.prototype.last = function(cb) {
            return this.reverse().first(cb);
        };
        Collection.prototype.filter = function(filterFunction) {
            addFilter(this._ctx, function(cursor) {
                return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
        };
        Collection.prototype.and = function(filter) {
            return this.filter(filter);
        };
        Collection.prototype.or = function(indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection.prototype.reverse = function() {
            this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
            if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);
            return this;
        };
        Collection.prototype.desc = function() {
            return this.reverse();
        };
        Collection.prototype.eachKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor) {
                cb(cursor.key, cursor);
            });
        };
        Collection.prototype.eachUniqueKey = function(cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
        };
        Collection.prototype.eachPrimaryKey = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function(val, cursor) {
                cb(cursor.primaryKey, cursor);
            });
        };
        Collection.prototype.keys = function(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor) {
                a.push(cursor.key);
            }).then(function() {
                return a;
            }).then(cb);
        };
        Collection.prototype.primaryKeys = function(cb) {
            var ctx = this._ctx;
            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                return this._read(function(trans) {
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        values: false,
                        limit: ctx.limit,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    });
                }).then(function(_a) {
                    var result = _a.result;
                    return result;
                }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function(item, cursor) {
                a.push(cursor.primaryKey);
            }).then(function() {
                return a;
            }).then(cb);
        };
        Collection.prototype.uniqueKeys = function(cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
        };
        Collection.prototype.firstKey = function(cb) {
            return this.limit(1).keys(function(a) {
                return a[0];
            }).then(cb);
        };
        Collection.prototype.lastKey = function(cb) {
            return this.reverse().firstKey(cb);
        };
        Collection.prototype.distinct = function() {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi) return this;
            var set = {};
            addFilter(this._ctx, function(cursor) {
                var strKey = cursor.primaryKey.toString();
                var found = hasOwn(set, strKey);
                set[strKey] = true;
                return !found;
            });
            return this;
        };
        Collection.prototype.modify = function(changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function(trans) {
                var modifyer;
                if (typeof changes === 'function') {
                    modifyer = changes;
                } else {
                    var keyPaths = keys(changes);
                    var numKeys = keyPaths.length;
                    modifyer = function(item) {
                        var anythingModified = false;
                        for(var i = 0; i < numKeys; ++i){
                            var keyPath = keyPaths[i];
                            var val = changes[keyPath];
                            var origVal = getByKeyPath(item, keyPath);
                            if (val instanceof PropModification) {
                                setByKeyPath(item, keyPath, val.execute(origVal));
                                anythingModified = true;
                            } else if (origVal !== val) {
                                setByKeyPath(item, keyPath, val);
                                anythingModified = true;
                            }
                        }
                        return anythingModified;
                    };
                }
                var coreTable = ctx.table.core;
                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;
                var limit = 200;
                var modifyChunkSize = _this.db._options.modifyChunkSize;
                if (modifyChunkSize) {
                    if (typeof modifyChunkSize == 'object') {
                        limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;
                    } else {
                        limit = modifyChunkSize;
                    }
                }
                var totalFailures = [];
                var successCount = 0;
                var failedKeys = [];
                var applyMutateResult = function(expectedCount, res) {
                    var failures = res.failures, numFailures = res.numFailures;
                    successCount += expectedCount - numFailures;
                    for(var _i = 0, _a = keys(failures); _i < _a.length; _i++){
                        var pos = _a[_i];
                        totalFailures.push(failures[pos]);
                    }
                };
                var isUnconditionalDelete = changes === deleteCallback;
                return _this.clone().primaryKeys().then(function(keys) {
                    var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== 'function' || isUnconditionalDelete) && {
                        index: ctx.index,
                        range: ctx.range
                    };
                    var nextChunk = function(offset) {
                        var count = Math.min(limit, keys.length - offset);
                        var keysInChunk = keys.slice(offset, offset + count);
                        return (isUnconditionalDelete ? Promise.resolve([]) : coreTable.getMany({
                            trans: trans,
                            keys: keysInChunk,
                            cache: "immutable"
                        })).then(function(values) {
                            var addValues = [];
                            var putValues = [];
                            var putKeys = outbound ? [] : null;
                            var deleteKeys = isUnconditionalDelete ? keysInChunk : [];
                            if (!isUnconditionalDelete) for(var i = 0; i < count; ++i){
                                var origValue = values[i];
                                var ctx_1 = {
                                    value: deepClone(origValue),
                                    primKey: keys[offset + i]
                                };
                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                                    if (ctx_1.value == null) {
                                        deleteKeys.push(keys[offset + i]);
                                    } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                                        deleteKeys.push(keys[offset + i]);
                                        addValues.push(ctx_1.value);
                                    } else {
                                        putValues.push(ctx_1.value);
                                        if (outbound) putKeys.push(keys[offset + i]);
                                    }
                                }
                            }
                            return Promise.resolve(addValues.length > 0 && coreTable.mutate({
                                trans: trans,
                                type: 'add',
                                values: addValues
                            }).then(function(res) {
                                for(var pos in res.failures){
                                    deleteKeys.splice(parseInt(pos), 1);
                                }
                                applyMutateResult(addValues.length, res);
                            })).then(function() {
                                return (putValues.length > 0 || criteria && typeof changes === 'object') && coreTable.mutate({
                                    trans: trans,
                                    type: 'put',
                                    keys: putKeys,
                                    values: putValues,
                                    criteria: criteria,
                                    changeSpec: typeof changes !== 'function' && changes,
                                    isAdditionalChunk: offset > 0
                                }).then(function(res) {
                                    return applyMutateResult(putValues.length, res);
                                });
                            }).then(function() {
                                return (deleteKeys.length > 0 || criteria && isUnconditionalDelete) && coreTable.mutate({
                                    trans: trans,
                                    type: 'delete',
                                    keys: deleteKeys,
                                    criteria: criteria,
                                    isAdditionalChunk: offset > 0
                                }).then(function(res) {
                                    return builtInDeletionTrigger(ctx.table, deleteKeys, res);
                                }).then(function(res) {
                                    return applyMutateResult(deleteKeys.length, res);
                                });
                            }).then(function() {
                                return keys.length > offset + count && nextChunk(offset + limit);
                            });
                        });
                    };
                    return nextChunk(0).then(function() {
                        if (totalFailures.length > 0) throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                        return keys.length;
                    });
                });
            });
        };
        Collection.prototype.delete = function() {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) && !ctx.table.schema.yProps && (ctx.isPrimKey || range.type === 3)) {
                return this._write(function(trans) {
                    var primaryKey = ctx.table.core.schema.primaryKey;
                    var coreRange = range;
                    return ctx.table.core.count({
                        trans: trans,
                        query: {
                            index: primaryKey,
                            range: coreRange
                        }
                    }).then(function(count) {
                        return ctx.table.core.mutate({
                            trans: trans,
                            type: 'deleteRange',
                            range: coreRange
                        }).then(function(_a) {
                            var failures = _a.failures, numFailures = _a.numFailures;
                            if (numFailures) throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                                return failures[pos];
                            }), count - numFailures);
                            return count - numFailures;
                        });
                    });
                });
            }
            return this.modify(deleteCallback);
        };
        return Collection;
    }();
    var deleteCallback = function(value, ctx) {
        return ctx.value = null;
    };
    function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
            this.db = db;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator) try {
                keyRange = keyRangeGenerator();
            } catch (ex) {
                error = ex;
            }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
                table: table,
                index: whereCtx.index,
                isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
                range: keyRange,
                keysOnly: false,
                dir: "next",
                unique: "",
                algorithm: null,
                filter: null,
                replayFilter: null,
                justLimit: true,
                isMatch: null,
                offset: 0,
                limit: Infinity,
                error: error,
                or: whereCtx.or,
                valueMapper: readingHook !== mirror ? readingHook : null
            };
        });
    }
    function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
    }
    function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
    }
    function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
    }
    function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function() {
            return rangeEqual("");
        }).limit(0);
    }
    function upperFactory(dir) {
        return dir === "next" ? function(s) {
            return s.toUpperCase();
        } : function(s) {
            return s.toLowerCase();
        };
    }
    function lowerFactory(dir) {
        return dir === "next" ? function(s) {
            return s.toLowerCase();
        } : function(s) {
            return s.toUpperCase();
        };
    }
    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for(var i = 0; i < length; ++i){
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
                if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                return null;
            }
            if (cmp(key[i], lwrKeyChar) < 0) llp = i;
        }
        if (length < lowerNeedle.length && dir === "next") return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev") return key.substr(0, upperNeedle.length);
        return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
    }
    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function(s) {
            return typeof s === 'string';
        })) {
            return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = dir === "next" ? simpleCompare : simpleCompareReverse;
            var needleBounds = needles.map(function(needle) {
                return {
                    lower: lower(needle),
                    upper: upper(needle)
                };
            }).sort(function(a, b) {
                return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function(nb) {
                return nb.upper;
            });
            lowerNeedles = needleBounds.map(function(nb) {
                return nb.lower;
            });
            direction = dir;
            nextKeySuffix = dir === "next" ? "" : suffix;
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function() {
            return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
        });
        c._ondirectionchange = function(direction) {
            initDirection(direction);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            if (typeof key !== 'string') return false;
            var lowerKey = lower(key);
            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                return true;
            } else {
                var lowestPossibleCasing = null;
                for(var i = firstPossibleNeedle; i < needlesLen; ++i){
                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                    if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;
                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                        lowestPossibleCasing = casing;
                    }
                }
                if (lowestPossibleCasing !== null) {
                    advance(function() {
                        cursor.continue(lowestPossibleCasing + nextKeySuffix);
                    });
                } else {
                    advance(resolve);
                }
                return false;
            }
        });
        return c;
    }
    function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
            type: 2,
            lower: lower,
            upper: upper,
            lowerOpen: lowerOpen,
            upperOpen: upperOpen
        };
    }
    function rangeEqual(value) {
        return {
            type: 1,
            lower: value,
            upper: value
        };
    }
    var WhereClause = function() {
        function WhereClause() {}
        Object.defineProperty(WhereClause.prototype, "Collection", {
            get: function() {
                return this._ctx.table.db.Collection;
            },
            enumerable: false,
            configurable: true
        });
        WhereClause.prototype.between = function(lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
                if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);
                return new this.Collection(this, function() {
                    return createRange(lower, upper, !includeLower, !includeUpper);
                });
            } catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
        };
        WhereClause.prototype.equals = function(value) {
            if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
                return rangeEqual(value);
            });
        };
        WhereClause.prototype.above = function(value) {
            if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
                return createRange(value, undefined, true);
            });
        };
        WhereClause.prototype.aboveOrEqual = function(value) {
            if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
                return createRange(value, undefined, false);
            });
        };
        WhereClause.prototype.below = function(value) {
            if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
                return createRange(undefined, value, false, true);
            });
        };
        WhereClause.prototype.belowOrEqual = function(value) {
            if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function() {
                return createRange(undefined, value);
            });
        };
        WhereClause.prototype.startsWith = function(str) {
            if (typeof str !== 'string') return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
        };
        WhereClause.prototype.startsWithIgnoreCase = function(str) {
            if (str === "") return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
                return x.indexOf(a[0]) === 0;
            }, [
                str
            ], maxString);
        };
        WhereClause.prototype.equalsIgnoreCase = function(str) {
            return addIgnoreCaseAlgorithm(this, function(x, a) {
                return x === a[0];
            }, [
                str
            ], "");
        };
        WhereClause.prototype.anyOfIgnoreCase = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0) return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
                return a.indexOf(x) !== -1;
            }, set, "");
        };
        WhereClause.prototype.startsWithAnyOfIgnoreCase = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0) return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function(x, a) {
                return a.some(function(n) {
                    return x.indexOf(n) === 0;
                });
            }, set, maxString);
        };
        WhereClause.prototype.anyOf = function() {
            var _this = this;
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
                set.sort(compare);
            } catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0) return emptyCollection(this);
            var c = new this.Collection(this, function() {
                return createRange(set[0], set[set.length - 1]);
            });
            c._ondirectionchange = function(direction) {
                compare = direction === "next" ? _this._ascending : _this._descending;
                set.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function(cursor, advance, resolve) {
                var key = cursor.key;
                while(compare(key, set[i]) > 0){
                    ++i;
                    if (i === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (compare(key, set[i]) === 0) {
                    return true;
                } else {
                    advance(function() {
                        cursor.continue(set[i]);
                    });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.notEqual = function(value) {
            return this.inAnyRange([
                [
                    minKey,
                    value
                ],
                [
                    value,
                    this.db._maxKey
                ]
            ], {
                includeLowers: false,
                includeUppers: false
            });
        };
        WhereClause.prototype.noneOf = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0) return new this.Collection(this);
            try {
                set.sort(this._ascending);
            } catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set.reduce(function(res, val) {
                return res ? res.concat([
                    [
                        res[res.length - 1][1],
                        val
                    ]
                ]) : [
                    [
                        minKey,
                        val
                    ]
                ];
            }, null);
            ranges.push([
                set[set.length - 1],
                this.db._maxKey
            ]);
            return this.inAnyRange(ranges, {
                includeLowers: false,
                includeUppers: false
            });
        };
        WhereClause.prototype.inAnyRange = function(ranges, options) {
            var _this = this;
            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0) return emptyCollection(this);
            if (!ranges.every(function(range) {
                return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;
            })) {
                return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options || options.includeLowers !== false;
            var includeUppers = options && options.includeUppers === true;
            function addRange(ranges, newRange) {
                var i = 0, l = ranges.length;
                for(; i < l; ++i){
                    var range = ranges[i];
                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                        range[0] = min(range[0], newRange[0]);
                        range[1] = max(range[1], newRange[1]);
                        break;
                    }
                }
                if (i === l) ranges.push(newRange);
                return ranges;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) {
                return sortDirection(a[0], b[0]);
            }
            var set;
            try {
                set = ranges.reduce(addRange, []);
                set.sort(rangeSorter);
            } catch (ex) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
                return ascending(key, set[rangePos][1]) > 0;
            } : function(key) {
                return ascending(key, set[rangePos][1]) >= 0;
            };
            var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
                return descending(key, set[rangePos][0]) > 0;
            } : function(key) {
                return descending(key, set[rangePos][0]) >= 0;
            };
            function keyWithinCurrentRange(key) {
                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function() {
                return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
            });
            c._ondirectionchange = function(direction) {
                if (direction === "next") {
                    checkKey = keyIsBeyondCurrentEntry;
                    sortDirection = ascending;
                } else {
                    checkKey = keyIsBeforeCurrentEntry;
                    sortDirection = descending;
                }
                set.sort(rangeSorter);
            };
            c._addAlgorithm(function(cursor, advance, resolve) {
                var key = cursor.key;
                while(checkKey(key)){
                    ++rangePos;
                    if (rangePos === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (keyWithinCurrentRange(key)) {
                    return true;
                } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                    return false;
                } else {
                    advance(function() {
                        if (sortDirection === ascending) cursor.continue(set[rangePos][0]);
                        else cursor.continue(set[rangePos][1]);
                    });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.startsWithAnyOf = function() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(function(s) {
                return typeof s === 'string';
            })) {
                return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0) return emptyCollection(this);
            return this.inAnyRange(set.map(function(str) {
                return [
                    str,
                    str + maxString
                ];
            }));
        };
        return WhereClause;
    }();
    function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
            this.db = db;
            this._ctx = {
                table: table,
                index: index === ":id" ? null : index,
                or: orCollection
            };
            this._cmp = this._ascending = cmp;
            this._descending = function(a, b) {
                return cmp(b, a);
            };
            this._max = function(a, b) {
                return cmp(a, b) > 0 ? a : b;
            };
            this._min = function(a, b) {
                return cmp(a, b) < 0 ? a : b;
            };
            this._IDBKeyRange = db._deps.IDBKeyRange;
            if (!this._IDBKeyRange) throw new exceptions.MissingAPI();
        });
    }
    function eventRejectHandler(reject) {
        return wrap(function(event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
        });
    }
    function preventDefault(event) {
        if (event.stopPropagation) event.stopPropagation();
        if (event.preventDefault) event.preventDefault();
    }
    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
    var Transaction = function() {
        function Transaction() {}
        Transaction.prototype._lock = function() {
            assert(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;
            return this;
        };
        Transaction.prototype._unlock = function() {
            assert(!PSD.global);
            if (--this._reculock === 0) {
                if (!PSD.global) PSD.lockOwnerFor = null;
                while(this._blockedFuncs.length > 0 && !this._locked()){
                    var fnAndPSD = this._blockedFuncs.shift();
                    try {
                        usePSD(fnAndPSD[1], fnAndPSD[0]);
                    } catch (e) {}
                }
            }
            return this;
        };
        Transaction.prototype._locked = function() {
            return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction.prototype.create = function(idbtrans) {
            var _this = this;
            if (!this.mode) return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
                switch(dbOpenError && dbOpenError.name){
                    case "DatabaseClosedError":
                        throw new exceptions.DatabaseClosed(dbOpenError);
                    case "MissingAPIError":
                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                    default:
                        throw new exceptions.OpenFailed(dbOpenError);
                }
            }
            if (!this.active) throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {
                durability: this.chromeTransactionDurability
            }) : idbdb.transaction(this.storeNames, this.mode, {
                durability: this.chromeTransactionDurability
            }));
            idbtrans.onerror = wrap(function(ev) {
                preventDefault(ev);
                _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function(ev) {
                preventDefault(ev);
                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
                _this.active = false;
                _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function() {
                _this.active = false;
                _this._resolve();
                if ('mutatedParts' in idbtrans) {
                    globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
                }
            });
            return this;
        };
        Transaction.prototype._promise = function(mode, fn, bWriteLock) {
            var _this = this;
            if (mode === 'readwrite' && this.mode !== 'readwrite') return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active) return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
                return new DexiePromise(function(resolve, reject) {
                    _this._blockedFuncs.push([
                        function() {
                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                        },
                        PSD
                    ]);
                });
            } else if (bWriteLock) {
                return newScope(function() {
                    var p = new DexiePromise(function(resolve, reject) {
                        _this._lock();
                        var rv = fn(resolve, reject, _this);
                        if (rv && rv.then) rv.then(resolve, reject);
                    });
                    p.finally(function() {
                        return _this._unlock();
                    });
                    p._lib = true;
                    return p;
                });
            } else {
                var p = new DexiePromise(function(resolve, reject) {
                    var rv = fn(resolve, reject, _this);
                    if (rv && rv.then) rv.then(resolve, reject);
                });
                p._lib = true;
                return p;
            }
        };
        Transaction.prototype._root = function() {
            return this.parent ? this.parent._root() : this;
        };
        Transaction.prototype.waitFor = function(promiseLike) {
            var root = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
                root._waitingFor = root._waitingFor.then(function() {
                    return promise;
                });
            } else {
                root._waitingFor = promise;
                root._waitingQueue = [];
                var store = root.idbtrans.objectStore(root.storeNames[0]);
                (function spin() {
                    ++root._spinCount;
                    while(root._waitingQueue.length)root._waitingQueue.shift()();
                    if (root._waitingFor) store.get(-Infinity).onsuccess = spin;
                })();
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise(function(resolve, reject) {
                promise.then(function(res) {
                    return root._waitingQueue.push(wrap(resolve.bind(null, res)));
                }, function(err) {
                    return root._waitingQueue.push(wrap(reject.bind(null, err)));
                }).finally(function() {
                    if (root._waitingFor === currentWaitPromise) {
                        root._waitingFor = null;
                    }
                });
            });
        };
        Transaction.prototype.abort = function() {
            if (this.active) {
                this.active = false;
                if (this.idbtrans) this.idbtrans.abort();
                this._reject(new exceptions.Abort());
            }
        };
        Transaction.prototype.table = function(tableName) {
            var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
            if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
        };
        return Transaction;
    }();
    function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            var _this = this;
            if (mode !== 'readonly') storeNames.forEach(function(storeName) {
                var _a;
                var yProps = (_a = dbschema[storeName]) === null || _a === void 0 ? void 0 : _a.yProps;
                if (yProps) storeNames = storeNames.concat(yProps.map(function(p) {
                    return p.updatesTable;
                }));
            });
            this.db = db;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function(resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
            });
            this._completion.then(function() {
                _this.active = false;
                _this.on.complete.fire();
            }, function(e) {
                var wasActive = _this.active;
                _this.active = false;
                _this.on.error.fire(e);
                _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
                return rejection(e);
            });
        });
    }
    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey, type) {
        return {
            name: name,
            keyPath: keyPath,
            unique: unique,
            multi: multi,
            auto: auto,
            compound: compound,
            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath),
            type: type
        };
    }
    function nameFromKeyPath(keyPath) {
        return typeof keyPath === 'string' ? keyPath : keyPath ? '[' + [].join.call(keyPath, '+') + ']' : "";
    }
    function createTableSchema(name, primKey, indexes) {
        return {
            name: name,
            primKey: primKey,
            indexes: indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function(index) {
                return [
                    index.name,
                    index
                ];
            })
        };
    }
    function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
    }
    var getMaxKey = function(IdbKeyRange) {
        try {
            IdbKeyRange.only([
                []
            ]);
            getMaxKey = function() {
                return [
                    []
                ];
            };
            return [
                []
            ];
        } catch (e) {
            getMaxKey = function() {
                return maxString;
            };
            return maxString;
        }
    };
    function getKeyExtractor(keyPath) {
        if (keyPath == null) {
            return function() {
                return undefined;
            };
        } else if (typeof keyPath === 'string') {
            return getSinglePathKeyExtractor(keyPath);
        } else {
            return function(obj) {
                return getByKeyPath(obj, keyPath);
            };
        }
    }
    function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split('.');
        if (split.length === 1) {
            return function(obj) {
                return obj[keyPath];
            };
        } else {
            return function(obj) {
                return getByKeyPath(obj, keyPath);
            };
        }
    }
    function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
    }
    var _id_counter = 0;
    function getKeyPathAlias(keyPath) {
        return keyPath == null ? ":id" : typeof keyPath === 'string' ? keyPath : "[".concat(keyPath.join('+'), "]");
    }
    function createDBCore(db, IdbKeyRange, tmpTrans) {
        function extractSchema(db, trans) {
            var tables = arrayify(db.objectStoreNames);
            return {
                schema: {
                    name: db.name,
                    tables: tables.map(function(table) {
                        return trans.objectStore(table);
                    }).map(function(store) {
                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                        var compound = isArray(keyPath);
                        var outbound = keyPath == null;
                        var indexByKeyPath = {};
                        var result = {
                            name: store.name,
                            primaryKey: {
                                name: null,
                                isPrimaryKey: true,
                                outbound: outbound,
                                compound: compound,
                                keyPath: keyPath,
                                autoIncrement: autoIncrement,
                                unique: true,
                                extractKey: getKeyExtractor(keyPath)
                            },
                            indexes: arrayify(store.indexNames).map(function(indexName) {
                                return store.index(indexName);
                            }).map(function(index) {
                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;
                                var compound = isArray(keyPath);
                                var result = {
                                    name: name,
                                    compound: compound,
                                    keyPath: keyPath,
                                    unique: unique,
                                    multiEntry: multiEntry,
                                    extractKey: getKeyExtractor(keyPath)
                                };
                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                                return result;
                            }),
                            getIndexByKeyPath: function(keyPath) {
                                return indexByKeyPath[getKeyPathAlias(keyPath)];
                            }
                        };
                        indexByKeyPath[":id"] = result.primaryKey;
                        if (keyPath != null) {
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                        }
                        return result;
                    })
                },
                hasGetAll: tables.length > 0 && 'getAll' in trans.objectStore(tables[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
        }
        function makeIDBKeyRange(range) {
            if (range.type === 3) return null;
            if (range.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
        }
        function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a) {
                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;
                return new Promise(function(resolve, reject) {
                    resolve = wrap(resolve);
                    var store = trans.objectStore(tableName);
                    var outbound = store.keyPath == null;
                    var isAddOrPut = type === "put" || type === "add";
                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange') throw new Error("Invalid operation type: " + type);
                    var length = (keys || values || {
                        length: 1
                    }).length;
                    if (keys && values && keys.length !== values.length) {
                        throw new Error("Given keys array must have same length as given values array.");
                    }
                    if (length === 0) return resolve({
                        numFailures: 0,
                        failures: {},
                        results: [],
                        lastResult: undefined
                    });
                    var req;
                    var reqs = [];
                    var failures = [];
                    var numFailures = 0;
                    var errorHandler = function(event) {
                        ++numFailures;
                        preventDefault(event);
                    };
                    if (type === 'deleteRange') {
                        if (range.type === 4) return resolve({
                            numFailures: numFailures,
                            failures: failures,
                            results: [],
                            lastResult: undefined
                        });
                        if (range.type === 3) reqs.push(req = store.clear());
                        else reqs.push(req = store.delete(makeIDBKeyRange(range)));
                    } else {
                        var _a = isAddOrPut ? outbound ? [
                            values,
                            keys
                        ] : [
                            values,
                            null
                        ] : [
                            keys,
                            null
                        ], args1 = _a[0], args2 = _a[1];
                        if (isAddOrPut) {
                            for(var i = 0; i < length; ++i){
                                reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));
                                req.onerror = errorHandler;
                            }
                        } else {
                            for(var i = 0; i < length; ++i){
                                reqs.push(req = store[type](args1[i]));
                                req.onerror = errorHandler;
                            }
                        }
                    }
                    var done = function(event) {
                        var lastResult = event.target.result;
                        reqs.forEach(function(req, i) {
                            return req.error != null && (failures[i] = req.error);
                        });
                        resolve({
                            numFailures: numFailures,
                            failures: failures,
                            results: type === "delete" ? keys : reqs.map(function(req) {
                                return req.result;
                            }),
                            lastResult: lastResult
                        });
                    };
                    req.onerror = function(event) {
                        errorHandler(event);
                        done(event);
                    };
                    req.onsuccess = done;
                });
            }
            function openCursor(_a) {
                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;
                return new Promise(function(resolve, reject) {
                    resolve = wrap(resolve);
                    var index = query.index, range = query.range;
                    var store = trans.objectStore(tableName);
                    var source = index.isPrimaryKey ? store : store.index(index.name);
                    var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
                    var req = values || !('openKeyCursor' in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = wrap(function(ev) {
                        var cursor = req.result;
                        if (!cursor) {
                            resolve(null);
                            return;
                        }
                        cursor.___id = ++_id_counter;
                        cursor.done = false;
                        var _cursorContinue = cursor.continue.bind(cursor);
                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                        if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                        var _cursorAdvance = cursor.advance.bind(cursor);
                        var doThrowCursorIsNotStarted = function() {
                            throw new Error("Cursor not started");
                        };
                        var doThrowCursorIsStopped = function() {
                            throw new Error("Cursor not stopped");
                        };
                        cursor.trans = trans;
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                        cursor.fail = wrap(reject);
                        cursor.next = function() {
                            var _this = this;
                            var gotOne = 1;
                            return this.start(function() {
                                return gotOne-- ? _this.continue() : _this.stop();
                            }).then(function() {
                                return _this;
                            });
                        };
                        cursor.start = function(callback) {
                            var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                                resolveIteration = wrap(resolveIteration);
                                req.onerror = eventRejectHandler(rejectIteration);
                                cursor.fail = rejectIteration;
                                cursor.stop = function(value) {
                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                    resolveIteration(value);
                                };
                            });
                            var guardedCallback = function() {
                                if (req.result) {
                                    try {
                                        callback();
                                    } catch (err) {
                                        cursor.fail(err);
                                    }
                                } else {
                                    cursor.done = true;
                                    cursor.start = function() {
                                        throw new Error("Cursor behind last entry");
                                    };
                                    cursor.stop();
                                }
                            };
                            req.onsuccess = wrap(function(ev) {
                                req.onsuccess = guardedCallback;
                                guardedCallback();
                            });
                            cursor.continue = _cursorContinue;
                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                            cursor.advance = _cursorAdvance;
                            guardedCallback();
                            return iterationPromise;
                        };
                        resolve(cursor);
                    }, reject);
                });
            }
            function query(hasGetAll) {
                return function(request) {
                    return new Promise(function(resolve, reject) {
                        resolve = wrap(resolve);
                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;
                        var nonInfinitLimit = limit === Infinity ? undefined : limit;
                        var index = query.index, range = query.range;
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        if (limit === 0) return resolve({
                            result: []
                        });
                        if (hasGetAll) {
                            var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                            req.onsuccess = function(event) {
                                return resolve({
                                    result: event.target.result
                                });
                            };
                            req.onerror = eventRejectHandler(reject);
                        } else {
                            var count_1 = 0;
                            var req_1 = values || !('openKeyCursor' in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                            var result_1 = [];
                            req_1.onsuccess = function(event) {
                                var cursor = req_1.result;
                                if (!cursor) return resolve({
                                    result: result_1
                                });
                                result_1.push(values ? cursor.value : cursor.primaryKey);
                                if (++count_1 === limit) return resolve({
                                    result: result_1
                                });
                                cursor.continue();
                            };
                            req_1.onerror = eventRejectHandler(reject);
                        }
                    });
                };
            }
            return {
                name: tableName,
                schema: tableSchema,
                mutate: mutate,
                getMany: function(_a) {
                    var trans = _a.trans, keys = _a.keys;
                    return new Promise(function(resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var length = keys.length;
                        var result = new Array(length);
                        var keyCount = 0;
                        var callbackCount = 0;
                        var req;
                        var successHandler = function(event) {
                            var req = event.target;
                            if ((result[req._pos] = req.result) != null) ;
                            if (++callbackCount === keyCount) resolve(result);
                        };
                        var errorHandler = eventRejectHandler(reject);
                        for(var i = 0; i < length; ++i){
                            var key = keys[i];
                            if (key != null) {
                                req = store.get(keys[i]);
                                req._pos = i;
                                req.onsuccess = successHandler;
                                req.onerror = errorHandler;
                                ++keyCount;
                            }
                        }
                        if (keyCount === 0) resolve(result);
                    });
                },
                get: function(_a) {
                    var trans = _a.trans, key = _a.key;
                    return new Promise(function(resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var req = store.get(key);
                        req.onsuccess = function(event) {
                            return resolve(event.target.result);
                        };
                        req.onerror = eventRejectHandler(reject);
                    });
                },
                query: query(hasGetAll),
                openCursor: openCursor,
                count: function(_a) {
                    var query = _a.query, trans = _a.trans;
                    var index = query.index, range = query.range;
                    return new Promise(function(resolve, reject) {
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                        req.onsuccess = wrap(function(ev) {
                            return resolve(ev.target.result);
                        });
                        req.onerror = eventRejectHandler(reject);
                    });
                }
            };
        }
        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;
        var tables = schema.tables.map(function(tableSchema) {
            return createDbCoreTable(tableSchema);
        });
        var tableMap = {};
        tables.forEach(function(table) {
            return tableMap[table.name] = table;
        });
        return {
            stack: "dbcore",
            transaction: db.transaction.bind(db),
            table: function(name) {
                var result = tableMap[name];
                if (!result) throw new Error("Table '".concat(name, "' not found"));
                return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema: schema
        };
    }
    function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function(down, _a) {
            var create = _a.create;
            return __assign(__assign({}, down), create(down));
        }, stackImpl);
    }
    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
        var IDBKeyRange = _a.IDBKeyRange;
        _a.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
        return {
            dbcore: dbcore
        };
    }
    function generateMiddlewareStacks(db, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(function(table) {
            var tableName = table.name;
            if (db.core.schema.tables.some(function(tbl) {
                return tbl.name === tableName;
            })) {
                table.core = db.core.table(tableName);
                if (db[tableName] instanceof db.Table) {
                    db[tableName].core = table.core;
                }
            }
        });
    }
    function setApiOnPlace(db, objs, tableNames, dbschema) {
        tableNames.forEach(function(tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function(obj) {
                var propDesc = getPropertyDescriptor(obj, tableName);
                if (!propDesc || "value" in propDesc && propDesc.value === undefined) {
                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                        setProp(obj, tableName, {
                            get: function() {
                                return this.table(tableName);
                            },
                            set: function(value) {
                                defineProperty(this, tableName, {
                                    value: value,
                                    writable: true,
                                    configurable: true,
                                    enumerable: true
                                });
                            }
                        });
                    } else {
                        obj[tableName] = new db.Table(tableName, schema);
                    }
                }
            });
        });
    }
    function removeTablesApi(db, objs) {
        objs.forEach(function(obj) {
            for(var key in obj){
                if (obj[key] instanceof db.Table) delete obj[key];
            }
        });
    }
    function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
    }
    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db._dbSchema;
        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {
            globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
            db._storeNames.push('$meta');
        }
        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function() {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
                keys(globalSchema).forEach(function(tableName) {
                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                });
                generateMiddlewareStacks(db, idbUpgradeTrans);
                DexiePromise.follow(function() {
                    return db.on.populate.fire(trans);
                }).catch(rejectTransaction);
            } else {
                generateMiddlewareStacks(db, idbUpgradeTrans);
                return getExistingVersion(db, trans, oldVersion).then(function(oldVersion) {
                    return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans);
                }).catch(rejectTransaction);
            }
        });
    }
    function patchCurrentVersion(db, idbUpgradeTrans) {
        createMissingTables(db._dbSchema, idbUpgradeTrans);
        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {
            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), 'version');
        }
        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);
        var diff = getSchemaDiff(globalSchema, db._dbSchema);
        var _loop_1 = function(tableChange) {
            if (tableChange.change.length || tableChange.recreate) {
                console.warn("Unable to patch indexes of table ".concat(tableChange.name, " because it has changes on the type of index or primary key."));
                return {
                    value: void 0
                };
            }
            var store = idbUpgradeTrans.objectStore(tableChange.name);
            tableChange.add.forEach(function(idx) {
                if (debug) console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange.name, ".").concat(idx.src));
                addIndex(store, idx);
            });
        };
        for(var _i = 0, _a = diff.change; _i < _a.length; _i++){
            var tableChange = _a[_i];
            var state_1 = _loop_1(tableChange);
            if (typeof state_1 === "object") return state_1.value;
        }
    }
    function getExistingVersion(db, trans, oldVersion) {
        if (trans.storeNames.includes('$meta')) {
            return trans.table('$meta').get('version').then(function(metaVersion) {
                return metaVersion != null ? metaVersion : oldVersion;
            });
        } else {
            return DexiePromise.resolve(oldVersion);
        }
    }
    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db._versions;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        var versToRun = versions.filter(function(v) {
            return v._cfg.version >= oldVersion;
        });
        if (versToRun.length === 0) {
            return DexiePromise.resolve();
        }
        versToRun.forEach(function(version) {
            queue.push(function() {
                var oldSchema = globalSchema;
                var newSchema = version._cfg.dbschema;
                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
                globalSchema = db._dbSchema = newSchema;
                var diff = getSchemaDiff(oldSchema, newSchema);
                diff.add.forEach(function(tuple) {
                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                });
                diff.change.forEach(function(change) {
                    if (change.recreate) {
                        throw new exceptions.Upgrade("Not yet support for changing primary key");
                    } else {
                        var store_1 = idbUpgradeTrans.objectStore(change.name);
                        change.add.forEach(function(idx) {
                            return addIndex(store_1, idx);
                        });
                        change.change.forEach(function(idx) {
                            store_1.deleteIndex(idx.name);
                            addIndex(store_1, idx);
                        });
                        change.del.forEach(function(idxName) {
                            return store_1.deleteIndex(idxName);
                        });
                    }
                });
                var contentUpgrade = version._cfg.contentUpgrade;
                if (contentUpgrade && version._cfg.version > oldVersion) {
                    generateMiddlewareStacks(db, idbUpgradeTrans);
                    trans._memoizedTables = {};
                    var upgradeSchema_1 = shallowClone(newSchema);
                    diff.del.forEach(function(table) {
                        upgradeSchema_1[table] = oldSchema[table];
                    });
                    removeTablesApi(db, [
                        db.Transaction.prototype
                    ]);
                    setApiOnPlace(db, [
                        db.Transaction.prototype
                    ], keys(upgradeSchema_1), upgradeSchema_1);
                    trans.schema = upgradeSchema_1;
                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                    if (contentUpgradeIsAsync_1) {
                        incrementExpectedAwaits();
                    }
                    var returnValue_1;
                    var promiseFollowed = DexiePromise.follow(function() {
                        returnValue_1 = contentUpgrade(trans);
                        if (returnValue_1) {
                            if (contentUpgradeIsAsync_1) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue_1.then(decrementor, decrementor);
                            }
                        }
                    });
                    return returnValue_1 && typeof returnValue_1.then === 'function' ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                        return returnValue_1;
                    });
                }
            });
            queue.push(function(idbtrans) {
                var newSchema = version._cfg.dbschema;
                deleteRemovedTables(newSchema, idbtrans);
                removeTablesApi(db, [
                    db.Transaction.prototype
                ]);
                setApiOnPlace(db, [
                    db.Transaction.prototype
                ], db._storeNames, db._dbSchema);
                trans.schema = db._dbSchema;
            });
            queue.push(function(idbtrans) {
                if (db.idbdb.objectStoreNames.contains('$meta')) {
                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {
                        db.idbdb.deleteObjectStore('$meta');
                        delete db._dbSchema.$meta;
                        db._storeNames = db._storeNames.filter(function(name) {
                            return name !== '$meta';
                        });
                    } else {
                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');
                    }
                }
            });
        });
        function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
        }
        return runQueue().then(function() {
            createMissingTables(globalSchema, idbUpgradeTrans);
        });
    }
    function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
            del: [],
            add: [],
            change: []
        };
        var table;
        for(table in oldSchema){
            if (!newSchema[table]) diff.del.push(table);
        }
        for(table in newSchema){
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
                diff.add.push([
                    table,
                    newDef
                ]);
            } else {
                var change = {
                    name: table,
                    def: newDef,
                    recreate: false,
                    del: [],
                    add: [],
                    change: []
                };
                if ('' + (oldDef.primKey.keyPath || '') !== '' + (newDef.primKey.keyPath || '') || oldDef.primKey.auto !== newDef.primKey.auto) {
                    change.recreate = true;
                    diff.change.push(change);
                } else {
                    var oldIndexes = oldDef.idxByName;
                    var newIndexes = newDef.idxByName;
                    var idxName = void 0;
                    for(idxName in oldIndexes){
                        if (!newIndexes[idxName]) change.del.push(idxName);
                    }
                    for(idxName in newIndexes){
                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                        if (!oldIdx) change.add.push(newIdx);
                        else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);
                    }
                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                        diff.change.push(change);
                    }
                }
            }
        }
        return diff;
    }
    function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {
            keyPath: primKey.keyPath,
            autoIncrement: primKey.auto
        } : {
            autoIncrement: primKey.auto
        });
        indexes.forEach(function(idx) {
            return addIndex(store, idx);
        });
        return store;
    }
    function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function(tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                if (debug) console.debug('Dexie: Creating missing table', tableName);
                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
        });
    }
    function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
    }
    function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, {
            unique: idx.unique,
            multiEntry: idx.multi
        });
    }
    function buildGlobalSchema(db, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function(storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for(var j = 0; j < store.indexNames.length; ++j){
                var idbindex = store.index(store.indexNames[j]);
                keyPath = idbindex.keyPath;
                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
                indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
    }
    function readGlobalSchema(db, idbdb, tmpTrans) {
        db.verno = idbdb.version / 10;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [
            db._allTables
        ], keys(globalSchema), globalSchema);
    }
    function verifyInstalledSchema(db, tmpTrans) {
        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(function(ch) {
            return ch.add.length || ch.change.length;
        }));
    }
    function adjustToExistingIndexNames(db, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for(var i = 0; i < storeNames.length; ++i){
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db._hasGetAll = 'getAll' in store;
            for(var j = 0; j < store.indexNames.length; ++j){
                var indexName = store.indexNames[j];
                var keyPath = store.index(indexName).keyPath;
                var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                if (schema[storeName]) {
                    var indexSpec = schema[storeName].idxByName[dexieName];
                    if (indexSpec) {
                        indexSpec.name = indexName;
                        delete schema[storeName].idxByName[dexieName];
                        schema[storeName].idxByName[indexName] = indexSpec;
                    }
                }
            }
        }
        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db._hasGetAll = false;
        }
    }
    function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(',').map(function(index, indexNum) {
            var _a;
            var typeSplit = index.split(':');
            var type = (_a = typeSplit[1]) === null || _a === void 0 ? void 0 : _a.trim();
            index = typeSplit[0].trim();
            var name = index.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0, type);
        });
    }
    var Version = function() {
        function Version() {}
        Version.prototype._createTableSchema = function(name, primKey, indexes) {
            return createTableSchema(name, primKey, indexes);
        };
        Version.prototype._parseIndexSyntax = function(primKeyAndIndexes) {
            return parseIndexSyntax(primKeyAndIndexes);
        };
        Version.prototype._parseStoresSpec = function(stores, outSchema) {
            var _this = this;
            keys(stores).forEach(function(tableName) {
                if (stores[tableName] !== null) {
                    var indexes = _this._parseIndexSyntax(stores[tableName]);
                    var primKey = indexes.shift();
                    if (!primKey) {
                        throw new exceptions.Schema('Invalid schema for table ' + tableName + ': ' + stores[tableName]);
                    }
                    primKey.unique = true;
                    if (primKey.multi) throw new exceptions.Schema('Primary key cannot be multiEntry*');
                    indexes.forEach(function(idx) {
                        if (idx.auto) throw new exceptions.Schema('Only primary key can be marked as autoIncrement (++)');
                        if (!idx.keyPath) throw new exceptions.Schema('Index must have a name and cannot be an empty string');
                    });
                    var tblSchema = _this._createTableSchema(tableName, primKey, indexes);
                    outSchema[tableName] = tblSchema;
                }
            });
        };
        Version.prototype.stores = function(stores) {
            var db = this.db;
            this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
            var versions = db._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function(version) {
                extend(storesSpec, version._cfg.storesSource);
                dbschema = version._cfg.dbschema = {};
                version._parseStoresSpec(storesSpec, dbschema);
            });
            db._dbSchema = dbschema;
            removeTablesApi(db, [
                db._allTables,
                db,
                db.Transaction.prototype
            ]);
            setApiOnPlace(db, [
                db._allTables,
                db,
                db.Transaction.prototype,
                this._cfg.tables
            ], keys(dbschema), dbschema);
            db._storeNames = keys(dbschema);
            return this;
        };
        Version.prototype.upgrade = function(upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
        };
        return Version;
    }();
    function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, function Version(versionNumber) {
            this.db = db;
            this._cfg = {
                version: versionNumber,
                storesSource: null,
                dbschema: {},
                tables: {},
                contentUpgrade: null
            };
        });
    }
    function getDbNamesTable(indexedDB1, IDBKeyRange) {
        var dbNamesDB = indexedDB1["_dbNamesDB"];
        if (!dbNamesDB) {
            dbNamesDB = indexedDB1["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
                addons: [],
                indexedDB: indexedDB1,
                IDBKeyRange: IDBKeyRange
            });
            dbNamesDB.version(1).stores({
                dbnames: "name"
            });
        }
        return dbNamesDB.table("dbnames");
    }
    function hasDatabasesNative(indexedDB1) {
        return indexedDB1 && typeof indexedDB1.databases === "function";
    }
    function getDatabaseNames(_a) {
        var indexedDB1 = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        return hasDatabasesNative(indexedDB1) ? Promise.resolve(indexedDB1.databases()).then(function(infos) {
            return infos.map(function(info) {
                return info.name;
            }).filter(function(name) {
                return name !== DBNAMES_DB;
            });
        }) : getDbNamesTable(indexedDB1, IDBKeyRange).toCollection().primaryKeys();
    }
    function _onDatabaseCreated(_a, name) {
        var indexedDB1 = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).put({
            name: name
        }).catch(nop);
    }
    function _onDatabaseDeleted(_a, name) {
        var indexedDB1 = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).delete(name).catch(nop);
    }
    function vip(fn) {
        return newScope(function() {
            PSD.letThrough = true;
            return fn();
        });
    }
    function idbReady() {
        var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases) return Promise.resolve();
        var intervalId;
        return new Promise(function(resolve) {
            var tryIdb = function() {
                return indexedDB.databases().finally(resolve);
            };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
        }).finally(function() {
            return clearInterval(intervalId);
        });
    }
    var _a;
    function isEmptyRange(node) {
        return !("from" in node);
    }
    var RangeSet = function(fromOrTree, to) {
        if (this) {
            extend(this, arguments.length ? {
                d: 1,
                from: fromOrTree,
                to: arguments.length > 1 ? to : fromOrTree
            } : {
                d: 0
            });
        } else {
            var rv = new RangeSet();
            if (fromOrTree && "d" in fromOrTree) {
                extend(rv, fromOrTree);
            }
            return rv;
        }
    };
    props(RangeSet.prototype, (_a = {
        add: function(rangeSet) {
            mergeRanges(this, rangeSet);
            return this;
        },
        addKey: function(key) {
            addRange(this, key, key);
            return this;
        },
        addKeys: function(keys) {
            var _this = this;
            keys.forEach(function(key) {
                return addRange(_this, key, key);
            });
            return this;
        },
        hasKey: function(key) {
            var node = getRangeSetIterator(this).next(key).value;
            return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;
        }
    }, _a[iteratorSymbol] = function() {
        return getRangeSetIterator(this);
    }, _a));
    function addRange(target, from, to) {
        var diff = cmp(from, to);
        if (isNaN(diff)) return;
        if (diff > 0) throw RangeError();
        if (isEmptyRange(target)) return extend(target, {
            from: from,
            to: to,
            d: 1
        });
        var left = target.l;
        var right = target.r;
        if (cmp(to, target.from) < 0) {
            left ? addRange(left, from, to) : target.l = {
                from: from,
                to: to,
                d: 1,
                l: null,
                r: null
            };
            return rebalance(target);
        }
        if (cmp(from, target.to) > 0) {
            right ? addRange(right, from, to) : target.r = {
                from: from,
                to: to,
                d: 1,
                l: null,
                r: null
            };
            return rebalance(target);
        }
        if (cmp(from, target.from) < 0) {
            target.from = from;
            target.l = null;
            target.d = right ? right.d + 1 : 1;
        }
        if (cmp(to, target.to) > 0) {
            target.to = to;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
            mergeRanges(target, left);
        }
        if (right && rightWasCutOff) {
            mergeRanges(target, right);
        }
    }
    function mergeRanges(target, newSet) {
        function _addRangeSet(target, _a) {
            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;
            addRange(target, from, to);
            if (l) _addRangeSet(target, l);
            if (r) _addRangeSet(target, r);
        }
        if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);
    }
    function rangesOverlap(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done) return false;
        var a = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a.from);
        var b = nextResult2.value;
        while(!nextResult1.done && !nextResult2.done){
            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;
            cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
        }
        return false;
    }
    function getRangeSetIterator(node) {
        var state = isEmptyRange(node) ? null : {
            s: 0,
            n: node
        };
        return {
            next: function(key) {
                var keyProvided = arguments.length > 0;
                while(state){
                    switch(state.s){
                        case 0:
                            state.s = 1;
                            if (keyProvided) {
                                while(state.n.l && cmp(key, state.n.from) < 0)state = {
                                    up: state,
                                    n: state.n.l,
                                    s: 1
                                };
                            } else {
                                while(state.n.l)state = {
                                    up: state,
                                    n: state.n.l,
                                    s: 1
                                };
                            }
                        case 1:
                            state.s = 2;
                            if (!keyProvided || cmp(key, state.n.to) <= 0) return {
                                value: state.n,
                                done: false
                            };
                        case 2:
                            if (state.n.r) {
                                state.s = 3;
                                state = {
                                    up: state,
                                    n: state.n.r,
                                    s: 0
                                };
                                continue;
                            }
                        case 3:
                            state = state.up;
                    }
                }
                return {
                    done: true
                };
            }
        };
    }
    function rebalance(target) {
        var _a, _b;
        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
            var l = r === "r" ? "l" : "r";
            var rootClone = __assign({}, target);
            var oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
    }
    function computeDepth(_a) {
        var r = _a.r, l = _a.l;
        return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
    }
    function extendObservabilitySet(target, newSet) {
        keys(newSet).forEach(function(part) {
            if (target[part]) mergeRanges(target[part], newSet[part]);
            else target[part] = cloneSimpleObjectTree(newSet[part]);
        });
        return target;
    }
    function obsSetsOverlap(os1, os2) {
        return os1.all || os2.all || Object.keys(os1).some(function(key) {
            return os2[key] && rangesOverlap(os2[key], os1[key]);
        });
    }
    var cache = {};
    var unsignaledParts = {};
    var isTaskEnqueued = false;
    function signalSubscribersLazily(part, optimistic) {
        extendObservabilitySet(unsignaledParts, part);
        if (!isTaskEnqueued) {
            isTaskEnqueued = true;
            setTimeout(function() {
                isTaskEnqueued = false;
                var parts = unsignaledParts;
                unsignaledParts = {};
                signalSubscribersNow(parts, false);
            }, 0);
        }
    }
    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
        if (deleteAffectedCacheEntries === void 0) {
            deleteAffectedCacheEntries = false;
        }
        var queriesToSignal = new Set();
        if (updatedParts.all) {
            for(var _i = 0, _a = Object.values(cache); _i < _a.length; _i++){
                var tblCache = _a[_i];
                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
        } else {
            for(var key in updatedParts){
                var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
                if (parts) {
                    var dbName = parts[1], tableName = parts[2];
                    var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                    if (tblCache) collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
                }
            }
        }
        queriesToSignal.forEach(function(requery) {
            return requery();
        });
    }
    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
        var updatedEntryLists = [];
        for(var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++){
            var _b = _a[_i], indexName = _b[0], entries = _b[1];
            var filteredEntries = [];
            for(var _c = 0, entries_1 = entries; _c < entries_1.length; _c++){
                var entry = entries_1[_c];
                if (obsSetsOverlap(updatedParts, entry.obsSet)) {
                    entry.subscribers.forEach(function(requery) {
                        return outQueriesToSignal.add(requery);
                    });
                } else if (deleteAffectedCacheEntries) {
                    filteredEntries.push(entry);
                }
            }
            if (deleteAffectedCacheEntries) updatedEntryLists.push([
                indexName,
                filteredEntries
            ]);
        }
        if (deleteAffectedCacheEntries) {
            for(var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++){
                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
                tblCache.queries.query[indexName] = filteredEntries;
            }
        }
    }
    function dexieOpen(db) {
        var state = db._state;
        var indexedDB1 = db._deps.indexedDB;
        if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(function() {
            return state.dbOpenError ? rejection(state.dbOpenError) : db;
        });
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var openCanceller = state.openCanceller;
        var nativeVerToOpen = Math.round(db.verno * 10);
        var schemaPatchMode = false;
        function throwIfCancelled() {
            if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');
        }
        var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
        var tryOpenDB = function() {
            return new DexiePromise(function(resolve, reject) {
                throwIfCancelled();
                if (!indexedDB1) throw new exceptions.MissingAPI();
                var dbName = db.name;
                var req = state.autoSchema || !nativeVerToOpen ? indexedDB1.open(dbName) : indexedDB1.open(dbName, nativeVerToOpen);
                if (!req) throw new exceptions.MissingAPI();
                req.onerror = eventRejectHandler(reject);
                req.onblocked = wrap(db._fireOnBlocked);
                req.onupgradeneeded = wrap(function(e) {
                    upgradeTransaction = req.transaction;
                    if (state.autoSchema && !db._options.allowEmptyDB) {
                        req.onerror = preventDefault;
                        upgradeTransaction.abort();
                        req.result.close();
                        var delreq = indexedDB1.deleteDatabase(dbName);
                        delreq.onsuccess = delreq.onerror = wrap(function() {
                            reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                        });
                    } else {
                        upgradeTransaction.onerror = eventRejectHandler(reject);
                        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                        wasCreated = oldVer < 1;
                        db.idbdb = req.result;
                        if (schemaPatchMode) {
                            patchCurrentVersion(db, upgradeTransaction);
                        }
                        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                    }
                }, reject);
                req.onsuccess = wrap(function() {
                    upgradeTransaction = null;
                    var idbdb = db.idbdb = req.result;
                    var objectStoreNames = slice(idbdb.objectStoreNames);
                    if (objectStoreNames.length > 0) try {
                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                        if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);
                        else {
                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {
                                console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                                idbdb.close();
                                nativeVerToOpen = idbdb.version + 1;
                                schemaPatchMode = true;
                                return resolve(tryOpenDB());
                            }
                        }
                        generateMiddlewareStacks(db, tmpTrans);
                    } catch (e) {}
                    connections.push(db);
                    idbdb.onversionchange = wrap(function(ev) {
                        state.vcFired = true;
                        db.on("versionchange").fire(ev);
                    });
                    idbdb.onclose = wrap(function(ev) {
                        db.on("close").fire(ev);
                    });
                    if (wasCreated) _onDatabaseCreated(db._deps, dbName);
                    resolve();
                }, reject);
            }).catch(function(err) {
                switch(err === null || err === void 0 ? void 0 : err.name){
                    case "UnknownError":
                        if (state.PR1398_maxLoop > 0) {
                            state.PR1398_maxLoop--;
                            console.warn('Dexie: Workaround for Chrome UnknownError on open()');
                            return tryOpenDB();
                        }
                        break;
                    case "VersionError":
                        if (nativeVerToOpen > 0) {
                            nativeVerToOpen = 0;
                            return tryOpenDB();
                        }
                        break;
                }
                return DexiePromise.reject(err);
            });
        };
        return DexiePromise.race([
            openCanceller,
            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
        ]).then(function() {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function() {
                return db.on.ready.fire(db.vip);
            })).then(function fireRemainders() {
                if (state.onReadyBeingFired.length > 0) {
                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                    state.onReadyBeingFired = [];
                    return DexiePromise.resolve(vip(function() {
                        return remainders_1(db.vip);
                    })).then(fireRemainders);
                }
            });
        }).finally(function() {
            if (state.openCanceller === openCanceller) {
                state.onReadyBeingFired = null;
                state.isBeingOpened = false;
            }
        }).catch(function(err) {
            state.dbOpenError = err;
            try {
                upgradeTransaction && upgradeTransaction.abort();
            } catch (_a) {}
            if (openCanceller === state.openCanceller) {
                db._close();
            }
            return rejection(err);
        }).finally(function() {
            state.openComplete = true;
            resolveDbReady();
        }).then(function() {
            if (wasCreated) {
                var everything_1 = {};
                db.tables.forEach(function(table) {
                    table.schema.indexes.forEach(function(idx) {
                        if (idx.name) everything_1["idb://".concat(db.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet(-Infinity, [
                            [
                                []
                            ]
                        ]);
                    });
                    everything_1["idb://".concat(db.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db.name, "/").concat(table.name, "/:dels")] = new RangeSet(-Infinity, [
                        [
                            []
                        ]
                    ]);
                });
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
                signalSubscribersNow(everything_1, true);
            }
            return db;
        });
    }
    function awaitIterator(iterator) {
        var callNext = function(result) {
            return iterator.next(result);
        }, doThrow = function(error) {
            return iterator.throw(error);
        }, onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
            return function(val) {
                var next = getNext(val), value = next.value;
                return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
            };
        }
        return step(callNext)();
    }
    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2) throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i - 1);
        while(--i)args[i - 1] = arguments[i];
        scopeFunc = args.pop();
        var tables = flatten(args);
        return [
            mode,
            tables,
            scopeFunc
        ];
    }
    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function() {
            var transless = PSD.transless || PSD;
            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
            trans.explicit = true;
            var zoneProps = {
                trans: trans,
                transless: transless
            };
            if (parentTransaction) {
                trans.idbtrans = parentTransaction.idbtrans;
            } else {
                try {
                    trans.create();
                    trans.idbtrans._explicit = true;
                    db._state.PR1398_maxLoop = 3;
                } catch (ex) {
                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                        console.warn('Dexie: Need to reopen db');
                        db.close({
                            disableAutoOpen: false
                        });
                        return db.open().then(function() {
                            return enterTransactionScope(db, mode, storeNames, null, scopeFunc);
                        });
                    }
                    return rejection(ex);
                }
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function() {
                returnValue = scopeFunc.call(trans, trans);
                if (returnValue) {
                    if (scopeFuncIsAsync) {
                        var decrementor = decrementExpectedAwaits.bind(null, null);
                        returnValue.then(decrementor, decrementor);
                    } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                        returnValue = awaitIterator(returnValue);
                    }
                }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue).then(function(x) {
                return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : promiseFollowed.then(function() {
                return returnValue;
            })).then(function(x) {
                if (parentTransaction) trans._resolve();
                return trans._completion.then(function() {
                    return x;
                });
            }).catch(function(e) {
                trans._reject(e);
                return rejection(e);
            });
        });
    }
    function pad(a, value, count) {
        var result = isArray(a) ? a.slice() : [
            a
        ];
        for(var i = 0; i < count; ++i)result.push(value);
        return result;
    }
    function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), {
            table: function(tableName) {
                var table = down.table(tableName);
                var schema = table.schema;
                var indexLookup = {};
                var allVirtualIndexes = [];
                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                    var keyPathAlias = getKeyPathAlias(keyPath);
                    var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                    var isVirtual = keyTail > 0;
                    var virtualIndex = __assign(__assign({}, lowLevelIndex), {
                        name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name,
                        lowLevelIndex: lowLevelIndex,
                        isVirtual: isVirtual,
                        keyTail: keyTail,
                        keyLength: keyLength,
                        extractKey: getKeyExtractor(keyPath),
                        unique: !isVirtual && lowLevelIndex.unique
                    });
                    indexList.push(virtualIndex);
                    if (!virtualIndex.isPrimaryKey) {
                        allVirtualIndexes.push(virtualIndex);
                    }
                    if (keyLength > 1) {
                        var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                    }
                    indexList.sort(function(a, b) {
                        return a.keyTail - b.keyTail;
                    });
                    return virtualIndex;
                }
                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
                indexLookup[":id"] = [
                    primaryKey
                ];
                for(var _i = 0, _a = schema.indexes; _i < _a.length; _i++){
                    var index = _a[_i];
                    addVirtualIndexes(index.keyPath, 0, index);
                }
                function findBestIndex(keyPath) {
                    var result = indexLookup[getKeyPathAlias(keyPath)];
                    return result && result[0];
                }
                function translateRange(range, keyTail) {
                    return {
                        type: range.type === 1 ? 2 : range.type,
                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                        lowerOpen: true,
                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                        upperOpen: true
                    };
                }
                function translateRequest(req) {
                    var index = req.query.index;
                    return index.isVirtual ? __assign(__assign({}, req), {
                        query: {
                            index: index.lowLevelIndex,
                            range: translateRange(req.query.range, index.keyTail)
                        }
                    }) : req;
                }
                var result = __assign(__assign({}, table), {
                    schema: __assign(__assign({}, schema), {
                        primaryKey: primaryKey,
                        indexes: allVirtualIndexes,
                        getIndexByKeyPath: findBestIndex
                    }),
                    count: function(req) {
                        return table.count(translateRequest(req));
                    },
                    query: function(req) {
                        return table.query(translateRequest(req));
                    },
                    openCursor: function(req) {
                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;
                        if (!isVirtual) return table.openCursor(req);
                        function createVirtualCursor(cursor) {
                            function _continue(key) {
                                key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
                            }
                            var virtualCursor = Object.create(cursor, {
                                continue: {
                                    value: _continue
                                },
                                continuePrimaryKey: {
                                    value: function(key, primaryKey) {
                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                    }
                                },
                                primaryKey: {
                                    get: function() {
                                        return cursor.primaryKey;
                                    }
                                },
                                key: {
                                    get: function() {
                                        var key = cursor.key;
                                        return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                                    }
                                },
                                value: {
                                    get: function() {
                                        return cursor.value;
                                    }
                                }
                            });
                            return virtualCursor;
                        }
                        return table.openCursor(translateRequest(req)).then(function(cursor) {
                            return cursor && createVirtualCursor(cursor);
                        });
                    }
                });
                return result;
            }
        });
    }
    var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
    };
    function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || '';
        keys(a).forEach(function(prop) {
            if (!hasOwn(b, prop)) {
                rv[prfx + prop] = undefined;
            } else {
                var ap = a[prop], bp = b[prop];
                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                    var apTypeName = toStringTag(ap);
                    var bpTypeName = toStringTag(bp);
                    if (apTypeName !== bpTypeName) {
                        rv[prfx + prop] = b[prop];
                    } else if (apTypeName === 'Object') {
                        getObjectDiff(ap, bp, rv, prfx + prop + '.');
                    } else if (ap !== bp) {
                        rv[prfx + prop] = b[prop];
                    }
                } else if (ap !== bp) rv[prfx + prop] = b[prop];
            }
        });
        keys(b).forEach(function(prop) {
            if (!hasOwn(a, prop)) {
                rv[prfx + prop] = b[prop];
            }
        });
        return rv;
    }
    function getEffectiveKeys(primaryKey, req) {
        if (req.type === 'delete') return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
    }
    var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: function(downCore) {
            return __assign(__assign({}, downCore), {
                table: function(tableName) {
                    var downTable = downCore.table(tableName);
                    var primaryKey = downTable.schema.primaryKey;
                    var tableMiddleware = __assign(__assign({}, downTable), {
                        mutate: function(req) {
                            var dxTrans = PSD.trans;
                            var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;
                            switch(req.type){
                                case 'add':
                                    if (creating.fire === nop) break;
                                    return dxTrans._promise('readwrite', function() {
                                        return addPutOrDelete(req);
                                    }, true);
                                case 'put':
                                    if (creating.fire === nop && updating.fire === nop) break;
                                    return dxTrans._promise('readwrite', function() {
                                        return addPutOrDelete(req);
                                    }, true);
                                case 'delete':
                                    if (deleting.fire === nop) break;
                                    return dxTrans._promise('readwrite', function() {
                                        return addPutOrDelete(req);
                                    }, true);
                                case 'deleteRange':
                                    if (deleting.fire === nop) break;
                                    return dxTrans._promise('readwrite', function() {
                                        return deleteRange(req);
                                    }, true);
                            }
                            return downTable.mutate(req);
                            //TURBOPACK unreachable
                            ;
                            function addPutOrDelete(req) {
                                var dxTrans = PSD.trans;
                                var keys = req.keys || getEffectiveKeys(primaryKey, req);
                                if (!keys) throw new Error("Keys missing");
                                req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), {
                                    keys: keys
                                }) : __assign({}, req);
                                if (req.type !== 'delete') req.values = __spreadArray([], req.values, true);
                                if (req.keys) req.keys = __spreadArray([], req.keys, true);
                                return getExistingValues(downTable, req, keys).then(function(existingValues) {
                                    var contexts = keys.map(function(key, i) {
                                        var existingValue = existingValues[i];
                                        var ctx = {
                                            onerror: null,
                                            onsuccess: null
                                        };
                                        if (req.type === 'delete') {
                                            deleting.fire.call(ctx, key, existingValue, dxTrans);
                                        } else if (req.type === 'add' || existingValue === undefined) {
                                            var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                            if (key == null && generatedPrimaryKey != null) {
                                                key = generatedPrimaryKey;
                                                req.keys[i] = key;
                                                if (!primaryKey.outbound) {
                                                    setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                                }
                                            }
                                        } else {
                                            var objectDiff = getObjectDiff(existingValue, req.values[i]);
                                            var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                            if (additionalChanges_1) {
                                                var requestedValue_1 = req.values[i];
                                                Object.keys(additionalChanges_1).forEach(function(keyPath) {
                                                    if (hasOwn(requestedValue_1, keyPath)) {
                                                        requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                                                    } else {
                                                        setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                                                    }
                                                });
                                            }
                                        }
                                        return ctx;
                                    });
                                    return downTable.mutate(req).then(function(_a) {
                                        var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;
                                        for(var i = 0; i < keys.length; ++i){
                                            var primKey = results ? results[i] : keys[i];
                                            var ctx = contexts[i];
                                            if (primKey == null) {
                                                ctx.onerror && ctx.onerror(failures[i]);
                                            } else {
                                                ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ? req.values[i] : primKey);
                                            }
                                        }
                                        return {
                                            failures: failures,
                                            results: results,
                                            numFailures: numFailures,
                                            lastResult: lastResult
                                        };
                                    }).catch(function(error) {
                                        contexts.forEach(function(ctx) {
                                            return ctx.onerror && ctx.onerror(error);
                                        });
                                        return Promise.reject(error);
                                    });
                                });
                            }
                            function deleteRange(req) {
                                return deleteNextChunk(req.trans, req.range, 10000);
                            }
                            function deleteNextChunk(trans, range, limit) {
                                return downTable.query({
                                    trans: trans,
                                    values: false,
                                    query: {
                                        index: primaryKey,
                                        range: range
                                    },
                                    limit: limit
                                }).then(function(_a) {
                                    var result = _a.result;
                                    return addPutOrDelete({
                                        type: 'delete',
                                        keys: result,
                                        trans: trans
                                    }).then(function(res) {
                                        if (res.numFailures > 0) return Promise.reject(res.failures[0]);
                                        if (result.length < limit) {
                                            return {
                                                failures: [],
                                                numFailures: 0,
                                                lastResult: undefined
                                            };
                                        } else {
                                            return deleteNextChunk(trans, __assign(__assign({}, range), {
                                                lower: result[result.length - 1],
                                                lowerOpen: true
                                            }), limit);
                                        }
                                    });
                                });
                            }
                        }
                    });
                    return tableMiddleware;
                }
            });
        }
    };
    function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add" ? Promise.resolve([]) : table.getMany({
            trans: req.trans,
            keys: effectiveKeys,
            cache: "immutable"
        });
    }
    function getFromTransactionCache(keys, cache, clone) {
        try {
            if (!cache) return null;
            if (cache.keys.length < keys.length) return null;
            var result = [];
            for(var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i){
                if (cmp(cache.keys[i], keys[j]) !== 0) continue;
                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
                ++j;
            }
            return result.length === keys.length ? result : null;
        } catch (_a) {
            return null;
        }
    }
    var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: function(core) {
            return {
                table: function(tableName) {
                    var table = core.table(tableName);
                    return __assign(__assign({}, table), {
                        getMany: function(req) {
                            if (!req.cache) {
                                return table.getMany(req);
                            }
                            var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                            if (cachedResult) {
                                return DexiePromise.resolve(cachedResult);
                            }
                            return table.getMany(req).then(function(res) {
                                req.trans["_cache"] = {
                                    keys: req.keys,
                                    values: req.cache === "clone" ? deepClone(res) : res
                                };
                                return res;
                            });
                        },
                        mutate: function(req) {
                            if (req.type !== "add") req.trans["_cache"] = null;
                            return table.mutate(req);
                        }
                    });
                }
            };
        }
    };
    function isCachableContext(ctx, table) {
        return ctx.trans.mode === 'readonly' && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== 'disabled' && !table.schema.primaryKey.outbound;
    }
    function isCachableRequest(type, req) {
        switch(type){
            case 'query':
                return req.values && !req.unique;
            case 'get':
                return false;
            case 'getMany':
                return false;
            case 'count':
                return false;
            case 'openCursor':
                return false;
        }
    }
    var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Observability",
        create: function(core) {
            var dbName = core.schema.name;
            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
            return __assign(__assign({}, core), {
                transaction: function(stores, mode, options) {
                    if (PSD.subscr && mode !== 'readonly') {
                        throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
                    }
                    return core.transaction(stores, mode, options);
                },
                table: function(tableName) {
                    var table = core.table(tableName);
                    var schema = table.schema;
                    var primaryKey = schema.primaryKey, indexes = schema.indexes;
                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index) {
                        return index.compound && index.keyPath.includes(primaryKey.keyPath);
                    });
                    var tableClone = __assign(__assign({}, table), {
                        mutate: function(req) {
                            var _a, _b;
                            var trans = req.trans;
                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
                            var getRangeSet = function(indexName) {
                                var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
                            };
                            var pkRangeSet = getRangeSet("");
                            var delsRangeSet = getRangeSet(":dels");
                            var type = req.type;
                            var _c = req.type === "deleteRange" ? [
                                req.range
                            ] : req.type === "delete" ? [
                                req.keys
                            ] : req.values.length < 50 ? [
                                getEffectiveKeys(primaryKey, req).filter(function(id) {
                                    return id;
                                }),
                                req.values
                            ] : [], keys = _c[0], newObjs = _c[1];
                            var oldCache = req.trans["_cache"];
                            if (isArray(keys)) {
                                pkRangeSet.addKeys(keys);
                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;
                                if (!oldObjs) {
                                    delsRangeSet.addKeys(keys);
                                }
                                if (oldObjs || newObjs) {
                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                                }
                            } else if (keys) {
                                var range = {
                                    from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,
                                    to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY
                                };
                                delsRangeSet.add(range);
                                pkRangeSet.add(range);
                            } else {
                                pkRangeSet.add(FULL_RANGE);
                                delsRangeSet.add(FULL_RANGE);
                                schema.indexes.forEach(function(idx) {
                                    return getRangeSet(idx.name).add(FULL_RANGE);
                                });
                            }
                            return table.mutate(req).then(function(res) {
                                if (keys && (req.type === 'add' || req.type === 'put')) {
                                    pkRangeSet.addKeys(res.results);
                                    if (indexesWithAutoIncPK) {
                                        indexesWithAutoIncPK.forEach(function(idx) {
                                            var idxVals = req.values.map(function(v) {
                                                return idx.extractKey(v);
                                            });
                                            var pkPos = idx.keyPath.findIndex(function(prop) {
                                                return prop === primaryKey.keyPath;
                                            });
                                            for(var i = 0, len = res.results.length; i < len; ++i){
                                                idxVals[i][pkPos] = res.results[i];
                                            }
                                            getRangeSet(idx.name).addKeys(idxVals);
                                        });
                                    }
                                }
                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                                return res;
                            });
                        }
                    });
                    var getRange = function(_a) {
                        var _b, _c;
                        var _d = _a.query, index = _d.index, range = _d.range;
                        return [
                            index,
                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
                        ];
                    };
                    var readSubscribers = {
                        get: function(req) {
                            return [
                                primaryKey,
                                new RangeSet(req.key)
                            ];
                        },
                        getMany: function(req) {
                            return [
                                primaryKey,
                                new RangeSet().addKeys(req.keys)
                            ];
                        },
                        count: getRange,
                        query: getRange,
                        openCursor: getRange
                    };
                    keys(readSubscribers).forEach(function(method) {
                        tableClone[method] = function(req) {
                            var subscr = PSD.subscr;
                            var isLiveQuery = !!subscr;
                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                            var obsSet = cachable ? req.obsSet = {} : subscr;
                            if (isLiveQuery) {
                                var getRangeSet = function(indexName) {
                                    var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                    return obsSet[part] || (obsSet[part] = new RangeSet());
                                };
                                var pkRangeSet_1 = getRangeSet("");
                                var delsRangeSet_1 = getRangeSet(":dels");
                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];
                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {
                                    delsRangeSet_1.add(queriedRanges);
                                } else {
                                    getRangeSet(queriedIndex.name || "").add(queriedRanges);
                                }
                                if (!queriedIndex.isPrimaryKey) {
                                    if (method === "count") {
                                        delsRangeSet_1.add(FULL_RANGE);
                                    } else {
                                        var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), {
                                            values: false
                                        }));
                                        return table[method].apply(this, arguments).then(function(res) {
                                            if (method === "query") {
                                                if (outbound && req.values) {
                                                    return keysPromise_1.then(function(_a) {
                                                        var resultingKeys = _a.result;
                                                        pkRangeSet_1.addKeys(resultingKeys);
                                                        return res;
                                                    });
                                                }
                                                var pKeys = req.values ? res.result.map(extractKey) : res.result;
                                                if (req.values) {
                                                    pkRangeSet_1.addKeys(pKeys);
                                                } else {
                                                    delsRangeSet_1.addKeys(pKeys);
                                                }
                                            } else if (method === "openCursor") {
                                                var cursor_1 = res;
                                                var wantValues_1 = req.values;
                                                return cursor_1 && Object.create(cursor_1, {
                                                    key: {
                                                        get: function() {
                                                            delsRangeSet_1.addKey(cursor_1.primaryKey);
                                                            return cursor_1.key;
                                                        }
                                                    },
                                                    primaryKey: {
                                                        get: function() {
                                                            var pkey = cursor_1.primaryKey;
                                                            delsRangeSet_1.addKey(pkey);
                                                            return pkey;
                                                        }
                                                    },
                                                    value: {
                                                        get: function() {
                                                            wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                                            return cursor_1.value;
                                                        }
                                                    }
                                                });
                                            }
                                            return res;
                                        });
                                    }
                                }
                            }
                            return table[method].apply(this, arguments);
                        };
                    });
                    return tableClone;
                }
            });
        }
    };
    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
            var rangeSet = getRangeSet(ix.name || "");
            function extractKey(obj) {
                return obj != null ? ix.extractKey(obj) : null;
            }
            var addKeyOrKeys = function(key) {
                return ix.multiEntry && isArray(key) ? key.forEach(function(key) {
                    return rangeSet.addKey(key);
                }) : rangeSet.addKey(key);
            };
            (oldObjs || newObjs).forEach(function(_, i) {
                var oldKey = oldObjs && extractKey(oldObjs[i]);
                var newKey = newObjs && extractKey(newObjs[i]);
                if (cmp(oldKey, newKey) !== 0) {
                    if (oldKey != null) addKeyOrKeys(oldKey);
                    if (newKey != null) addKeyOrKeys(newKey);
                }
            });
        }
        schema.indexes.forEach(addAffectedIndex);
    }
    function adjustOptimisticFromFailures(tblCache, req, res) {
        if (res.numFailures === 0) return req;
        if (req.type === 'deleteRange') {
            return null;
        }
        var numBulkOps = req.keys ? req.keys.length : 'values' in req && req.values ? req.values.length : 1;
        if (res.numFailures === numBulkOps) {
            return null;
        }
        var clone = __assign({}, req);
        if (isArray(clone.keys)) {
            clone.keys = clone.keys.filter(function(_, i) {
                return !(i in res.failures);
            });
        }
        if ('values' in clone && isArray(clone.values)) {
            clone.values = clone.values.filter(function(_, i) {
                return !(i in res.failures);
            });
        }
        return clone;
    }
    function isAboveLower(key, range) {
        return range.lower === undefined ? true : range.lowerOpen ? cmp(key, range.lower) > 0 : cmp(key, range.lower) >= 0;
    }
    function isBelowUpper(key, range) {
        return range.upper === undefined ? true : range.upperOpen ? cmp(key, range.upper) < 0 : cmp(key, range.upper) <= 0;
    }
    function isWithinRange(key, range) {
        return isAboveLower(key, range) && isBelowUpper(key, range);
    }
    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
        if (!ops || ops.length === 0) return result;
        var index = req.query.index;
        var multiEntry = index.multiEntry;
        var queryRange = req.query.range;
        var primaryKey = table.schema.primaryKey;
        var extractPrimKey = primaryKey.extractKey;
        var extractIndex = index.extractKey;
        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
        var finalResult = ops.reduce(function(result, op) {
            var modifedResult = result;
            var includedValues = [];
            if (op.type === 'add' || op.type === 'put') {
                var includedPKs = new RangeSet();
                for(var i = op.values.length - 1; i >= 0; --i){
                    var value = op.values[i];
                    var pk = extractPrimKey(value);
                    if (includedPKs.hasKey(pk)) continue;
                    var key = extractIndex(value);
                    if (multiEntry && isArray(key) ? key.some(function(k) {
                        return isWithinRange(k, queryRange);
                    }) : isWithinRange(key, queryRange)) {
                        includedPKs.addKey(pk);
                        includedValues.push(value);
                    }
                }
            }
            switch(op.type){
                case 'add':
                    {
                        var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function(v) {
                            return extractPrimKey(v);
                        }) : result);
                        modifedResult = result.concat(req.values ? includedValues.filter(function(v) {
                            var key = extractPrimKey(v);
                            if (existingKeys_1.hasKey(key)) return false;
                            existingKeys_1.addKey(key);
                            return true;
                        }) : includedValues.map(function(v) {
                            return extractPrimKey(v);
                        }).filter(function(k) {
                            if (existingKeys_1.hasKey(k)) return false;
                            existingKeys_1.addKey(k);
                            return true;
                        }));
                        break;
                    }
                case 'put':
                    {
                        var keySet_1 = new RangeSet().addKeys(op.values.map(function(v) {
                            return extractPrimKey(v);
                        }));
                        modifedResult = result.filter(function(item) {
                            return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item);
                        }).concat(req.values ? includedValues : includedValues.map(function(v) {
                            return extractPrimKey(v);
                        }));
                        break;
                    }
                case 'delete':
                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);
                    modifedResult = result.filter(function(item) {
                        return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
                    });
                    break;
                case 'deleteRange':
                    var range_1 = op.range;
                    modifedResult = result.filter(function(item) {
                        return !isWithinRange(extractPrimKey(item), range_1);
                    });
                    break;
            }
            return modifedResult;
        }, result);
        if (finalResult === result) return result;
        finalResult.sort(function(a, b) {
            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) || cmp(extractPrimKey(a), extractPrimKey(b));
        });
        if (req.limit && req.limit < Infinity) {
            if (finalResult.length > req.limit) {
                finalResult.length = req.limit;
            } else if (result.length === req.limit && finalResult.length < req.limit) {
                cacheEntry.dirty = true;
            }
        }
        return immutable ? Object.freeze(finalResult) : finalResult;
    }
    function areRangesEqual(r1, r2) {
        return cmp(r1.lower, r2.lower) === 0 && cmp(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
    }
    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
        if (lower1 === undefined) return lower2 !== undefined ? -1 : 0;
        if (lower2 === undefined) return 1;
        var c = cmp(lower1, lower2);
        if (c === 0) {
            if (lowerOpen1 && lowerOpen2) return 0;
            if (lowerOpen1) return 1;
            if (lowerOpen2) return -1;
        }
        return c;
    }
    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
        if (upper1 === undefined) return upper2 !== undefined ? 1 : 0;
        if (upper2 === undefined) return -1;
        var c = cmp(upper1, upper2);
        if (c === 0) {
            if (upperOpen1 && upperOpen2) return 0;
            if (upperOpen1) return -1;
            if (upperOpen2) return 1;
        }
        return c;
    }
    function isSuperRange(r1, r2) {
        return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
    }
    function findCompatibleQuery(dbName, tableName, type, req) {
        var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
        if (!tblCache) return [];
        var queries = tblCache.queries[type];
        if (!queries) return [
            null,
            false,
            tblCache,
            null
        ];
        var indexName = req.query ? req.query.index.name : null;
        var entries = queries[indexName || ''];
        if (!entries) return [
            null,
            false,
            tblCache,
            null
        ];
        switch(type){
            case 'query':
                var equalEntry = entries.find(function(entry) {
                    return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
                });
                if (equalEntry) return [
                    equalEntry,
                    true,
                    tblCache,
                    entries
                ];
                var superEntry = entries.find(function(entry) {
                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;
                    return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
                });
                return [
                    superEntry,
                    false,
                    tblCache,
                    entries
                ];
            case 'count':
                var countQuery = entries.find(function(entry) {
                    return areRangesEqual(entry.req.query.range, req.query.range);
                });
                return [
                    countQuery,
                    !!countQuery,
                    tblCache,
                    entries
                ];
        }
    }
    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
        cacheEntry.subscribers.add(requery);
        signal.addEventListener("abort", function() {
            cacheEntry.subscribers.delete(requery);
            if (cacheEntry.subscribers.size === 0) {
                enqueForDeletion(cacheEntry, container);
            }
        });
    }
    function enqueForDeletion(cacheEntry, container) {
        setTimeout(function() {
            if (cacheEntry.subscribers.size === 0) {
                delArrayItem(container, cacheEntry);
            }
        }, 3000);
    }
    var cacheMiddleware = {
        stack: 'dbcore',
        level: 0,
        name: 'Cache',
        create: function(core) {
            var dbName = core.schema.name;
            var coreMW = __assign(__assign({}, core), {
                transaction: function(stores, mode, options) {
                    var idbtrans = core.transaction(stores, mode, options);
                    if (mode === 'readwrite') {
                        var ac_1 = new AbortController();
                        var signal = ac_1.signal;
                        var endTransaction = function(wasCommitted) {
                            return function() {
                                ac_1.abort();
                                if (mode === 'readwrite') {
                                    var affectedSubscribers_1 = new Set();
                                    for(var _i = 0, stores_1 = stores; _i < stores_1.length; _i++){
                                        var storeName = stores_1[_i];
                                        var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                                        if (tblCache) {
                                            var table = core.table(storeName);
                                            var ops = tblCache.optimisticOps.filter(function(op) {
                                                return op.trans === idbtrans;
                                            });
                                            if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                                                for(var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++){
                                                    var entries = _b[_a];
                                                    for(var _c = 0, _d = entries.slice(); _c < _d.length; _c++){
                                                        var entry = _d[_c];
                                                        if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                                            delArrayItem(entries, entry);
                                                            entry.subscribers.forEach(function(requery) {
                                                                return affectedSubscribers_1.add(requery);
                                                            });
                                                        }
                                                    }
                                                }
                                            } else if (ops.length > 0) {
                                                tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                                                    return op.trans !== idbtrans;
                                                });
                                                for(var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++){
                                                    var entries = _f[_e];
                                                    for(var _g = 0, _h = entries.slice(); _g < _h.length; _g++){
                                                        var entry = _h[_g];
                                                        if (entry.res != null && idbtrans.mutatedParts) {
                                                            if (wasCommitted && !entry.dirty) {
                                                                var freezeResults = Object.isFrozen(entry.res);
                                                                var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                                                if (entry.dirty) {
                                                                    delArrayItem(entries, entry);
                                                                    entry.subscribers.forEach(function(requery) {
                                                                        return affectedSubscribers_1.add(requery);
                                                                    });
                                                                } else if (modRes !== entry.res) {
                                                                    entry.res = modRes;
                                                                    entry.promise = DexiePromise.resolve({
                                                                        result: modRes
                                                                    });
                                                                }
                                                            } else {
                                                                if (entry.dirty) {
                                                                    delArrayItem(entries, entry);
                                                                }
                                                                entry.subscribers.forEach(function(requery) {
                                                                    return affectedSubscribers_1.add(requery);
                                                                });
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    affectedSubscribers_1.forEach(function(requery) {
                                        return requery();
                                    });
                                }
                            };
                        };
                        idbtrans.addEventListener('abort', endTransaction(false), {
                            signal: signal
                        });
                        idbtrans.addEventListener('error', endTransaction(false), {
                            signal: signal
                        });
                        idbtrans.addEventListener('complete', endTransaction(true), {
                            signal: signal
                        });
                    }
                    return idbtrans;
                },
                table: function(tableName) {
                    var downTable = core.table(tableName);
                    var primKey = downTable.schema.primaryKey;
                    var tableMW = __assign(__assign({}, downTable), {
                        mutate: function(req) {
                            var trans = PSD.trans;
                            if (primKey.outbound || trans.db._options.cache === 'disabled' || trans.explicit || trans.idbtrans.mode !== 'readwrite') {
                                return downTable.mutate(req);
                            }
                            var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                            if (!tblCache) return downTable.mutate(req);
                            var promise = downTable.mutate(req);
                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                                return key == null;
                            }))) {
                                promise.then(function(res) {
                                    var reqWithResolvedKeys = __assign(__assign({}, req), {
                                        values: req.values.map(function(value, i) {
                                            var _a;
                                            if (res.failures[i]) return value;
                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.')) ? deepClone(value) : __assign({}, value);
                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                                            return valueWithKey;
                                        })
                                    });
                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                                    tblCache.optimisticOps.push(adjustedReq);
                                    queueMicrotask(function() {
                                        return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                    });
                                });
                            } else {
                                tblCache.optimisticOps.push(req);
                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                promise.then(function(res) {
                                    if (res.numFailures > 0) {
                                        delArrayItem(tblCache.optimisticOps, req);
                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                                        if (adjustedReq) {
                                            tblCache.optimisticOps.push(adjustedReq);
                                        }
                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                    }
                                });
                                promise.catch(function() {
                                    delArrayItem(tblCache.optimisticOps, req);
                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                });
                            }
                            return promise;
                        },
                        query: function(req) {
                            var _a;
                            if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req)) return downTable.query(req);
                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';
                            var _b = PSD, requery = _b.requery, signal = _b.signal;
                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
                            if (cacheEntry && exactMatch) {
                                cacheEntry.obsSet = req.obsSet;
                            } else {
                                var promise = downTable.query(req).then(function(res) {
                                    var result = res.result;
                                    if (cacheEntry) cacheEntry.res = result;
                                    if (freezeResults) {
                                        for(var i = 0, l = result.length; i < l; ++i){
                                            Object.freeze(result[i]);
                                        }
                                        Object.freeze(result);
                                    } else {
                                        res.result = deepClone(result);
                                    }
                                    return res;
                                }).catch(function(error) {
                                    if (container && cacheEntry) delArrayItem(container, cacheEntry);
                                    return Promise.reject(error);
                                });
                                cacheEntry = {
                                    obsSet: req.obsSet,
                                    promise: promise,
                                    subscribers: new Set(),
                                    type: 'query',
                                    req: req,
                                    dirty: false
                                };
                                if (container) {
                                    container.push(cacheEntry);
                                } else {
                                    container = [
                                        cacheEntry
                                    ];
                                    if (!tblCache) {
                                        tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                                            queries: {
                                                query: {},
                                                count: {}
                                            },
                                            objs: new Map(),
                                            optimisticOps: [],
                                            unsignaledParts: {}
                                        };
                                    }
                                    tblCache.queries.query[req.query.index.name || ''] = container;
                                }
                            }
                            subscribeToCacheEntry(cacheEntry, container, requery, signal);
                            return cacheEntry.promise.then(function(res) {
                                return {
                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                                };
                            });
                        }
                    });
                    return tableMW;
                }
            });
            return coreMW;
        }
    };
    function vipify(target, vipDb) {
        return new Proxy(target, {
            get: function(target, prop, receiver) {
                if (prop === 'db') return vipDb;
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    var Dexie$1 = function() {
        function Dexie(name, options) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie.dependencies;
            this._options = options = __assign({
                addons: Dexie.addons,
                autoOpen: true,
                indexedDB: deps.indexedDB,
                IDBKeyRange: deps.IDBKeyRange,
                cache: 'cloned'
            }, options);
            this._deps = {
                indexedDB: options.indexedDB,
                IDBKeyRange: options.IDBKeyRange
            };
            var addons = options.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            var state = {
                dbOpenError: null,
                isBeingOpened: false,
                onReadyBeingFired: null,
                openComplete: false,
                dbReadyResolve: nop,
                dbReadyPromise: null,
                cancelOpen: nop,
                openCanceller: null,
                autoSchema: true,
                PR1398_maxLoop: 3,
                autoOpen: options.autoOpen
            };
            state.dbReadyPromise = new DexiePromise(function(resolve) {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function(_, reject) {
                state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", {
                ready: [
                    promisableChain,
                    nop
                ]
            });
            this.once = function(event, callback) {
                var fn = function() {
                    var args = [];
                    for(var _i = 0; _i < arguments.length; _i++){
                        args[_i] = arguments[_i];
                    }
                    _this.on(event).unsubscribe(fn);
                    callback.apply(_this, args);
                };
                return _this.on(event, fn);
            };
            this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
                return function(subscriber, bSticky) {
                    Dexie.vip(function() {
                        var state = _this._state;
                        if (state.openComplete) {
                            if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);
                            if (bSticky) subscribe(subscriber);
                        } else if (state.onReadyBeingFired) {
                            state.onReadyBeingFired.push(subscriber);
                            if (bSticky) subscribe(subscriber);
                        } else {
                            subscribe(subscriber);
                            var db_1 = _this;
                            if (!bSticky) subscribe(function unsubscribe() {
                                db_1.on.ready.unsubscribe(subscriber);
                                db_1.on.ready.unsubscribe(unsubscribe);
                            });
                        }
                    });
                };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function(ev) {
                if (ev.newVersion > 0) console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
                else console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
                _this.close({
                    disableAutoOpen: false
                });
            });
            this.on("blocked", function(ev) {
                if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
                else console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
                return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
            };
            this._fireOnBlocked = function(ev) {
                _this.on("blocked").fire(ev);
                connections.filter(function(c) {
                    return c.name === _this.name && c !== _this && !c._state.vcFired;
                }).map(function(c) {
                    return c.on("versionchange").fire(ev);
                });
            };
            this.use(cacheExistingValuesMiddleware);
            this.use(cacheMiddleware);
            this.use(observabilityMiddleware);
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            var vipDB = new Proxy(this, {
                get: function(_, prop, receiver) {
                    if (prop === '_vip') return true;
                    if (prop === 'table') return function(tableName) {
                        return vipify(_this.table(tableName), vipDB);
                    };
                    var rv = Reflect.get(_, prop, receiver);
                    if (rv instanceof Table) return vipify(rv, vipDB);
                    if (prop === 'tables') return rv.map(function(t) {
                        return vipify(t, vipDB);
                    });
                    if (prop === '_createTransaction') return function() {
                        var tx = rv.apply(this, arguments);
                        return vipify(tx, vipDB);
                    };
                    return rv;
                }
            });
            this.vip = vipDB;
            addons.forEach(function(addon) {
                return addon(_this);
            });
        }
        Dexie.prototype.version = function(versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function(v) {
                return v._cfg.version === versionNumber;
            })[0];
            if (versionInstance) return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
        };
        Dexie.prototype._whenReady = function(fn) {
            var _this = this;
            return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve, reject) {
                if (_this._state.openComplete) {
                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
                }
                if (!_this._state.isBeingOpened) {
                    if (!_this._state.autoOpen) {
                        reject(new exceptions.DatabaseClosed());
                        return;
                    }
                    _this.open().catch(nop);
                }
                _this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn);
        };
        Dexie.prototype.use = function(_a) {
            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;
            if (name) this.unuse({
                stack: stack,
                name: name
            });
            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({
                stack: stack,
                create: create,
                level: level == null ? 10 : level,
                name: name
            });
            middlewares.sort(function(a, b) {
                return a.level - b.level;
            });
            return this;
        };
        Dexie.prototype.unuse = function(_a) {
            var stack = _a.stack, name = _a.name, create = _a.create;
            if (stack && this._middlewares[stack]) {
                this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
                    return create ? mw.create !== create : name ? mw.name !== name : false;
                });
            }
            return this;
        };
        Dexie.prototype.open = function() {
            var _this = this;
            return usePSD(globalPSD, function() {
                return dexieOpen(_this);
            });
        };
        Dexie.prototype._close = function() {
            this.on.close.fire(new CustomEvent('close'));
            var state = this._state;
            var idx = connections.indexOf(this);
            if (idx >= 0) connections.splice(idx, 1);
            if (this.idbdb) {
                try {
                    this.idbdb.close();
                } catch (e) {}
                this.idbdb = null;
            }
            if (!state.isBeingOpened) {
                state.dbReadyPromise = new DexiePromise(function(resolve) {
                    state.dbReadyResolve = resolve;
                });
                state.openCanceller = new DexiePromise(function(_, reject) {
                    state.cancelOpen = reject;
                });
            }
        };
        Dexie.prototype.close = function(_a) {
            var _b = _a === void 0 ? {
                disableAutoOpen: true
            } : _a, disableAutoOpen = _b.disableAutoOpen;
            var state = this._state;
            if (disableAutoOpen) {
                if (state.isBeingOpened) {
                    state.cancelOpen(new exceptions.DatabaseClosed());
                }
                this._close();
                state.autoOpen = false;
                state.dbOpenError = new exceptions.DatabaseClosed();
            } else {
                this._close();
                state.autoOpen = this._options.autoOpen || state.isBeingOpened;
                state.openComplete = false;
                state.dbOpenError = null;
            }
        };
        Dexie.prototype.delete = function(closeOptions) {
            var _this = this;
            if (closeOptions === void 0) {
                closeOptions = {
                    disableAutoOpen: true
                };
            }
            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';
            var state = this._state;
            return new DexiePromise(function(resolve, reject) {
                var doDelete = function() {
                    _this.close(closeOptions);
                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                    req.onsuccess = wrap(function() {
                        _onDatabaseDeleted(_this._deps, _this.name);
                        resolve();
                    });
                    req.onerror = eventRejectHandler(reject);
                    req.onblocked = _this._fireOnBlocked;
                };
                if (hasInvalidArguments) throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
                if (state.isBeingOpened) {
                    state.dbReadyPromise.then(doDelete);
                } else {
                    doDelete();
                }
            });
        };
        Dexie.prototype.backendDB = function() {
            return this.idbdb;
        };
        Dexie.prototype.isOpen = function() {
            return this.idbdb !== null;
        };
        Dexie.prototype.hasBeenClosed = function() {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && dbOpenError.name === 'DatabaseClosed';
        };
        Dexie.prototype.hasFailed = function() {
            return this._state.dbOpenError !== null;
        };
        Dexie.prototype.dynamicallyOpened = function() {
            return this._state.autoSchema;
        };
        Object.defineProperty(Dexie.prototype, "tables", {
            get: function() {
                var _this = this;
                return keys(this._allTables).map(function(name) {
                    return _this._allTables[name];
                });
            },
            enumerable: false,
            configurable: true
        });
        Dexie.prototype.transaction = function() {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
        };
        Dexie.prototype._transaction = function(mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;
            var onlyIfCompatible = mode.indexOf('?') !== -1;
            mode = mode.replace('!', '').replace('?', '');
            var idbMode, storeNames;
            try {
                storeNames = tables.map(function(table) {
                    var storeName = table instanceof _this.Table ? table.name : table;
                    if (typeof storeName !== 'string') throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                    return storeName;
                });
                if (mode == "r" || mode === READONLY) idbMode = READONLY;
                else if (mode == "rw" || mode == READWRITE) idbMode = READWRITE;
                else throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                if (parentTransaction) {
                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                        if (onlyIfCompatible) {
                            parentTransaction = null;
                        } else throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                    }
                    if (parentTransaction) {
                        storeNames.forEach(function(storeName) {
                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                if (onlyIfCompatible) {
                                    parentTransaction = null;
                                } else throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                            }
                        });
                    }
                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                        parentTransaction = null;
                    }
                }
            } catch (e) {
                return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
                    reject(e);
                }) : rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
                return _this._whenReady(enterTransaction);
            }) : this._whenReady(enterTransaction);
        };
        Dexie.prototype.table = function(tableName) {
            if (!hasOwn(this._allTables, tableName)) {
                throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
            }
            return this._allTables[tableName];
        };
        return Dexie;
    }();
    var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
    var Observable = function() {
        function Observable(subscribe) {
            this._subscribe = subscribe;
        }
        Observable.prototype.subscribe = function(x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? {
                next: x,
                error: error,
                complete: complete
            } : x);
        };
        Observable.prototype[symbolObservable] = function() {
            return this;
        };
        return Observable;
    }();
    var domDeps;
    try {
        domDeps = {
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        };
    } catch (e) {
        domDeps = {
            indexedDB: null,
            IDBKeyRange: null
        };
    }
    function liveQuery(querier) {
        var hasValue = false;
        var currentValue;
        var observable = new Observable(function(observer) {
            var scopeFuncIsAsync = isAsyncFunction(querier);
            function execute(ctx) {
                var wasRootExec = beginMicroTickScope();
                try {
                    if (scopeFuncIsAsync) {
                        incrementExpectedAwaits();
                    }
                    var rv = newScope(querier, ctx);
                    if (scopeFuncIsAsync) {
                        rv = rv.finally(decrementExpectedAwaits);
                    }
                    return rv;
                } finally{
                    wasRootExec && endMicroTickScope();
                }
            }
            var closed = false;
            var abortController;
            var accumMuts = {};
            var currentObs = {};
            var subscription = {
                get closed () {
                    return closed;
                },
                unsubscribe: function() {
                    if (closed) return;
                    closed = true;
                    if (abortController) abortController.abort();
                    if (startedListening) globalEvents.storagemutated.unsubscribe(mutationListener);
                }
            };
            observer.start && observer.start(subscription);
            var startedListening = false;
            var doQuery = function() {
                return execInGlobalContext(_doQuery);
            };
            function shouldNotify() {
                return obsSetsOverlap(currentObs, accumMuts);
            }
            var mutationListener = function(parts) {
                extendObservabilitySet(accumMuts, parts);
                if (shouldNotify()) {
                    doQuery();
                }
            };
            var _doQuery = function() {
                if (closed || !domDeps.indexedDB) {
                    return;
                }
                accumMuts = {};
                var subscr = {};
                if (abortController) abortController.abort();
                abortController = new AbortController();
                var ctx = {
                    subscr: subscr,
                    signal: abortController.signal,
                    requery: doQuery,
                    querier: querier,
                    trans: null
                };
                var ret = execute(ctx);
                Promise.resolve(ret).then(function(result) {
                    hasValue = true;
                    currentValue = result;
                    if (closed || ctx.signal.aborted) {
                        return;
                    }
                    accumMuts = {};
                    currentObs = subscr;
                    if (!objectIsEmpty(currentObs) && !startedListening) {
                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                        startedListening = true;
                    }
                    execInGlobalContext(function() {
                        return !closed && observer.next && observer.next(result);
                    });
                }, function(err) {
                    hasValue = false;
                    if (![
                        'DatabaseClosedError',
                        'AbortError'
                    ].includes(err === null || err === void 0 ? void 0 : err.name)) {
                        if (!closed) execInGlobalContext(function() {
                            if (closed) return;
                            observer.error && observer.error(err);
                        });
                    }
                });
            };
            setTimeout(doQuery, 0);
            return subscription;
        });
        observable.hasValue = function() {
            return hasValue;
        };
        observable.getValue = function() {
            return currentValue;
        };
        return observable;
    }
    var Dexie = Dexie$1;
    props(Dexie, __assign(__assign({}, fullNameExceptions), {
        delete: function(databaseName) {
            var db = new Dexie(databaseName, {
                addons: []
            });
            return db.delete();
        },
        exists: function(name) {
            return new Dexie(name, {
                addons: []
            }).open().then(function(db) {
                db.close();
                return true;
            }).catch('NoSuchDatabaseError', function() {
                return false;
            });
        },
        getDatabaseNames: function(cb) {
            try {
                return getDatabaseNames(Dexie.dependencies).then(cb);
            } catch (_a) {
                return rejection(new exceptions.MissingAPI());
            }
        },
        defineClass: function() {
            function Class(content) {
                extend(this, content);
            }
            return Class;
        },
        ignoreTransaction: function(scopeFunc) {
            return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
        },
        vip: vip,
        async: function(generatorFn) {
            return function() {
                try {
                    var rv = awaitIterator(generatorFn.apply(this, arguments));
                    if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);
                    return rv;
                } catch (e) {
                    return rejection(e);
                }
            };
        },
        spawn: function(generatorFn, args, thiz) {
            try {
                var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);
                return rv;
            } catch (e) {
                return rejection(e);
            }
        },
        currentTransaction: {
            get: function() {
                return PSD.trans || null;
            }
        },
        waitFor: function(promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);
            return PSD.trans ? PSD.trans.waitFor(promise) : promise;
        },
        Promise: DexiePromise,
        debug: {
            get: function() {
                return debug;
            },
            set: function(value) {
                setDebug(value);
            }
        },
        derive: derive,
        extend: extend,
        props: props,
        override: override,
        Events: Events,
        on: globalEvents,
        liveQuery: liveQuery,
        extendObservabilitySet: extendObservabilitySet,
        getByKeyPath: getByKeyPath,
        setByKeyPath: setByKeyPath,
        delByKeyPath: delByKeyPath,
        shallowClone: shallowClone,
        deepClone: deepClone,
        getObjectDiff: getObjectDiff,
        cmp: cmp,
        asap: asap$1,
        minKey: minKey,
        addons: [],
        connections: connections,
        errnames: errnames,
        dependencies: domDeps,
        cache: cache,
        semVer: DEXIE_VERSION,
        version: DEXIE_VERSION.split('.').map(function(n) {
            return parseInt(n);
        }).reduce(function(p, c, i) {
            return p + c / Math.pow(10, i * 2);
        })
    }));
    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
            if (!propagatingLocally) {
                var event_1;
                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                    detail: updatedParts
                });
                propagatingLocally = true;
                dispatchEvent(event_1);
                propagatingLocally = false;
            }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a) {
            var detail = _a.detail;
            if (!propagatingLocally) {
                propagateLocally(detail);
            }
        });
    }
    function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
            signalSubscribersNow(updateParts, true);
        } finally{
            propagatingLocally = wasMe;
        }
    }
    var propagatingLocally = false;
    var bc;
    var createBC = function() {};
    if (typeof BroadcastChannel !== 'undefined') {
        createBC = function() {
            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
            bc.onmessage = function(ev) {
                return ev.data && propagateLocally(ev.data);
            };
        };
        createBC();
        if (typeof bc.unref === 'function') {
            bc.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
            if (!propagatingLocally) {
                bc.postMessage(changedParts);
            }
        });
    }
    if (typeof addEventListener !== 'undefined') {
        addEventListener('pagehide', function(event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
                if (debug) console.debug('Dexie: handling persisted pagehide');
                bc === null || bc === void 0 ? void 0 : bc.close();
                for(var _i = 0, connections_1 = connections; _i < connections_1.length; _i++){
                    var db = connections_1[_i];
                    db.close({
                        disableAutoOpen: false
                    });
                }
            }
        });
        addEventListener('pageshow', function(event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
                if (debug) console.debug('Dexie: handling persisted pageshow');
                createBC();
                propagateLocally({
                    all: new RangeSet(-Infinity, [
                        []
                    ])
                });
            }
        });
    }
    function add(value) {
        return new PropModification({
            add: value
        });
    }
    function remove(value) {
        return new PropModification({
            remove: value
        });
    }
    function replacePrefix(a, b) {
        return new PropModification({
            replacePrefix: [
                a,
                b
            ]
        });
    }
    DexiePromise.rejectionMapper = mapError;
    setDebug(debug);
    var namedExports = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery,
        Entity: Entity,
        cmp: cmp,
        PropModification: PropModification,
        replacePrefix: replacePrefix,
        add: add,
        remove: remove,
        'default': Dexie$1,
        RangeSet: RangeSet,
        mergeRanges: mergeRanges,
        rangesOverlap: rangesOverlap
    });
    __assign(Dexie$1, namedExports, {
        default: Dexie$1
    });
    return Dexie$1;
}); //# sourceMappingURL=dexie.js.map
}),
"[project]/node_modules/dexie/import-wrapper.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Making the module version consumable via require - to prohibit
// multiple occurrancies of the same module in the same app
// (dual package hazard, https://nodejs.org/api/packages.html#dual-package-hazard)
__turbopack_context__.s([
    "Dexie",
    ()=>Dexie,
    "DexieYProvider",
    ()=>DexieYProvider,
    "Entity",
    ()=>Entity,
    "PropModification",
    ()=>PropModification,
    "RangeSet",
    ()=>RangeSet,
    "add",
    ()=>add,
    "cmp",
    ()=>cmp,
    "default",
    ()=>__TURBOPACK__default__export__,
    "liveQuery",
    ()=>liveQuery,
    "mergeRanges",
    ()=>mergeRanges,
    "rangesOverlap",
    ()=>rangesOverlap,
    "remove",
    ()=>remove,
    "replacePrefix",
    ()=>replacePrefix
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dexie$2f$dist$2f$dexie$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dexie/dist/dexie.js [app-ssr] (ecmascript)");
;
const DexieSymbol = Symbol.for("Dexie");
const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dexie$2f$dist$2f$dexie$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dexie$2f$dist$2f$dexie$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].semVer !== Dexie.semVer) {
    throw new Error(`Two different versions of Dexie loaded in the same app: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dexie$2f$dist$2f$dexie$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].semVer} and ${Dexie.semVer}`);
}
const { liveQuery, mergeRanges, rangesOverlap, RangeSet, cmp, Entity, PropModification, replacePrefix, add, remove, DexieYProvider } = Dexie;
;
const __TURBOPACK__default__export__ = Dexie;
}),
"[project]/node_modules/@neondatabase/serverless/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* @ts-self-types="./index.d.mts" */ __turbopack_context__.s([
    "Client",
    ()=>ut,
    "DatabaseError",
    ()=>export_DatabaseError,
    "NeonDbError",
    ()=>be,
    "NeonQueryPromise",
    ()=>Ce,
    "Pool",
    ()=>Mn,
    "SqlTemplate",
    ()=>$e,
    "UnsafeRawSql",
    ()=>Ge,
    "_bundleExt",
    ()=>kp,
    "defaults",
    ()=>export_defaults,
    "escapeIdentifier",
    ()=>export_escapeIdentifier,
    "escapeLiteral",
    ()=>export_escapeLiteral,
    "neon",
    ()=>cs,
    "neonConfig",
    ()=>ce,
    "types",
    ()=>export_types,
    "warnIfBrowser",
    ()=>bt
]);
var So = Object.create;
var Ie = Object.defineProperty;
var Eo = Object.getOwnPropertyDescriptor;
var Ao = Object.getOwnPropertyNames;
var Co = Object.getPrototypeOf, _o = Object.prototype.hasOwnProperty;
var Io = (r, e, t)=>e in r ? Ie(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t;
var a = (r, e)=>Ie(r, "name", {
        value: e,
        configurable: !0
    });
var G = (r, e)=>()=>(r && (e = r(r = 0)), e);
var T = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports), ie = (r, e)=>{
    for(var t in e)Ie(r, t, {
        get: e[t],
        enumerable: !0
    });
}, Dn = (r, e, t, n)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let i of Ao(e))!_o.call(r, i) && i !== t && Ie(r, i, {
        get: ()=>e[i],
        enumerable: !(n = Eo(e, i)) || n.enumerable
    });
    return r;
};
var Se = (r, e, t)=>(t = r != null ? So(Co(r)) : {}, Dn(e || !r || !r.__esModule ? Ie(t, "default", {
        value: r,
        enumerable: !0
    }) : t, r)), O = (r)=>Dn(Ie({}, "__esModule", {
        value: !0
    }), r);
var E = (r, e, t)=>Io(r, typeof e != "symbol" ? e + "" : e, t);
var Qn = T((lt)=>{
    "use strict";
    p();
    lt.byteLength = Po;
    lt.toByteArray = Ro;
    lt.fromByteArray = ko;
    var ae = [], te = [], To = typeof Uint8Array < "u" ? Uint8Array : Array, qt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01\
23456789+/";
    for(Ee = 0, On = qt.length; Ee < On; ++Ee)ae[Ee] = qt[Ee], te[qt.charCodeAt(Ee)] = Ee;
    var Ee, On;
    te[45] = 62;
    te[95] = 63;
    function qn(r) {
        var e = r.length;
        if (e % 4 > 0) throw new Error("Invalid string. Length must be \
a multiple of 4");
        var t = r.indexOf("=");
        t === -1 && (t = e);
        var n = t === e ? 0 : 4 - t % 4;
        return [
            t,
            n
        ];
    }
    a(qn, "getLens");
    function Po(r) {
        var e = qn(r), t = e[0], n = e[1];
        return (t + n) * 3 / 4 - n;
    }
    a(Po, "byteLength");
    function Bo(r, e, t) {
        return (e + t) * 3 / 4 - t;
    }
    a(Bo, "_byteLength");
    function Ro(r) {
        var e, t = qn(r), n = t[0], i = t[1], s = new To(Bo(r, n, i)), o = 0, u = i > 0 ? n - 4 : n, c;
        for(c = 0; c < u; c += 4)e = te[r.charCodeAt(c)] << 18 | te[r.charCodeAt(c + 1)] << 12 | te[r.charCodeAt(c + 2)] << 6 | te[r.charCodeAt(c + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
        return i === 2 && (e = te[r.charCodeAt(c)] << 2 | te[r.charCodeAt(c + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = te[r.charCodeAt(c)] << 10 | te[r.charCodeAt(c + 1)] << 4 | te[r.charCodeAt(c + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
    }
    a(Ro, "toByteArray");
    function Lo(r) {
        return ae[r >> 18 & 63] + ae[r >> 12 & 63] + ae[r >> 6 & 63] + ae[r & 63];
    }
    a(Lo, "tripletToBase64");
    function Fo(r, e, t) {
        for(var n, i = [], s = e; s < t; s += 3)n = (r[s] << 16 & 16711680) + (r[s + 1] << 8 & 65280) + (r[s + 2] & 255), i.push(Lo(n));
        return i.join("");
    }
    a(Fo, "en\
codeChunk");
    function ko(r) {
        for(var e, t = r.length, n = t % 3, i = [], s = 16383, o = 0, u = t - n; o < u; o += s)i.push(Fo(r, o, o + s > u ? u : o + s));
        return n === 1 ? (e = r[t - 1], i.push(ae[e >> 2] + ae[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i.push(ae[e >> 10] + ae[e >> 4 & 63] + ae[e << 2 & 63] + "=")), i.join("");
    }
    a(ko, "fromByteArray");
});
var Nn = T((Qt)=>{
    p();
    Qt.read = function(r, e, t, n, i) {
        var s, o, u = i * 8 - n - 1, c = (1 << u) - 1, l = c >> 1, f = -7, y = t ? i - 1 : 0, g = t ? -1 : 1, A = r[e + y];
        for(y += g, s = A & (1 << -f) - 1, A >>= -f, f += u; f > 0; s = s * 256 + r[e + y], y += g, f -= 8);
        for(o = s & (1 << -f) - 1, s >>= -f, f += n; f > 0; o = o * 256 + r[e + y], y += g, f -= 8);
        if (s === 0) s = 1 - l;
        else {
            if (s === c) return o ? NaN : (A ? -1 : 1) * (1 / 0);
            o = o + Math.pow(2, n), s = s - l;
        }
        return (A ? -1 : 1) * o * Math.pow(2, s - n);
    };
    Qt.write = function(r, e, t, n, i, s) {
        var o, u, c, l = s * 8 - i - 1, f = (1 << l) - 1, y = f >> 1, g = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, A = n ? 0 : s - 1, C = n ? 1 : -1, D = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, o = f) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + y >= 1 ? e += g / c : e += g * Math.pow(2, 1 - y), e * c >= 2 && (o++, c /= 2), o + y >= f ? (u = 0, o = f) : o + y >= 1 ? (u = (e * c - 1) * Math.pow(2, i), o = o + y) : (u = e * Math.pow(2, y - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + A] = u & 255, A += C, u /= 256, i -= 8);
        for(o = o << i | u, l += i; l > 0; r[t + A] = o & 255, A += C, o /= 256, l -= 8);
        r[t + A - C] |= D * 128;
    };
});
var ii = T((Re)=>{
    "use strict";
    p();
    var Nt = Qn(), Pe = Nn(), Wn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Re.Buffer = h;
    Re.SlowBuffer = Qo;
    Re.INSPECT_MAX_BYTES = 50;
    var ft = 2147483647;
    Re.kMaxLength = ft;
    h.TYPED_ARRAY_SUPPORT = Mo();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) su\
pport which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Mo() {
        try {
            let r = new Uint8Array(1), e = {
                foo: a(function() {
                    return 42;
                }, "foo")
            };
            return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42;
        } catch  {
            return !1;
        }
    }
    a(Mo, "typedArraySupport");
    Object.defineProperty(h.prototype, "parent", {
        enumerable: !0,
        get: a(function() {
            if (h.isBuffer(this)) return this.buffer;
        }, "get")
    });
    Object.defineProperty(h.prototype, "offset", {
        enumerable: !0,
        get: a(function() {
            if (h.isBuffer(this)) return this.byteOffset;
        }, "get")
    });
    function he(r) {
        if (r > ft) throw new RangeError('The value "' + r + '\
" is invalid for option "size"');
        let e = new Uint8Array(r);
        return Object.setPrototypeOf(e, h.prototype), e;
    }
    a(he, "createBuffer");
    function h(r, e, t) {
        if (typeof r == "number") {
            if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return $t(r);
        }
        return Gn(r, e, t);
    }
    a(h, "Buffer");
    h.poolSize = 8192;
    function Gn(r, e, t) {
        if (typeof r == "string") return Do(r, e);
        if (ArrayBuffer.isView(r)) return Oo(r);
        if (r == null) throw new TypeError("The first argument must be one of type string\
, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
        if (ue(r, ArrayBuffer) || r && ue(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ue(r, SharedArrayBuffer) || r && ue(r.buffer, SharedArrayBuffer))) return jt(r, e, t);
        if (typeof r == "number") throw new TypeError('The "value" argument\
 must not be of type number. Received type number');
        let n = r.valueOf && r.valueOf();
        if (n != null && n !== r) return h.from(n, e, t);
        let i = qo(r);
        if (i) return i;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return h.from(r[Symbol.toPrimitive]("string"), e, t);
        throw new TypeError("The\
 first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Receiv\
ed type " + typeof r);
    }
    a(Gn, "from");
    h.from = function(r, e, t) {
        return Gn(r, e, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function Vn(r) {
        if (typeof r != "number") throw new TypeError('"size" argument must be of type number');
        if (r < 0) throw new RangeError('The value "' + r + '" is invalid \
for option "size"');
    }
    a(Vn, "assertSize");
    function Uo(r, e, t) {
        return Vn(r), r <= 0 ? he(r) : e !== void 0 ? typeof t == "string" ? he(r).fill(e, t) : he(r).fill(e) : he(r);
    }
    a(Uo, "alloc");
    h.alloc = function(r, e, t) {
        return Uo(r, e, t);
    };
    function $t(r) {
        return Vn(r), he(r < 0 ? 0 : Gt(r) | 0);
    }
    a($t, "allocUnsafe");
    h.allocUnsafe = function(r) {
        return $t(r);
    };
    h.allocUnsafeSlow = function(r) {
        return $t(r);
    };
    function Do(r, e) {
        if ((typeof e != "string" || e === "") && (e = "utf8"), !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
        let t = zn(r, e) | 0, n = he(t), i = n.write(r, e);
        return i !== t && (n = n.slice(0, i)), n;
    }
    a(Do, "fromString");
    function Wt(r) {
        let e = r.length < 0 ? 0 : Gt(r.length) | 0, t = he(e);
        for(let n = 0; n < e; n += 1)t[n] = r[n] & 255;
        return t;
    }
    a(Wt, "fromArrayLike");
    function Oo(r) {
        if (ue(r, Uint8Array)) {
            let e = new Uint8Array(r);
            return jt(e.buffer, e.byteOffset, e.byteLength);
        }
        return Wt(r);
    }
    a(Oo, "fromArrayVi\
ew");
    function jt(r, e, t) {
        if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer b\
ounds');
        if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let n;
        return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(r, e, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    a(jt, "fromArrayBuffer");
    function qo(r) {
        if (h.isBuffer(r)) {
            let e = Gt(r.length) | 0, t = he(e);
            return t.length === 0 || r.copy(t, 0, 0, e), t;
        }
        if (r.length !== void 0) return typeof r.length != "number" || zt(r.length) ? he(0) : Wt(r);
        if (r.type === "Buffer" && Array.isArray(r.data)) return Wt(r.data);
    }
    a(qo, "fromObject");
    function Gt(r) {
        if (r >= ft) throw new RangeError("Attempt to allocate Buffer larger t\
han maximum size: 0x" + ft.toString(16) + " bytes");
        return r | 0;
    }
    a(Gt, "checked");
    function Qo(r) {
        return +r != r && (r = 0), h.alloc(+r);
    }
    a(Qo, "SlowBuffer");
    h.isBuffer = a(function(e) {
        return e != null && e._isBuffer === !0 && e !== h.prototype;
    }, "isBuffer");
    h.compare = a(function(e, t) {
        if (ue(e, Uint8Array) && (e = h.from(e, e.offset, e.byteLength)), ue(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(e) || !h.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e === t) return 0;
        let n = e.length, i = t.length;
        for(let s = 0, o = Math.min(n, i); s < o; ++s)if (e[s] !== t[s]) {
            n = e[s], i = t[s];
            break;
        }
        return n < i ? -1 : i < n ? 1 : 0;
    }, "compare");
    h.isEncoding = a(function(e) {
        switch(String(e).toLowerCase()){
            case "hex":
            case "utf8":
            case "\
utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "\
utf-16le":
                return !0;
            default:
                return !1;
        }
    }, "isEncoding");
    h.concat = a(function(e, t) {
        if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (e.length === 0) return h.alloc(0);
        let n;
        if (t === void 0) for(t = 0, n = 0; n < e.length; ++n)t += e[n].length;
        let i = h.allocUnsafe(t), s = 0;
        for(n = 0; n < e.length; ++n){
            let o = e[n];
            if (ue(o, Uint8Array)) s + o.length > i.length ? (h.isBuffer(o) || (o = h.from(o)), o.copy(i, s)) : Uint8Array.prototype.set.call(i, o, s);
            else if (h.isBuffer(o)) o.copy(i, s);
            else throw new TypeError('"list" argument must be \
an Array of Buffers');
            s += o.length;
        }
        return i;
    }, "concat");
    function zn(r, e) {
        if (h.isBuffer(r)) return r.length;
        if (ArrayBuffer.isView(r) || ue(r, ArrayBuffer)) return r.byteLength;
        if (typeof r != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
        let t = r.length, n = arguments.length > 2 && arguments[2] === !0;
        if (!n && t === 0) return 0;
        let i = !1;
        for(;;)switch(e){
            case "\
ascii":
            case "latin1":
            case "binary":
                return t;
            case "utf8":
            case "utf-8":
                return Ht(r).length;
            case "ucs2":
            case "\
ucs-2":
            case "utf16le":
            case "utf-16le":
                return t * 2;
            case "hex":
                return t >>> 1;
            case "base64":
                return ni(r).length;
            default:
                if (i) return n ? -1 : Ht(r).length;
                e = ("" + e).toLowerCase(), i = !0;
        }
    }
    a(zn, "byteLength");
    h.byteLength = zn;
    function No(r, e, t) {
        let n = !1;
        if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
        for(r || (r = "utf8");;)switch(r){
            case "hex":
                return Zo(this, e, t);
            case "u\
tf8":
            case "utf-8":
                return Yn(this, e, t);
            case "ascii":
                return Ko(this, e, t);
            case "latin1":
            case "binary":
                return Yo(this, e, t);
            case "base64":
                return Vo(this, e, t);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Jo(this, e, t);
            default:
                if (n) throw new TypeError("Unknown encoding: " + r);
                r = (r + "").toLowerCase(), n = !0;
        }
    }
    a(No, "slowToString");
    h.prototype._isBuffer = !0;
    function Ae(r, e, t) {
        let n = r[e];
        r[e] = r[t], r[t] = n;
    }
    a(Ae, "swap");
    h.prototype.swap16 = a(function() {
        let e = this.length;
        if (e % 2 !== 0) throw new RangeError("Buffer size must \
be a multiple of 16-bits");
        for(let t = 0; t < e; t += 2)Ae(this, t, t + 1);
        return this;
    }, "swap16");
    h.prototype.swap32 = a(function() {
        let e = this.length;
        if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32\
-bits");
        for(let t = 0; t < e; t += 4)Ae(this, t, t + 3), Ae(this, t + 1, t + 2);
        return this;
    }, "swap32");
    h.prototype.swap64 = a(function() {
        let e = this.length;
        if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64\
-bits");
        for(let t = 0; t < e; t += 8)Ae(this, t, t + 7), Ae(this, t + 1, t + 6), Ae(this, t + 2, t + 5), Ae(this, t + 3, t + 4);
        return this;
    }, "swap64");
    h.prototype.toString = a(function() {
        let e = this.length;
        return e === 0 ? "" : arguments.length === 0 ? Yn(this, 0, e) : No.apply(this, arguments);
    }, "toString");
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = a(function(e) {
        if (!h.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
        return this === e ? !0 : h.compare(this, e) === 0;
    }, "equals");
    h.prototype.inspect = a(function() {
        let e = "", t = Re.INSPECT_MAX_BYTES;
        return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buff\
er " + e + ">";
    }, "inspect");
    Wn && (h.prototype[Wn] = h.prototype.inspect);
    h.prototype.compare = a(function(e, t, n, i, s) {
        if (ue(e, Uint8Array) && (e = h.from(e, e.offset, e.byteLength)), !h.isBuffer(e)) throw new TypeError('The "ta\
rget" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
        if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), s === void 0 && (s = this.length), t < 0 || n > e.length || i < 0 || s > this.length) throw new RangeError("out of range index");
        if (i >= s && t >= n) return 0;
        if (i >= s) return -1;
        if (t >= n) return 1;
        if (t >>>= 0, n >>>= 0, i >>>= 0, s >>>= 0, this === e) return 0;
        let o = s - i, u = n - t, c = Math.min(o, u), l = this.slice(i, s), f = e.slice(t, n);
        for(let y = 0; y < c; ++y)if (l[y] !== f[y]) {
            o = l[y], u = f[y];
            break;
        }
        return o < u ? -1 : u < o ? 1 : 0;
    }, "\
compare");
    function Kn(r, e, t, n, i) {
        if (r.length === 0) return -1;
        if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, zt(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
            if (i) return -1;
            t = r.length - 1;
        } else if (t < 0) if (i) t = 0;
        else return -1;
        if (typeof e == "string" && (e = h.from(e, n)), h.isBuffer(e)) return e.length === 0 ? -1 : jn(r, e, t, n, i);
        if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : jn(r, [
            e
        ], t, n, i);
        throw new TypeError("val must be string, number or Buffer");
    }
    a(Kn, "bidire\
ctionalIndexOf");
    function jn(r, e, t, n, i) {
        let s = 1, o = r.length, u = e.length;
        if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
            if (r.length < 2 || e.length < 2) return -1;
            s = 2, o /= 2, u /= 2, t /= 2;
        }
        function c(f, y) {
            return s === 1 ? f[y] : f.readUInt16BE(y * s);
        }
        a(c, "read");
        let l;
        if (i) {
            let f = -1;
            for(l = t; l < o; l++)if (c(r, l) === c(e, f === -1 ? 0 : l - f)) {
                if (f === -1 && (f = l), l - f + 1 === u) return f * s;
            } else f !== -1 && (l -= l - f), f = -1;
        } else for(t + u > o && (t = o - u), l = t; l >= 0; l--){
            let f = !0;
            for(let y = 0; y < u; y++)if (c(r, l + y) !== c(e, y)) {
                f = !1;
                break;
            }
            if (f) return l;
        }
        return -1;
    }
    a(jn, "arrayIndexOf");
    h.prototype.includes = a(function(e, t, n) {
        return this.indexOf(e, t, n) !== -1;
    }, "includes");
    h.prototype.indexOf = a(function(e, t, n) {
        return Kn(this, e, t, n, !0);
    }, "indexOf");
    h.prototype.lastIndexOf = a(function(e, t, n) {
        return Kn(this, e, t, n, !1);
    }, "lastIndexOf");
    function Wo(r, e, t, n) {
        t = Number(t) || 0;
        let i = r.length - t;
        n ? (n = Number(n), n > i && (n = i)) : n = i;
        let s = e.length;
        n > s / 2 && (n = s / 2);
        let o;
        for(o = 0; o < n; ++o){
            let u = parseInt(e.substr(o * 2, 2), 16);
            if (zt(u)) return o;
            r[t + o] = u;
        }
        return o;
    }
    a(Wo, "hexWrite");
    function jo(r, e, t, n) {
        return ht(Ht(e, r.length - t), r, t, n);
    }
    a(jo, "utf8Write");
    function Ho(r, e, t, n) {
        return ht(ra(e), r, t, n);
    }
    a(Ho, "asciiWrite");
    function $o(r, e, t, n) {
        return ht(ni(e), r, t, n);
    }
    a($o, "base64Write");
    function Go(r, e, t, n) {
        return ht(na(e, r.length - t), r, t, n);
    }
    a(Go, "ucs2Write");
    h.prototype.write = a(function(e, t, n, i) {
        if (t === void 0) i = "utf\
8", n = this.length, t = 0;
        else if (n === void 0 && typeof t == "string") i = t, n = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
        else throw new Error("Buffer.wri\
te(string, encoding, offset[, length]) is no longer supported");
        let s = this.length - t;
        if ((n === void 0 || n > s) && (n = s), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buf\
fer bounds");
        i || (i = "utf8");
        let o = !1;
        for(;;)switch(i){
            case "hex":
                return Wo(this, e, t, n);
            case "utf8":
            case "\
utf-8":
                return jo(this, e, t, n);
            case "ascii":
            case "latin1":
            case "binary":
                return Ho(this, e, t, n);
            case "base64":
                return $o(this, e, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Go(this, e, t, n);
            default:
                if (o) throw new TypeError("Unknown encoding: " + i);
                i = ("" + i).toLowerCase(), o = !0;
        }
    }, "write");
    h.prototype.toJSON = a(function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    }, "toJSO\
N");
    function Vo(r, e, t) {
        return e === 0 && t === r.length ? Nt.fromByteArray(r) : Nt.fromByteArray(r.slice(e, t));
    }
    a(Vo, "base64Slice");
    function Yn(r, e, t) {
        t = Math.min(r.length, t);
        let n = [], i = e;
        for(; i < t;){
            let s = r[i], o = null, u = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
            if (i + u <= t) {
                let c, l, f, y;
                switch(u){
                    case 1:
                        s < 128 && (o = s);
                        break;
                    case 2:
                        c = r[i + 1], (c & 192) === 128 && (y = (s & 31) << 6 | c & 63, y > 127 && (o = y));
                        break;
                    case 3:
                        c = r[i + 1], l = r[i + 2], (c & 192) === 128 && (l & 192) === 128 && (y = (s & 15) << 12 | (c & 63) << 6 | l & 63, y > 2047 && (y < 55296 || y > 57343) && (o = y));
                        break;
                    case 4:
                        c = r[i + 1], l = r[i + 2], f = r[i + 3], (c & 192) === 128 && (l & 192) === 128 && (f & 192) === 128 && (y = (s & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | f & 63, y > 65535 && y < 1114112 && (o = y));
                }
            }
            o === null ? (o = 65533, u = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n.push(o), i += u;
        }
        return zo(n);
    }
    a(Yn, "utf8Slice");
    var Hn = 4096;
    function zo(r) {
        let e = r.length;
        if (e <= Hn) return String.fromCharCode.apply(String, r);
        let t = "", n = 0;
        for(; n < e;)t += String.fromCharCode.apply(String, r.slice(n, n += Hn));
        return t;
    }
    a(zo, "decodeCodePointsArray");
    function Ko(r, e, t) {
        let n = "";
        t = Math.min(r.length, t);
        for(let i = e; i < t; ++i)n += String.fromCharCode(r[i] & 127);
        return n;
    }
    a(Ko, "asciiSlice");
    function Yo(r, e, t) {
        let n = "";
        t = Math.min(r.length, t);
        for(let i = e; i < t; ++i)n += String.fromCharCode(r[i]);
        return n;
    }
    a(Yo, "latin1Slice");
    function Zo(r, e, t) {
        let n = r.length;
        (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
        let i = "";
        for(let s = e; s < t; ++s)i += ia[r[s]];
        return i;
    }
    a(Zo, "hexSlice");
    function Jo(r, e, t) {
        let n = r.slice(e, t), i = "";
        for(let s = 0; s < n.length - 1; s += 2)i += String.fromCharCode(n[s] + n[s + 1] * 256);
        return i;
    }
    a(Jo, "utf16leSlice");
    h.prototype.slice = a(function(e, t) {
        let n = this.length;
        e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
        let i = this.subarray(e, t);
        return Object.setPrototypeOf(i, h.prototype), i;
    }, "slice");
    function q(r, e, t) {
        if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
        if (r + e > t) throw new RangeError("Trying to \
access beyond buffer length");
    }
    a(q, "checkOffset");
    h.prototype.readUintLE = h.prototype.readUIntLE = a(function(e, t, n) {
        e = e >>> 0, t = t >>> 0, n || q(e, t, this.length);
        let i = this[e], s = 1, o = 0;
        for(; ++o < t && (s *= 256);)i += this[e + o] * s;
        return i;
    }, "readUIntLE");
    h.prototype.readUintBE = h.prototype.readUIntBE = a(function(e, t, n) {
        e = e >>> 0, t = t >>> 0, n || q(e, t, this.length);
        let i = this[e + --t], s = 1;
        for(; t > 0 && (s *= 256);)i += this[e + --t] * s;
        return i;
    }, "readUIntBE");
    h.prototype.readUint8 = h.prototype.readUInt8 = a(function(e, t) {
        return e = e >>> 0, t || q(e, 1, this.length), this[e];
    }, "readUInt8");
    h.prototype.readUint16LE = h.prototype.readUInt16LE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 2, this.length), this[e] | this[e + 1] << 8;
    }, "readUInt16LE");
    h.prototype.readUint16BE = h.prototype.readUInt16BE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 2, this.length), this[e] << 8 | this[e + 1];
    }, "readUInt16BE");
    h.prototype.readUint32LE = h.prototype.readUInt32LE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    }, "readUInt32LE");
    h.prototype.readUint32BE = h.prototype.readUInt32BE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    }, "readUInt32BE");
    h.prototype.readBigUInt64LE = we(a(function(e) {
        e = e >>> 0, Be(e, "offset");
        let t = this[e], n = this[e + 7];
        (t === void 0 || n === void 0) && je(e, this.length - 8);
        let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
        return BigInt(i) + (BigInt(s) << BigInt(32));
    }, "readBigUInt64LE"));
    h.prototype.readBigUInt64BE = we(a(function(e) {
        e = e >>> 0, Be(e, "offset");
        let t = this[e], n = this[e + 7];
        (t === void 0 || n === void 0) && je(e, this.length - 8);
        let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
        return (BigInt(i) << BigInt(32)) + BigInt(s);
    }, "readBigUInt64BE"));
    h.prototype.readIntLE = a(function(e, t, n) {
        e = e >>> 0, t = t >>> 0, n || q(e, t, this.length);
        let i = this[e], s = 1, o = 0;
        for(; ++o < t && (s *= 256);)i += this[e + o] * s;
        return s *= 128, i >= s && (i -= Math.pow(2, 8 * t)), i;
    }, "readIntLE");
    h.prototype.readIntBE = a(function(e, t, n) {
        e = e >>> 0, t = t >>> 0, n || q(e, t, this.length);
        let i = t, s = 1, o = this[e + --i];
        for(; i > 0 && (s *= 256);)o += this[e + --i] * s;
        return s *= 128, o >= s && (o -= Math.pow(2, 8 * t)), o;
    }, "readIntBE");
    h.prototype.readInt8 = a(function(e, t) {
        return e = e >>> 0, t || q(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    }, "readInt8");
    h.prototype.readInt16LE = a(function(e, t) {
        e = e >>> 0, t || q(e, 2, this.length);
        let n = this[e] | this[e + 1] << 8;
        return n & 32768 ? n | 4294901760 : n;
    }, "readInt16LE");
    h.prototype.readInt16BE = a(function(e, t) {
        e = e >>> 0, t || q(e, 2, this.length);
        let n = this[e + 1] | this[e] << 8;
        return n & 32768 ? n | 4294901760 : n;
    }, "readInt16BE");
    h.prototype.readInt32LE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    }, "readInt32LE");
    h.prototype.readInt32BE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    }, "readInt32BE");
    h.prototype.readBigInt64LE = we(a(function(e) {
        e = e >>> 0, Be(e, "offset");
        let t = this[e], n = this[e + 7];
        (t === void 0 || n === void 0) && je(e, this.length - 8);
        let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
        return (BigInt(i) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    }, "readBigInt64LE"));
    h.prototype.readBigInt64BE = we(a(function(e) {
        e = e >>> 0, Be(e, "offset");
        let t = this[e], n = this[e + 7];
        (t === void 0 || n === void 0) && je(e, this.length - 8);
        let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
        return (BigInt(i) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n);
    }, "readBigInt64BE"));
    h.prototype.readFloatLE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 4, this.length), Pe.read(this, e, !0, 23, 4);
    }, "readFloatLE");
    h.prototype.readFloatBE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 4, this.length), Pe.read(this, e, !1, 23, 4);
    }, "readFloatBE");
    h.prototype.readDoubleLE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 8, this.length), Pe.read(this, e, !0, 52, 8);
    }, "readDoub\
leLE");
    h.prototype.readDoubleBE = a(function(e, t) {
        return e = e >>> 0, t || q(e, 8, this.length), Pe.read(this, e, !1, 52, 8);
    }, "readDoubleBE");
    function V(r, e, t, n, i, s) {
        if (!h.isBuffer(r)) throw new TypeError('"buffer" ar\
gument must be a Buffer instance');
        if (e > i || e < s) throw new RangeError('"value" argument is out of boun\
ds');
        if (t + n > r.length) throw new RangeError("Index out of range");
    }
    a(V, "checkInt");
    h.prototype.writeUintLE = h.prototype.writeUIntLE = a(function(e, t, n, i) {
        if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
            let u = Math.pow(2, 8 * n) - 1;
            V(this, e, t, n, u, 0);
        }
        let s = 1, o = 0;
        for(this[t] = e & 255; ++o < n && (s *= 256);)this[t + o] = e / s & 255;
        return t + n;
    }, "writeUIntLE");
    h.prototype.writeUintBE = h.prototype.writeUIntBE = a(function(e, t, n, i) {
        if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
            let u = Math.pow(2, 8 * n) - 1;
            V(this, e, t, n, u, 0);
        }
        let s = n - 1, o = 1;
        for(this[t + s] = e & 255; --s >= 0 && (o *= 256);)this[t + s] = e / o & 255;
        return t + n;
    }, "writeUIntBE");
    h.prototype.writeUint8 = h.prototype.writeUInt8 = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1;
    }, "writeUInt8");
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
    }, "writeUInt16LE");
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
    }, "writeUInt16BE");
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4;
    }, "writeUInt32LE");
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
    }, "writeUInt32BE");
    function Zn(r, e, t, n, i) {
        ri(e, n, i, r, t, 7);
        let s = Number(e & BigInt(4294967295));
        r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s;
        let o = Number(e >> BigInt(32) & BigInt(4294967295));
        return r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, t;
    }
    a(Zn, "wrtBigUInt64LE");
    function Jn(r, e, t, n, i) {
        ri(e, n, i, r, t, 7);
        let s = Number(e & BigInt(4294967295));
        r[t + 7] = s, s = s >> 8, r[t + 6] = s, s = s >> 8, r[t + 5] = s, s = s >> 8, r[t + 4] = s;
        let o = Number(e >> BigInt(32) & BigInt(4294967295));
        return r[t + 3] = o, o = o >> 8, r[t + 2] = o, o = o >> 8, r[t + 1] = o, o = o >> 8, r[t] = o, t + 8;
    }
    a(Jn, "wrtBigUInt64BE");
    h.prototype.writeBigUInt64LE = we(a(function(e, t = 0) {
        return Zn(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "w\
riteBigUInt64LE"));
    h.prototype.writeBigUInt64BE = we(a(function(e, t = 0) {
        return Jn(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"));
    h.prototype.writeIntLE = a(function(e, t, n, i) {
        if (e = +e, t = t >>> 0, !i) {
            let c = Math.pow(2, 8 * n - 1);
            V(this, e, t, n, c - 1, -c);
        }
        let s = 0, o = 1, u = 0;
        for(this[t] = e & 255; ++s < n && (o *= 256);)e < 0 && u === 0 && this[t + s - 1] !== 0 && (u = 1), this[t + s] = (e / o >> 0) - u & 255;
        return t + n;
    }, "writeIntLE");
    h.prototype.writeIntBE = a(function(e, t, n, i) {
        if (e = +e, t = t >>> 0, !i) {
            let c = Math.pow(2, 8 * n - 1);
            V(this, e, t, n, c - 1, -c);
        }
        let s = n - 1, o = 1, u = 0;
        for(this[t + s] = e & 255; --s >= 0 && (o *= 256);)e < 0 && u === 0 && this[t + s + 1] !== 0 && (u = 1), this[t + s] = (e / o >> 0) - u & 255;
        return t + n;
    }, "writeIntBE");
    h.prototype.writeInt8 = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
    }, "writeInt8");
    h.prototype.writeInt16LE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
    }, "writeInt16LE");
    h.prototype.writeInt16BE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
    }, "writeInt16BE");
    h.prototype.writeInt32LE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
    }, "\
writeInt32LE");
    h.prototype.writeInt32BE = a(function(e, t, n) {
        return e = +e, t = t >>> 0, n || V(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
    }, "writeInt32BE");
    h.prototype.writeBigInt64LE = we(a(function(e, t = 0) {
        return Zn(this, e, t, -BigInt("0x\
8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"));
    h.prototype.writeBigInt64BE = we(a(function(e, t = 0) {
        return Jn(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "w\
riteBigInt64BE"));
    function Xn(r, e, t, n, i, s) {
        if (t + n > r.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range");
    }
    a(Xn, "checkIEEE754");
    function ei(r, e, t, n, i) {
        return e = +e, t = t >>> 0, i || Xn(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), Pe.write(r, e, t, n, 23, 4), t + 4;
    }
    a(ei, "writeFloat");
    h.prototype.writeFloatLE = a(function(e, t, n) {
        return ei(this, e, t, !0, n);
    }, "writeFloatLE");
    h.prototype.writeFloatBE = a(function(e, t, n) {
        return ei(this, e, t, !1, n);
    }, "writeFloatBE");
    function ti(r, e, t, n, i) {
        return e = +e, t = t >>> 0, i || Xn(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), Pe.write(r, e, t, n, 52, 8), t + 8;
    }
    a(ti, "writeDouble");
    h.prototype.writeDoubleLE = a(function(e, t, n) {
        return ti(this, e, t, !0, n);
    }, "wr\
iteDoubleLE");
    h.prototype.writeDoubleBE = a(function(e, t, n) {
        return ti(this, e, t, !1, n);
    }, "writeDoubleBE");
    h.prototype.copy = a(function(e, t, n, i) {
        if (!h.isBuffer(e)) throw new TypeError("argument should be a Buf\
fer");
        if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
        if (i < 0) throw new RangeError("sourceEnd \
out of bounds");
        i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
        let s = i - n;
        return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), s;
    }, "copy");
    h.prototype.fill = a(function(e, t, n, i) {
        if (typeof e == "string") {
            if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
            if (typeof i == "string" && !h.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
            if (e.length === 1) {
                let o = e.charCodeAt(0);
                (i === "utf8" && o < 128 || i === "latin1") && (e = o);
            }
        } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
        if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
        if (n <= t) return this;
        t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
        let s;
        if (typeof e == "number") for(s = t; s < n; ++s)this[s] = e;
        else {
            let o = h.isBuffer(e) ? e : h.from(e, i), u = o.length;
            if (u === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
            for(s = 0; s < n - t; ++s)this[s + t] = o[s % u];
        }
        return this;
    }, "fill");
    var Te = {};
    function Vt(r, e, t) {
        var n;
        Te[r] = (n = class extends t {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: e.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${r}]`, this.stack, delete this.name;
            }
            get code() {
                return r;
            }
            set code(s) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: s,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${r}\
]: ${this.message}`;
            }
        }, a(n, "NodeError"), n);
    }
    a(Vt, "E");
    Vt("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
        return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Vt("ERR_INVALID_ARG_TYPE", function(r, e) {
        return `The "${r}" argument must be of type number. Received typ\
e ${typeof e}`;
    }, TypeError);
    Vt("ERR_OUT_OF_RANGE", function(r, e, t) {
        let n = `The value of "${r}" is out o\
f range.`, i = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = $n(String(t)) : typeof t == "bigint" && (i = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = $n(i)), i += "n"), n += ` It must be ${e}. Re\
ceived ${i}`, n;
    }, RangeError);
    function $n(r) {
        let e = "", t = r.length, n = r[0] === "-" ? 1 : 0;
        for(; t >= n + 4; t -= 3)e = `\
_${r.slice(t - 3, t)}${e}`;
        return `${r.slice(0, t)}${e}`;
    }
    a($n, "addNumericalSeparator");
    function Xo(r, e, t) {
        Be(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && je(e, r.length - (t + 1));
    }
    a(Xo, "checkBounds");
    function ri(r, e, t, n, i, s) {
        if (r > t || r < e) {
            let o = typeof e == "bigint" ? "n" : "", u;
            throw s > 3 ? e === 0 || e === BigInt(0) ? u = `>= 0${o} and < 2${o}\
 ** ${(s + 1) * 8}${o}` : u = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${(s + 1) * 8 - 1}${o}` : u = `>= ${e}${o} a\
nd <= ${t}${o}`, new Te.ERR_OUT_OF_RANGE("value", u, r);
        }
        Xo(n, i, s);
    }
    a(ri, "checkIntBI");
    function Be(r, e) {
        if (typeof r != "number") throw new Te.ERR_INVALID_ARG_TYPE(e, "number", r);
    }
    a(Be, "validateNumber");
    function je(r, e, t) {
        throw Math.floor(r) !== r ? (Be(r, t), new Te.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new Te.ERR_BUFFER_OUT_OF_BOUNDS : new Te.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${e}`, r);
    }
    a(je, "boundsError");
    var ea = /[^+/0-9A-Za-z-_]/g;
    function ta(r) {
        if (r = r.split("=")[0], r = r.trim().replace(ea, ""), r.length < 2) return "";
        for(; r.length % 4 !== 0;)r = r + "=";
        return r;
    }
    a(ta, "base64clean");
    function Ht(r, e) {
        e = e || 1 / 0;
        let t, n = r.length, i = null, s = [];
        for(let o = 0; o < n; ++o){
            if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
                if (!i) {
                    if (t > 56319) {
                        (e -= 3) > -1 && s.push(239, 191, 189);
                        continue;
                    } else if (o + 1 === n) {
                        (e -= 3) > -1 && s.push(239, 191, 189);
                        continue;
                    }
                    i = t;
                    continue;
                }
                if (t < 56320) {
                    (e -= 3) > -1 && s.push(239, 191, 189), i = t;
                    continue;
                }
                t = (i - 55296 << 10 | t - 56320) + 65536;
            } else i && (e -= 3) > -1 && s.push(239, 191, 189);
            if (i = null, t < 128) {
                if ((e -= 1) < 0) break;
                s.push(t);
            } else if (t < 2048) {
                if ((e -= 2) < 0) break;
                s.push(t >> 6 | 192, t & 63 | 128);
            } else if (t < 65536) {
                if ((e -= 3) < 0) break;
                s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
            } else if (t < 1114112) {
                if ((e -= 4) < 0) break;
                s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return s;
    }
    a(Ht, "utf\
8ToBytes");
    function ra(r) {
        let e = [];
        for(let t = 0; t < r.length; ++t)e.push(r.charCodeAt(t) & 255);
        return e;
    }
    a(ra, "asciiToBytes");
    function na(r, e) {
        let t, n, i, s = [];
        for(let o = 0; o < r.length && !((e -= 2) < 0); ++o)t = r.charCodeAt(o), n = t >> 8, i = t % 256, s.push(i), s.push(n);
        return s;
    }
    a(na, "utf16leToBytes");
    function ni(r) {
        return Nt.toByteArray(ta(r));
    }
    a(ni, "base64ToBytes");
    function ht(r, e, t, n) {
        let i;
        for(i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i)e[i + t] = r[i];
        return i;
    }
    a(ht, "blitBuffer");
    function ue(r, e) {
        return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name;
    }
    a(ue, "isInstance");
    function zt(r) {
        return r !== r;
    }
    a(zt, "numberIsNaN");
    var ia = function() {
        let r = "0123456789abcdef", e = new Array(256);
        for(let t = 0; t < 16; ++t){
            let n = t * 16;
            for(let i = 0; i < 16; ++i)e[n + i] = r[t] + r[i];
        }
        return e;
    }();
    function we(r) {
        return typeof BigInt > "u" ? sa : r;
    }
    a(we, "defineBigIntMethod");
    function sa() {
        throw new Error("BigInt not supported");
    }
    a(sa, "BufferBi\
gIntNotDefined");
});
var b, v, x, d, m, p = G(()=>{
    "use strict";
    b = globalThis, v = globalThis.setImmediate ?? ((r)=>setTimeout(r, 0)), x = globalThis.clearImmediate ?? ((r)=>clearTimeout(r)), d = typeof globalThis.Buffer == "function" && typeof globalThis.Buffer.allocUnsafe == "function" ? globalThis.Buffer : ii().Buffer, m = globalThis.process ?? {};
    m.env ?? (m.env = {});
    try {
        m.nextTick(()=>{});
    } catch  {
        let e = Promise.resolve();
        m.nextTick = e.then.bind(e);
    }
});
var ge = T((Rl, Kt)=>{
    "use strict";
    p();
    var Le = typeof Reflect == "object" ? Reflect : null, si = Le && typeof Le.apply == "function" ? Le.apply : a(function(e, t, n) {
        return Function.prototype.apply.call(e, t, n);
    }, "ReflectApply"), pt;
    Le && typeof Le.ownKeys == "function" ? pt = Le.ownKeys : Object.getOwnPropertySymbols ? pt = a(function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    }, "ReflectOwnKeys") : pt = a(function(e) {
        return Object.getOwnPropertyNames(e);
    }, "ReflectOwnKeys");
    function oa(r) {
        console && console.warn && console.warn(r);
    }
    a(oa, "ProcessEmitWarning");
    var ai = Number.isNaN || a(function(e) {
        return e !== e;
    }, "NumberIsNaN");
    function B() {
        B.init.call(this);
    }
    a(B, "EventEmitter");
    Kt.exports = B;
    Kt.exports.once = la;
    B.EventEmitter = B;
    B.prototype._events = void 0;
    B.prototype._eventsCount = 0;
    B.prototype._maxListeners = void 0;
    var oi = 10;
    function dt(r) {
        if (typeof r != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
    }
    a(dt, "checkListener");
    Object.defineProperty(B, "defaultMaxListeners", {
        enumerable: !0,
        get: a(function() {
            return oi;
        }, "get"),
        set: a(function(r) {
            if (typeof r != "number" || r < 0 || ai(r)) throw new RangeError('The valu\
e of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
            oi = r;
        }, "set")
    });
    B.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    };
    B.prototype.setMaxListeners = a(function(e) {
        if (typeof e != "number" || e < 0 || ai(e)) throw new RangeError('Th\
e value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this;
    }, "setMaxListeners");
    function ui(r) {
        return r._maxListeners === void 0 ? B.defaultMaxListeners : r._maxListeners;
    }
    a(ui, "_getMaxListeners");
    B.prototype.getMaxListeners = a(function() {
        return ui(this);
    }, "getMaxListeners");
    B.prototype.emit = a(function(e) {
        for(var t = [], n = 1; n < arguments.length; n++)t.push(arguments[n]);
        var i = e === "error", s = this._events;
        if (s !== void 0) i = i && s.error === void 0;
        else if (!i) return !1;
        if (i) {
            var o;
            if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
            var u = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
            throw u.context = o, u;
        }
        var c = s[e];
        if (c === void 0) return !1;
        if (typeof c == "function") si(c, this, t);
        else for(var l = c.length, f = pi(c, l), n = 0; n < l; ++n)si(f[n], this, t);
        return !0;
    }, "emit");
    function ci(r, e, t, n) {
        var i, s, o;
        if (dt(t), s = r._events, s === void 0 ? (s = r._events = Object.create(null), r._eventsCount = 0) : (s.newListener !== void 0 && (r.emit("newListener", e, t.listener ? t.listener : t), s = r._events), o = s[e]), o === void 0) o = s[e] = t, ++r._eventsCount;
        else if (typeof o == "function" ? o = s[e] = n ? [
            t,
            o
        ] : [
            o,
            t
        ] : n ? o.unshift(t) : o.push(t), i = ui(r), i > 0 && o.length > i && !o.warned) {
            o.warned = !0;
            var u = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners\
 added. Use emitter.setMaxListeners() to increase limit");
            u.name = "MaxListenersExceededWarning", u.emitter = r, u.type = e, u.count = o.length, oa(u);
        }
        return r;
    }
    a(ci, "_addListener");
    B.prototype.addListener = a(function(e, t) {
        return ci(this, e, t, !1);
    }, "addListener");
    B.prototype.on = B.prototype.addListener;
    B.prototype.prependListener = a(function(e, t) {
        return ci(this, e, t, !0);
    }, "prependListener");
    function aa() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    a(aa, "onceWrapper");
    function li(r, e, t) {
        var n = {
            fired: !1,
            wrapFn: void 0,
            target: r,
            type: e,
            listener: t
        }, i = aa.bind(n);
        return i.listener = t, n.wrapFn = i, i;
    }
    a(li, "_onceW\
rap");
    B.prototype.once = a(function(e, t) {
        return dt(t), this.on(e, li(this, e, t)), this;
    }, "once");
    B.prototype.prependOnceListener = a(function(e, t) {
        return dt(t), this.prependListener(e, li(this, e, t)), this;
    }, "prepend\
OnceListener");
    B.prototype.removeListener = a(function(e, t) {
        var n, i, s, o, u;
        if (dt(t), i = this._events, i === void 0) return this;
        if (n = i[e], n === void 0) return this;
        if (n === t || n.listener === t) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
        else if (typeof n != "function") {
            for(s = -1, o = n.length - 1; o >= 0; o--)if (n[o] === t || n[o].listener === t) {
                u = n[o].listener, s = o;
                break;
            }
            if (s < 0) return this;
            s === 0 ? n.shift() : ua(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, u || t);
        }
        return this;
    }, "removeListener");
    B.prototype.off = B.prototype.removeListener;
    B.prototype.removeAllListeners = a(function(e) {
        var t, n, i;
        if (n = this._events, n === void 0) return this;
        if (n.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[e]), this;
        if (arguments.length === 0) {
            var s = Object.keys(n), o;
            for(i = 0; i < s.length; ++i)o = s[i], o !== "removeListener" && this.removeAllListeners(o);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
        }
        if (t = n[e], typeof t == "function") this.removeListener(e, t);
        else if (t !== void 0) for(i = t.length - 1; i >= 0; i--)this.removeListener(e, t[i]);
        return this;
    }, "removeAllListeners");
    function fi(r, e, t) {
        var n = r._events;
        if (n === void 0) return [];
        var i = n[e];
        return i === void 0 ? [] : typeof i == "function" ? t ? [
            i.listener || i
        ] : [
            i
        ] : t ? ca(i) : pi(i, i.length);
    }
    a(fi, "_listeners");
    B.prototype.listeners = a(function(e) {
        return fi(this, e, !0);
    }, "l\
isteners");
    B.prototype.rawListeners = a(function(e) {
        return fi(this, e, !1);
    }, "rawListeners");
    B.listenerCount = function(r, e) {
        return typeof r.listenerCount == "function" ? r.listenerCount(e) : hi.call(r, e);
    };
    B.prototype.listenerCount = hi;
    function hi(r) {
        var e = this._events;
        if (e !== void 0) {
            var t = e[r];
            if (typeof t == "function") return 1;
            if (t !== void 0) return t.length;
        }
        return 0;
    }
    a(hi, "listenerCount");
    B.prototype.eventNames = a(function() {
        return this._eventsCount > 0 ? pt(this._events) : [];
    }, "eventNames");
    function pi(r, e) {
        for(var t = new Array(e), n = 0; n < e; ++n)t[n] = r[n];
        return t;
    }
    a(pi, "arrayClone");
    function ua(r, e) {
        for(; e + 1 < r.length; e++)r[e] = r[e + 1];
        r.pop();
    }
    a(ua, "spliceOne");
    function ca(r) {
        for(var e = new Array(r.length), t = 0; t < e.length; ++t)e[t] = r[t].listener || r[t];
        return e;
    }
    a(ca, "unwrapListeners");
    function la(r, e) {
        return new Promise(function(t, n) {
            function i(o) {
                r.removeListener(e, s), n(o);
            }
            a(i, "errorListener");
            function s() {
                typeof r.removeListener == "function" && r.removeListener("error", i), t([].slice.call(arguments));
            }
            a(s, "resolver"), di(r, e, s, {
                once: !0
            }), e !== "error" && fa(r, i, {
                once: !0
            });
        });
    }
    a(la, "once");
    function fa(r, e, t) {
        typeof r.on == "function" && di(r, "error", e, t);
    }
    a(fa, "addErrorHandlerIfEventEmitter");
    function di(r, e, t, n) {
        if (typeof r.on == "function") n.once ? r.once(e, t) : r.on(e, t);
        else if (typeof r.addEventListener == "function") r.addEventListener(e, a(function i(s) {
            n.once && r.removeEventListener(e, i), t(s);
        }, "wrapListener"));
        else throw new TypeError('The "emitter" argument m\
ust be of type EventEmitter. Received type ' + typeof r);
    }
    a(di, "eventTargetAgnosticAddListener");
});
var wi = {};
ie(wi, {
    Socket: ()=>ce,
    isIP: ()=>ha
});
function ha(r) {
    return 0;
}
var mi, yi, S, ce, Fe = G(()=>{
    "use s\
trict";
    p();
    mi = Se(ge(), 1);
    a(ha, "isIP");
    yi = /^[^.]+\./, S = class S extends mi.EventEmitter {
        constructor(){
            super(...arguments);
            E(this, "opts", {});
            E(this, "connecting", !1);
            E(this, "pending", !0);
            E(this, "writable", !0);
            E(this, "encrypted", !1);
            E(this, "authorized", !1);
            E(this, "destroyed", !1);
            E(this, "ws", null);
            E(this, "\
writeBuffer");
            E(this, "tlsState", 0);
            E(this, "tlsRead");
            E(this, "tlsWrite");
        }
        static get poolQueryViaFetch() {
            return S.opts.poolQueryViaFetch ?? S.defaults.poolQueryViaFetch;
        }
        static set poolQueryViaFetch(t) {
            S.opts.poolQueryViaFetch = t;
        }
        static get fetchEndpoint() {
            return S.opts.fetchEndpoint ?? S.defaults.fetchEndpoint;
        }
        static set fetchEndpoint(t) {
            S.opts.fetchEndpoint = t;
        }
        static get fetchConnectionCache() {
            return !0;
        }
        static set fetchConnectionCache(t) {
            console.warn("The `fetchConnectionCache` option is deprecated (now always `true`)");
        }
        static get fetchFunction() {
            return S.opts.fetchFunction ?? S.defaults.fetchFunction;
        }
        static set fetchFunction(t) {
            S.opts.fetchFunction = t;
        }
        static get webSocketConstructor() {
            return S.opts.webSocketConstructor ?? S.defaults.webSocketConstructor;
        }
        static set webSocketConstructor(t) {
            S.opts.webSocketConstructor = t;
        }
        get webSocketConstructor() {
            return this.opts.webSocketConstructor ?? S.webSocketConstructor;
        }
        set webSocketConstructor(t) {
            this.opts.webSocketConstructor = t;
        }
        static get wsProxy() {
            return S.opts.wsProxy ?? S.defaults.wsProxy;
        }
        static set wsProxy(t) {
            S.opts.wsProxy = t;
        }
        get wsProxy() {
            return this.opts.wsProxy ?? S.wsProxy;
        }
        set wsProxy(t) {
            this.opts.wsProxy = t;
        }
        static get coalesceWrites() {
            return S.opts.coalesceWrites ?? S.defaults.coalesceWrites;
        }
        static set coalesceWrites(t) {
            S.opts.coalesceWrites = t;
        }
        get coalesceWrites() {
            return this.opts.coalesceWrites ?? S.coalesceWrites;
        }
        set coalesceWrites(t) {
            this.opts.coalesceWrites = t;
        }
        static get useSecureWebSocket() {
            return S.opts.useSecureWebSocket ?? S.defaults.useSecureWebSocket;
        }
        static set useSecureWebSocket(t) {
            S.opts.useSecureWebSocket = t;
        }
        get useSecureWebSocket() {
            return this.opts.useSecureWebSocket ?? S.useSecureWebSocket;
        }
        set useSecureWebSocket(t) {
            this.opts.useSecureWebSocket = t;
        }
        static get forceDisablePgSSL() {
            return S.opts.forceDisablePgSSL ?? S.defaults.forceDisablePgSSL;
        }
        static set forceDisablePgSSL(t) {
            S.opts.forceDisablePgSSL = t;
        }
        get forceDisablePgSSL() {
            return this.opts.forceDisablePgSSL ?? S.forceDisablePgSSL;
        }
        set forceDisablePgSSL(t) {
            this.opts.forceDisablePgSSL = t;
        }
        static get disableSNI() {
            return S.opts.disableSNI ?? S.defaults.disableSNI;
        }
        static set disableSNI(t) {
            S.opts.disableSNI = t;
        }
        get disableSNI() {
            return this.opts.disableSNI ?? S.disableSNI;
        }
        set disableSNI(t) {
            this.opts.disableSNI = t;
        }
        static get disableWarningInBrowsers() {
            return S.opts.disableWarningInBrowsers ?? S.defaults.disableWarningInBrowsers;
        }
        static set disableWarningInBrowsers(t) {
            S.opts.disableWarningInBrowsers = t;
        }
        get disableWarningInBrowsers() {
            return this.opts.disableWarningInBrowsers ?? S.disableWarningInBrowsers;
        }
        set disableWarningInBrowsers(t) {
            this.opts.disableWarningInBrowsers = t;
        }
        static get pipelineConnect() {
            return S.opts.pipelineConnect ?? S.defaults.pipelineConnect;
        }
        static set pipelineConnect(t) {
            S.opts.pipelineConnect = t;
        }
        get pipelineConnect() {
            return this.opts.pipelineConnect ?? S.pipelineConnect;
        }
        set pipelineConnect(t) {
            this.opts.pipelineConnect = t;
        }
        static get subtls() {
            return S.opts.subtls ?? S.defaults.subtls;
        }
        static set subtls(t) {
            S.opts.subtls = t;
        }
        get subtls() {
            return this.opts.subtls ?? S.subtls;
        }
        set subtls(t) {
            this.opts.subtls = t;
        }
        static get pipelineTLS() {
            return S.opts.pipelineTLS ?? S.defaults.pipelineTLS;
        }
        static set pipelineTLS(t) {
            S.opts.pipelineTLS = t;
        }
        get pipelineTLS() {
            return this.opts.pipelineTLS ?? S.pipelineTLS;
        }
        set pipelineTLS(t) {
            this.opts.pipelineTLS = t;
        }
        static get rootCerts() {
            return S.opts.rootCerts ?? S.defaults.rootCerts;
        }
        static set rootCerts(t) {
            S.opts.rootCerts = t;
        }
        get rootCerts() {
            return this.opts.rootCerts ?? S.rootCerts;
        }
        set rootCerts(t) {
            this.opts.rootCerts = t;
        }
        wsProxyAddrForHost(t, n) {
            let i = this.wsProxy;
            if (i === void 0) throw new Error("No WebSocket proxy is configured. Please see https://github.c\
om/neondatabase/serverless/blob/main/CONFIG.md#wsproxy-string--host-string-port-number--string--stri\
ng");
            return typeof i == "function" ? i(t, n) : `${i}?address=${t}:${n}`;
        }
        setNoDelay() {
            return this;
        }
        setKeepAlive() {
            return this;
        }
        ref() {
            return this;
        }
        unref() {
            return this;
        }
        connect(t, n, i) {
            this.connecting = !0, i && this.once("co\
nnect", i);
            let s = a(()=>{
                this.connecting = !1, this.pending = !1, this.emit("connect"), this.emit("ready");
            }, "\
handleWebSocketOpen"), o = a((c, l = !1)=>{
                c.binaryType = "arraybuffer", c.addEventListener("error", (f)=>{
                    this.emit("error", f), this.emit("close");
                }), c.addEventListener("message", (f)=>{
                    if (this.tlsState === 0) {
                        let y = d.from(f.data);
                        this.emit("data", y);
                    }
                }), c.addEventListener("close", ()=>{
                    this.emit("close");
                }), l ? s() : c.addEventListener("open", s);
            }, "configureWebSocket"), u;
            try {
                u = this.wsProxyAddrForHost(n, typeof t == "string" ? parseInt(t, 10) : t);
            } catch (c) {
                this.emit("error", c), this.emit("close");
                return;
            }
            try {
                let l = (this.useSecureWebSocket ? "wss:" : "ws:") + "//" + u;
                if (this.webSocketConstructor !== void 0) this.ws = new this.webSocketConstructor(l), o(this.ws);
                else try {
                    this.ws = new WebSocket(l), o(this.ws);
                } catch  {
                    this.ws = new __unstable_WebSocket(l), o(this.ws);
                }
            } catch (c) {
                let f = (this.useSecureWebSocket ? "https:" : "http:") + "//" + u;
                fetch(f, {
                    headers: {
                        Upgrade: "websocket"
                    }
                }).then((y)=>{
                    if (this.ws = y.webSocket, this.ws == null) throw c;
                    this.ws.accept(), o(this.ws, !0);
                }).catch((y)=>{
                    this.emit("error", new Error(`All attempts to open a WebSocket to connect to the database failed. Please refer \
to https://github.com/neondatabase/serverless/blob/main/CONFIG.md#websocketconstructor-typeof-websoc\
ket--undefined. Details: ${y}`)), this.emit("close");
                });
            }
        }
        async startTls(t) {
            if (this.subtls === void 0) throw new Error("For Postgres SSL connections, you must set `neonConfig.subtls` to the subtls library. See https://g\
ithub.com/neondatabase/serverless/blob/main/CONFIG.md for more information.");
            this.tlsState = 1;
            let n = await this.subtls.TrustedCert.databaseFromPEM(this.rootCerts), i = new this.subtls.WebSocketReadQueue(this.ws), s = i.read.bind(i), o = this.rawWrite.bind(this), { read: u, write: c } = await this.subtls.startTls(t, n, s, o, {
                useSNI: !this.disableSNI,
                expectPreData: this.pipelineTLS ? new Uint8Array([
                    83
                ]) : void 0
            });
            this.tlsRead = u, this.tlsWrite = c, this.tlsState = 2, this.encrypted = !0, this.authorized = !0, this.emit("secureConnection", this), this.tlsReadLoop();
        }
        async tlsReadLoop() {
            for(;;){
                let t = await this.tlsRead();
                if (t === void 0) break;
                {
                    let n = d.from(t);
                    this.emit("data", n);
                }
            }
        }
        rawWrite(t) {
            if (!this.coalesceWrites) {
                this.ws && this.ws.send(t);
                return;
            }
            if (this.writeBuffer === void 0) this.writeBuffer = t, setTimeout(()=>{
                this.ws && this.ws.send(this.writeBuffer), this.writeBuffer = void 0;
            }, 0);
            else {
                let n = new Uint8Array(this.writeBuffer.length + t.length);
                n.set(this.writeBuffer), n.set(t, this.writeBuffer.length), this.writeBuffer = n;
            }
        }
        write(t, n = "utf8", i = (s)=>{}) {
            return t.length === 0 ? (i(), !0) : (typeof t == "string" && (t = d.from(t, n)), this.tlsState === 0 ? (this.rawWrite(t), i()) : this.tlsState === 1 ? this.once("secureConnection", ()=>{
                this.write(t, n, i);
            }) : (this.tlsWrite(t), i()), !0);
        }
        end(t = d.alloc(0), n = "utf8", i = ()=>{}) {
            return this.write(t, n, ()=>{
                this.ws.close(), i();
            }), this;
        }
        destroy() {
            return this.destroyed = !0, this.end();
        }
    };
    a(S, "Socket"), E(S, "defaults", {
        poolQueryViaFetch: !1,
        fetchEndpoint: a((t, n, i)=>{
            let s;
            return i?.jwtAuth ? s = t.replace(yi, "apiauth.") : s = t.replace(yi, "api."), "https://" + s + "/sql";
        }, "fetchEndpoint"),
        fetchConnectionCache: !0,
        fetchFunction: void 0,
        webSocketConstructor: void 0,
        wsProxy: a((t)=>t + "/v2", "wsProxy"),
        useSecureWebSocket: !0,
        forceDisablePgSSL: !0,
        coalesceWrites: !0,
        pipelineConnect: "password",
        subtls: void 0,
        rootCerts: "",
        pipelineTLS: !1,
        disableSNI: !1,
        disableWarningInBrowsers: !1
    }), E(S, "opts", {});
    ce = S;
});
var gi = {};
ie(gi, {
    parse: ()=>Yt
});
function Yt(r, e = !1) {
    let { protocol: t } = new URL(r), n = "http:" + r.substring(t.length), { username: i, password: s, host: o, hostname: u, port: c, pathname: l, search: f, searchParams: y, hash: g } = new URL(n);
    s = decodeURIComponent(s), i = decodeURIComponent(i), l = decodeURIComponent(l);
    let A = i + ":" + s, C = e ? Object.fromEntries(y.entries()) : f;
    return {
        href: r,
        protocol: t,
        auth: A,
        username: i,
        password: s,
        host: o,
        hostname: u,
        port: c,
        pathname: l,
        search: f,
        query: C,
        hash: g
    };
}
var Zt = G(()=>{
    "use strict";
    p();
    a(Yt, "parse");
});
var tr = T((Ai)=>{
    "use strict";
    p();
    Ai.parse = function(r, e) {
        return new er(r, e).parse();
    };
    var vt = class vt {
        constructor(e, t){
            this.source = e, this.transform = t || Ca, this.position = 0, this.entries = [], this.recorded = [], this.dimension = 0;
        }
        isEof() {
            return this.position >= this.source.length;
        }
        nextCharacter() {
            var e = this.source[this.position++];
            return e === "\\" ? {
                value: this.source[this.position++],
                escaped: !0
            } : {
                value: e,
                escaped: !1
            };
        }
        record(e) {
            this.recorded.push(e);
        }
        newEntry(e) {
            var t;
            (this.recorded.length > 0 || e) && (t = this.recorded.join(""), t === "NULL" && !e && (t = null), t !== null && (t = this.transform(t)), this.entries.push(t), this.recorded = []);
        }
        consumeDimensions() {
            if (this.source[0] === "[") for(; !this.isEof();){
                var e = this.nextCharacter();
                if (e.value === "=") break;
            }
        }
        parse(e) {
            var t, n, i;
            for(this.consumeDimensions(); !this.isEof();)if (t = this.nextCharacter(), t.value === "{" && !i) this.dimension++, this.dimension > 1 && (n = new vt(this.source.substr(this.position - 1), this.transform), this.entries.push(n.parse(!0)), this.position += n.position - 2);
            else if (t.value === "}" && !i) {
                if (this.dimension--, !this.dimension && (this.newEntry(), e)) return this.entries;
            } else t.value === '"' && !t.escaped ? (i && this.newEntry(!0), i = !i) : t.value === "," && !i ? this.newEntry() : this.record(t.value);
            if (this.dimension !== 0) throw new Error("array dimension \
not balanced");
            return this.entries;
        }
    };
    a(vt, "ArrayParser");
    var er = vt;
    function Ca(r) {
        return r;
    }
    a(Ca, "ide\
ntity");
});
var rr = T((Zl, Ci)=>{
    p();
    var _a = tr();
    Ci.exports = {
        create: a(function(r, e) {
            return {
                parse: a(function() {
                    return _a.parse(r, e);
                }, "parse")
            };
        }, "create")
    };
});
var Ti = T((ef, Ii)=>{
    "use strict";
    p();
    var Ia = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/, Ta = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/, Pa = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/, Ba = /^-?infinity$/;
    Ii.exports = a(function(e) {
        if (Ba.test(e)) return Number(e.replace("i", "I"));
        var t = Ia.exec(e);
        if (!t) return Ra(e) || null;
        var n = !!t[8], i = parseInt(t[1], 10);
        n && (i = _i(i));
        var s = parseInt(t[2], 10) - 1, o = t[3], u = parseInt(t[4], 10), c = parseInt(t[5], 10), l = parseInt(t[6], 10), f = t[7];
        f = f ? 1e3 * parseFloat(f) : 0;
        var y, g = La(e);
        return g != null ? (y = new Date(Date.UTC(i, s, o, u, c, l, f)), nr(i) && y.setUTCFullYear(i), g !== 0 && y.setTime(y.getTime() - g)) : (y = new Date(i, s, o, u, c, l, f), nr(i) && y.setFullYear(i)), y;
    }, "parseDate");
    function Ra(r) {
        var e = Ta.exec(r);
        if (e) {
            var t = parseInt(e[1], 10), n = !!e[4];
            n && (t = _i(t));
            var i = parseInt(e[2], 10) - 1, s = e[3], o = new Date(t, i, s);
            return nr(t) && o.setFullYear(t), o;
        }
    }
    a(Ra, "getDate");
    function La(r) {
        if (r.endsWith("+00")) return 0;
        var e = Pa.exec(r.split(" ")[1]);
        if (e) {
            var t = e[1];
            if (t === "Z") return 0;
            var n = t === "-" ? -1 : 1, i = parseInt(e[2], 10) * 3600 + parseInt(e[3] || 0, 10) * 60 + parseInt(e[4] || 0, 10);
            return i * n * 1e3;
        }
    }
    a(La, "timeZoneOffset");
    function _i(r) {
        return -(r - 1);
    }
    a(_i, "bcYearToNegativeYear");
    function nr(r) {
        return r >= 0 && r < 100;
    }
    a(nr, "is0To99");
});
var Bi = T((nf, Pi)=>{
    p();
    Pi.exports = ka;
    var Fa = Object.prototype.hasOwnProperty;
    function ka(r) {
        for(var e = 1; e < arguments.length; e++){
            var t = arguments[e];
            for(var n in t)Fa.call(t, n) && (r[n] = t[n]);
        }
        return r;
    }
    a(ka, "ext\
end");
});
var Fi = T((af, Li)=>{
    "use strict";
    p();
    var Ma = Bi();
    Li.exports = ke;
    function ke(r) {
        if (!(this instanceof ke)) return new ke(r);
        Ma(this, Va(r));
    }
    a(ke, "PostgresInterval");
    var Ua = [
        "seconds",
        "minutes",
        "hours",
        "days",
        "months",
        "years"
    ];
    ke.prototype.toPostgres = function() {
        var r = Ua.filter(this.hasOwnProperty, this);
        return this.milliseconds && r.indexOf("seconds") < 0 && r.push("seconds"), r.length === 0 ? "0" : r.map(function(e) {
            var t = this[e] || 0;
            return e === "seconds" && this.milliseconds && (t = (t + this.milliseconds / 1e3).toFixed(6).replace(/\.?0+$/, "")), t + " " + e;
        }, this).join(" ");
    };
    var Da = {
        years: "Y",
        months: "M",
        days: "D",
        hours: "H",
        minutes: "M",
        seconds: "\
S"
    }, Oa = [
        "years",
        "months",
        "days"
    ], qa = [
        "hours",
        "minutes",
        "seconds"
    ];
    ke.prototype.toISOString = ke.prototype.toISO = function() {
        var r = Oa.map(t, this).join(""), e = qa.map(t, this).join("");
        return "P" + r + "T" + e;
        //TURBOPACK unreachable
        ;
        function t(n) {
            var i = this[n] || 0;
            return n === "seconds" && this.milliseconds && (i = (i + this.milliseconds / 1e3).toFixed(6).replace(/0+$/, "")), i + Da[n];
        }
    };
    var ir = "([+-]?\\d+)", Qa = ir + "\\s+years?", Na = ir + "\\s+mons?", Wa = ir + "\\s+days?", ja = "\
([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?", Ha = new RegExp([
        Qa,
        Na,
        Wa,
        ja
    ].map(function(r) {
        return "\
(" + r + ")?";
    }).join("\\s*")), Ri = {
        years: 2,
        months: 4,
        days: 6,
        hours: 9,
        minutes: 10,
        seconds: 11,
        milliseconds: 12
    }, $a = [
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
    ];
    function Ga(r) {
        var e = r + "000000".slice(r.length);
        return parseInt(e, 10) / 1e3;
    }
    a(Ga, "parseMilliseconds");
    function Va(r) {
        if (!r) return {};
        var e = Ha.exec(r), t = e[8] === "-";
        return Object.keys(Ri).reduce(function(n, i) {
            var s = Ri[i], o = e[s];
            return !o || (o = i === "milliseconds" ? Ga(o) : parseInt(o, 10), !o) || (t && ~$a.indexOf(i) && (o *= -1), n[i] = o), n;
        }, {});
    }
    a(Va, "parse");
});
var Mi = T((lf, ki)=>{
    "use strict";
    p();
    ki.exports = a(function(e) {
        if (/^\\x/.test(e)) return new d(e.substr(2), "hex");
        for(var t = "", n = 0; n < e.length;)if (e[n] !== "\\") t += e[n], ++n;
        else if (/[0-7]{3}/.test(e.substr(n + 1, 3))) t += String.fromCharCode(parseInt(e.substr(n + 1, 3), 8)), n += 4;
        else {
            for(var i = 1; n + i < e.length && e[n + i] === "\\";)i++;
            for(var s = 0; s < Math.floor(i / 2); ++s)t += "\\";
            n += Math.floor(i / 2) * 2;
        }
        return new d(t, "binary");
    }, "\
parseBytea");
});
var Wi = T((pf, Ni)=>{
    p();
    var Ve = tr(), ze = rr(), xt = Ti(), Di = Fi(), Oi = Mi();
    function St(r) {
        return a(function(t) {
            return t === null ? t : r(t);
        }, "nullAllowed");
    }
    a(St, "allowNull");
    function qi(r) {
        return r === null ? r : r === "TRUE" || r === "t" || r === "true" || r === "y" || r === "yes" || r === "on" || r === "1";
    }
    a(qi, "parseBool");
    function za(r) {
        return r ? Ve.parse(r, qi) : null;
    }
    a(za, "parseBoolArray");
    function Ka(r) {
        return parseInt(r, 10);
    }
    a(Ka, "parseBaseTenIn\
t");
    function sr(r) {
        return r ? Ve.parse(r, St(Ka)) : null;
    }
    a(sr, "parseIntegerArray");
    function Ya(r) {
        return r ? Ve.parse(r, St(function(e) {
            return Qi(e).trim();
        })) : null;
    }
    a(Ya, "parseBigIntegerArray");
    var Za = a(function(r) {
        if (!r) return null;
        var e = ze.create(r, function(t) {
            return t !== null && (t = cr(t)), t;
        });
        return e.parse();
    }, "pa\
rsePointArray"), or = a(function(r) {
        if (!r) return null;
        var e = ze.create(r, function(t) {
            return t !== null && (t = parseFloat(t)), t;
        });
        return e.parse();
    }, "parseFloatArray"), re = a(function(r) {
        if (!r) return null;
        var e = ze.create(r);
        return e.parse();
    }, "parseStringArray"), ar = a(function(r) {
        if (!r) return null;
        var e = ze.create(r, function(t) {
            return t !== null && (t = xt(t)), t;
        });
        return e.parse();
    }, "parseDateArray"), Ja = a(function(r) {
        if (!r) return null;
        var e = ze.create(r, function(t) {
            return t !== null && (t = Di(t)), t;
        });
        return e.parse();
    }, "parseInt\
ervalArray"), Xa = a(function(r) {
        return r ? Ve.parse(r, St(Oi)) : null;
    }, "parseByteAArray"), ur = a(function(r) {
        return parseInt(r, 10);
    }, "parseInteger"), Qi = a(function(r) {
        var e = String(r);
        return /^\d+$/.test(e) ? e : r;
    }, "\
parseBigInteger"), Ui = a(function(r) {
        return r ? Ve.parse(r, St(JSON.parse)) : null;
    }, "parseJsonArray"), cr = a(function(r) {
        return r[0] !== "(" ? null : (r = r.substring(1, r.length - 1).split(","), {
            x: parseFloat(r[0]),
            y: parseFloat(r[1])
        });
    }, "parsePoint"), eu = a(function(r) {
        if (r[0] !== "<" && r[1] !== "(") return null;
        for(var e = "(", t = "", n = !1, i = 2; i < r.length - 1; i++){
            if (n || (e += r[i]), r[i] === ")") {
                n = !0;
                continue;
            } else if (!n) continue;
            r[i] !== "," && (t += r[i]);
        }
        var s = cr(e);
        return s.radius = parseFloat(t), s;
    }, "parseCircle"), tu = a(function(r) {
        r(20, Qi), r(21, ur), r(23, ur), r(26, ur), r(700, parseFloat), r(701, parseFloat), r(16, qi), r(1082, xt), r(1114, xt), r(1184, xt), r(600, cr), r(651, re), r(718, eu), r(1e3, za), r(1001, Xa), r(1005, sr), r(1007, sr), r(1028, sr), r(1016, Ya), r(1017, Za), r(1021, or), r(1022, or), r(1231, or), r(1014, re), r(1015, re), r(1008, re), r(1009, re), r(1040, re), r(1041, re), r(1115, ar), r(1182, ar), r(1185, ar), r(1186, Di), r(1187, Ja), r(17, Oi), r(114, JSON.parse.bind(JSON)), r(3802, JSON.parse.bind(JSON)), r(199, Ui), r(3807, Ui), r(3907, re), r(2951, re), r(791, re), r(1183, re), r(1270, re);
    }, "init");
    Ni.exports = {
        init: tu
    };
});
var Hi = T((mf, ji)=>{
    "use strict";
    p();
    var z = 1e6;
    function ru(r) {
        var e = r.readInt32BE(0), t = r.readUInt32BE(4), n = "";
        e < 0 && (e = ~e + (t === 0), t = ~t + 1 >>> 0, n = "-");
        var i = "", s, o, u, c, l, f;
        {
            if (s = e % z, e = e / z >>> 0, o = 4294967296 * s + t, t = o / z >>> 0, u = "" + (o - z * t), t === 0 && e === 0) return n + u + i;
            for(c = "", l = 6 - u.length, f = 0; f < l; f++)c += "0";
            i = c + u + i;
        }
        {
            if (s = e % z, e = e / z >>> 0, o = 4294967296 * s + t, t = o / z >>> 0, u = "" + (o - z * t), t === 0 && e === 0) return n + u + i;
            for(c = "", l = 6 - u.length, f = 0; f < l; f++)c += "0";
            i = c + u + i;
        }
        {
            if (s = e % z, e = e / z >>> 0, o = 4294967296 * s + t, t = o / z >>> 0, u = "" + (o - z * t), t === 0 && e === 0) return n + u + i;
            for(c = "", l = 6 - u.length, f = 0; f < l; f++)c += "0";
            i = c + u + i;
        }
        return s = e % z, o = 4294967296 * s + t, u = "" + o % z, n + u + i;
    }
    a(ru, "readInt8");
    ji.exports = ru;
});
var Ki = T((bf, zi)=>{
    p();
    var nu = Hi(), L = a(function(r, e, t, n, i) {
        t = t || 0, n = n || !1, i = i || function(A, C, D) {
            return A * Math.pow(2, D) + C;
        };
        var s = t >> 3, o = a(function(A) {
            return n ? ~A & 255 : A;
        }, "inv"), u = 255, c = 8 - t % 8;
        e < c && (u = 255 << 8 - e & 255, c = e), t && (u = u >> t % 8);
        var l = 0;
        t % 8 + e >= 8 && (l = i(0, o(r[s]) & u, c));
        for(var f = e + t >> 3, y = s + 1; y < f; y++)l = i(l, o(r[y]), 8);
        var g = (e + t) % 8;
        return g > 0 && (l = i(l, o(r[f]) >> 8 - g, g)), l;
    }, "parseBits"), Vi = a(function(r, e, t) {
        var n = Math.pow(2, t - 1) - 1, i = L(r, 1), s = L(r, t, 1);
        if (s === 0) return 0;
        var o = 1, u = a(function(l, f, y) {
            l === 0 && (l = 1);
            for(var g = 1; g <= y; g++)o /= 2, (f & 1 << y - g) > 0 && (l += o);
            return l;
        }, "parsePrecisionBits"), c = L(r, e, t + 1, !1, u);
        return s == Math.pow(2, t + 1) - 1 ? c === 0 ? i === 0 ? 1 / 0 : -1 / 0 : NaN : (i === 0 ? 1 : -1) * Math.pow(2, s - n) * c;
    }, "parseFloatFromBits"), iu = a(function(r) {
        return L(r, 1) == 1 ? -1 * (L(r, 15, 1, !0) + 1) : L(r, 15, 1);
    }, "parseInt16"), $i = a(function(r) {
        return L(r, 1) == 1 ? -1 * (L(r, 31, 1, !0) + 1) : L(r, 31, 1);
    }, "parseInt32"), su = a(function(r) {
        return Vi(r, 23, 8);
    }, "parseFloat32"), ou = a(function(r) {
        return Vi(r, 52, 11);
    }, "parseFloat64"), au = a(function(r) {
        var e = L(r, 16, 32);
        if (e == 49152) return NaN;
        for(var t = Math.pow(1e4, L(r, 16, 16)), n = 0, i = [], s = L(r, 16), o = 0; o < s; o++)n += L(r, 16, 64 + 16 * o) * t, t /= 1e4;
        var u = Math.pow(10, L(r, 16, 48));
        return (e === 0 ? 1 : -1) * Math.round(n * u) / u;
    }, "parseNumeric"), Gi = a(function(r, e) {
        var t = L(e, 1), n = L(e, 63, 1), i = new Date((t === 0 ? 1 : -1) * n / 1e3 + 9466848e5);
        return r || i.setTime(i.getTime() + i.getTimezoneOffset() * 6e4), i.usec = n % 1e3, i.getMicroSeconds = function() {
            return this.usec;
        }, i.setMicroSeconds = function(s) {
            this.usec = s;
        }, i.getUTCMicroSeconds = function() {
            return this.usec;
        }, i;
    }, "parseDate"), Ke = a(function(r) {
        for(var e = L(r, 32), t = L(r, 32, 32), n = L(r, 32, 64), i = 96, s = [], o = 0; o < e; o++)s[o] = L(r, 32, i), i += 32, i += 32;
        var u = a(function(l) {
            var f = L(r, 32, i);
            if (i += 32, f == 4294967295) return null;
            var y;
            if (l == 23 || l == 20) return y = L(r, f * 8, i), i += f * 8, y;
            if (l == 25) return y = r.toString(this.encoding, i >> 3, (i += f << 3) >> 3), y;
            console.log("ERROR: ElementType no\
t implemented: " + l);
        }, "parseElement"), c = a(function(l, f) {
            var y = [], g;
            if (l.length > 1) {
                var A = l.shift();
                for(g = 0; g < A; g++)y[g] = c(l, f);
                l.unshift(A);
            } else for(g = 0; g < l[0]; g++)y[g] = u(f);
            return y;
        }, "parse");
        return c(s, n);
    }, "parseArray"), uu = a(function(r) {
        return r.toString("utf8");
    }, "parseText"), cu = a(function(r) {
        return r === null ? null : L(r, 8) > 0;
    }, "parseBool"), lu = a(function(r) {
        r(20, nu), r(21, iu), r(23, $i), r(26, $i), r(1700, au), r(700, su), r(701, ou), r(16, cu), r(1114, Gi.bind(null, !1)), r(1184, Gi.bind(null, !0)), r(1e3, Ke), r(1007, Ke), r(1016, Ke), r(1008, Ke), r(1009, Ke), r(25, uu);
    }, "init");
    zi.exports = {
        init: lu
    };
});
var Zi = T((Sf, Yi)=>{
    p();
    Yi.exports = {
        BOOL: 16,
        BYTEA: 17,
        CHAR: 18,
        INT8: 20,
        INT2: 21,
        INT4: 23,
        REGPROC: 24,
        TEXT: 25,
        OID: 26,
        TID: 27,
        XID: 28,
        CID: 29,
        JSON: 114,
        XML: 142,
        PG_NODE_TREE: 194,
        SMGR: 210,
        PATH: 602,
        POLYGON: 604,
        CIDR: 650,
        FLOAT4: 700,
        FLOAT8: 701,
        ABSTIME: 702,
        RELTIME: 703,
        TINTERVAL: 704,
        CIRCLE: 718,
        MACADDR8: 774,
        MONEY: 790,
        MACADDR: 829,
        INET: 869,
        ACLITEM: 1033,
        BPCHAR: 1042,
        VARCHAR: 1043,
        DATE: 1082,
        TIME: 1083,
        TIMESTAMP: 1114,
        TIMESTAMPTZ: 1184,
        INTERVAL: 1186,
        TIMETZ: 1266,
        BIT: 1560,
        VARBIT: 1562,
        NUMERIC: 1700,
        REFCURSOR: 1790,
        REGPROCEDURE: 2202,
        REGOPER: 2203,
        REGOPERATOR: 2204,
        REGCLASS: 2205,
        REGTYPE: 2206,
        UUID: 2950,
        TXID_SNAPSHOT: 2970,
        PG_LSN: 3220,
        PG_NDISTINCT: 3361,
        PG_DEPENDENCIES: 3402,
        TSVECTOR: 3614,
        TSQUERY: 3615,
        GTSVECTOR: 3642,
        REGCONFIG: 3734,
        REGDICTIONARY: 3769,
        JSONB: 3802,
        REGNAMESPACE: 4089,
        REGROLE: 4096
    };
});
var Je = T((Ze)=>{
    p();
    var fu = Wi(), hu = Ki(), pu = rr(), du = Zi();
    Ze.getTypeParser = yu;
    Ze.setTypeParser = mu;
    Ze.arrayParser = pu;
    Ze.builtins = du;
    var Ye = {
        text: {},
        binary: {}
    };
    function Ji(r) {
        return String(r);
    }
    a(Ji, "noParse");
    function yu(r, e) {
        return e = e || "text", Ye[e] && Ye[e][r] || Ji;
    }
    a(yu, "getTypeParser");
    function mu(r, e, t) {
        typeof e == "function" && (t = e, e = "text"), Ye[e][r] = t;
    }
    a(mu, "setTypeParser");
    fu.init(function(r, e) {
        Ye.text[r] = e;
    });
    hu.init(function(r, e) {
        Ye.binary[r] = e;
    });
});
var At = T((If, Xi)=>{
    "use strict";
    p();
    var wu = Je();
    function Et(r) {
        this._types = r || wu, this.text = {}, this.binary = {};
    }
    a(Et, "TypeOverrides");
    Et.prototype.getOverrides = function(r) {
        switch(r){
            case "text":
                return this.text;
            case "\
binary":
                return this.binary;
            default:
                return {};
        }
    };
    Et.prototype.setTypeParser = function(r, e, t) {
        typeof e == "\
function" && (t = e, e = "text"), this.getOverrides(e)[r] = t;
    };
    Et.prototype.getTypeParser = function(r, e) {
        return e = e || "text", this.getOverrides(e)[r] || this._types.getTypeParser(r, e);
    };
    Xi.exports = Et;
});
function Xe(r) {
    let e = 1779033703, t = 3144134277, n = 1013904242, i = 2773480762, s = 1359893119, o = 2600822924, u = 528734635, c = 1541459225, l = 0, f = 0, y = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ], g = a((I, w)=>I >>> w | I << 32 - w, "rrot"), A = new Uint32Array(64), C = new Uint8Array(64), D = a(()=>{
        for(let R = 0, j = 0; R < 16; R++, j += 4)A[R] = C[j] << 24 | C[j + 1] << 16 | C[j + 2] << 8 | C[j + 3];
        for(let R = 16; R < 64; R++){
            let j = g(A[R - 15], 7) ^ g(A[R - 15], 18) ^ A[R - 15] >>> 3, le = g(A[R - 2], 17) ^ g(A[R - 2], 19) ^ A[R - 2] >>> 10;
            A[R] = A[R - 16] + j + A[R - 7] + le | 0;
        }
        let I = e, w = t, Z = n, W = i, J = s, X = o, se = u, oe = c;
        for(let R = 0; R < 64; R++){
            let j = g(J, 6) ^ g(J, 11) ^ g(J, 25), le = J & X ^ ~J & se, de = oe + j + le + y[R] + A[R] | 0, We = g(I, 2) ^ g(I, 13) ^ g(I, 22), fe = I & w ^ I & Z ^ w & Z, _e = We + fe | 0;
            oe = se, se = X, X = J, J = W + de | 0, W = Z, Z = w, w = I, I = de + _e | 0;
        }
        e = e + I | 0, t = t + w | 0, n = n + Z | 0, i = i + W | 0, s = s + J | 0, o = o + X | 0, u = u + se | 0, c = c + oe | 0, f = 0;
    }, "process"), Y = a((I)=>{
        typeof I == "string" && (I = new TextEncoder().encode(I));
        for(let w = 0; w < I.length; w++)C[f++] = I[w], f === 64 && D();
        l += I.length;
    }, "add"), P = a(()=>{
        if (C[f++] = 128, f == 64 && D(), f + 8 > 64) {
            for(; f < 64;)C[f++] = 0;
            D();
        }
        for(; f < 58;)C[f++] = 0;
        let I = l * 8;
        C[f++] = I / 1099511627776 & 255, C[f++] = I / 4294967296 & 255, C[f++] = I >>> 24, C[f++] = I >>> 16 & 255, C[f++] = I >>> 8 & 255, C[f++] = I & 255, D();
        let w = new Uint8Array(32);
        return w[0] = e >>> 24, w[1] = e >>> 16 & 255, w[2] = e >>> 8 & 255, w[3] = e & 255, w[4] = t >>> 24, w[5] = t >>> 16 & 255, w[6] = t >>> 8 & 255, w[7] = t & 255, w[8] = n >>> 24, w[9] = n >>> 16 & 255, w[10] = n >>> 8 & 255, w[11] = n & 255, w[12] = i >>> 24, w[13] = i >>> 16 & 255, w[14] = i >>> 8 & 255, w[15] = i & 255, w[16] = s >>> 24, w[17] = s >>> 16 & 255, w[18] = s >>> 8 & 255, w[19] = s & 255, w[20] = o >>> 24, w[21] = o >>> 16 & 255, w[22] = o >>> 8 & 255, w[23] = o & 255, w[24] = u >>> 24, w[25] = u >>> 16 & 255, w[26] = u >>> 8 & 255, w[27] = u & 255, w[28] = c >>> 24, w[29] = c >>> 16 & 255, w[30] = c >>> 8 & 255, w[31] = c & 255, w;
    }, "digest");
    return r === void 0 ? {
        add: Y,
        digest: P
    } : (Y(r), P());
}
var es = G(()=>{
    "use strict";
    p();
    a(Xe, "sha256");
});
var U, et, ts = G(()=>{
    "use strict";
    p();
    U = class U {
        constructor(){
            E(this, "_dataLength", 0);
            E(this, "_bufferL\
ength", 0);
            E(this, "_state", new Int32Array(4));
            E(this, "_buffer", new ArrayBuffer(68));
            E(this, "_buffer8");
            E(this, "_buffer32");
            this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
        }
        static hashByteArray(e, t = !1) {
            return this.onePassHasher.start().appendByteArray(e).end(t);
        }
        static hashStr(e, t = !1) {
            return this.onePassHasher.start().appendStr(e).end(t);
        }
        static hashAsciiStr(e, t = !1) {
            return this.onePassHasher.start().appendAsciiStr(e).end(t);
        }
        static _hex(e) {
            let t = U.hexChars, n = U.hexOut, i, s, o, u;
            for(u = 0; u < 4; u += 1)for(s = u * 8, i = e[u], o = 0; o < 8; o += 2)n[s + 1 + o] = t.charAt(i & 15), i >>>= 4, n[s + 0 + o] = t.charAt(i & 15), i >>>= 4;
            return n.join("");
        }
        static _md5cycle(e, t) {
            let n = e[0], i = e[1], s = e[2], o = e[3];
            n += (i & s | ~i & o) + t[0] - 680876936 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[1] - 389564586 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[2] + 606105819 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[3] - 1044525330 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[4] - 176418897 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[5] + 1200080426 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[6] - 1473231341 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[7] - 45705983 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[8] + 1770035416 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[9] - 1958414417 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[10] - 42063 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[11] - 1990404162 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[12] + 1804603682 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[13] - 40341101 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[14] - 1502002290 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[15] + 1236535329 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & o | s & ~o) + t[1] - 165796510 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[6] - 1069501632 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[11] + 643717713 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[0] - 373897302 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[5] - 701558691 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[10] + 38016083 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[15] - 660478335 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[4] - 405537848 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[9] + 568446438 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[14] - 1019803690 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[3] - 187363961 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[8] + 1163531501 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[13] - 1444681467 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[2] - 51403784 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[7] + 1735328473 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[12] - 1926607734 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i ^ s ^ o) + t[5] - 378558 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[8] - 2022574463 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[11] + 1839030562 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[14] - 35309556 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[1] - 1530992060 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[4] + 1272893353 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[7] - 155497632 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[10] - 1094730640 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[13] + 681279174 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[0] - 358537222 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[3] - 722521979 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[6] + 76029189 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[9] - 640364487 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[12] - 421815835 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[15] + 530742520 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[2] - 995338651 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (s ^ (i | ~o)) + t[0] - 198630844 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[7] + 1126891415 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[14] - 1416354905 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[5] - 57434055 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[12] + 1700485571 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[3] - 1894986606 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[10] - 1051523 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[1] - 2054922799 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[8] + 1873313359 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[15] - 30611744 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[6] - 1560198380 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[13] + 1309151649 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[4] - 145523070 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[11] - 1120210379 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[2] + 718787259 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[9] - 343485551 | 0, i = (i << 21 | i >>> 11) + s | 0, e[0] = n + e[0] | 0, e[1] = i + e[1] | 0, e[2] = s + e[2] | 0, e[3] = o + e[3] | 0;
        }
        start() {
            return this._dataLength = 0, this._bufferLength = 0, this._state.set(U.stateIdentity), this;
        }
        appendStr(e) {
            let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o;
            for(o = 0; o < e.length; o += 1){
                if (s = e.charCodeAt(o), s < 128) t[i++] = s;
                else if (s < 2048) t[i++] = (s >>> 6) + 192, t[i++] = s & 63 | 128;
                else if (s < 55296 || s > 56319) t[i++] = (s >>> 12) + 224, t[i++] = s >>> 6 & 63 | 128, t[i++] = s & 63 | 128;
                else {
                    if (s = (s - 55296) * 1024 + (e.charCodeAt(++o) - 56320) + 65536, s > 1114111) throw new Error("Unicode standard supports code points up to U+10FFFF");
                    t[i++] = (s >>> 18) + 240, t[i++] = s >>> 12 & 63 | 128, t[i++] = s >>> 6 & 63 | 128, t[i++] = s & 63 | 128;
                }
                i >= 64 && (this._dataLength += 64, U._md5cycle(this._state, n), i -= 64, n[0] = n[16]);
            }
            return this._bufferLength = i, this;
        }
        appendAsciiStr(e) {
            let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o = 0;
            for(;;){
                for(s = Math.min(e.length - o, 64 - i); s--;)t[i++] = e.charCodeAt(o++);
                if (i < 64) break;
                this._dataLength += 64, U._md5cycle(this._state, n), i = 0;
            }
            return this._bufferLength = i, this;
        }
        appendByteArray(e) {
            let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o = 0;
            for(;;){
                for(s = Math.min(e.length - o, 64 - i); s--;)t[i++] = e[o++];
                if (i < 64) break;
                this._dataLength += 64, U._md5cycle(this._state, n), i = 0;
            }
            return this._bufferLength = i, this;
        }
        getState() {
            let e = this._state;
            return {
                buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
                buflen: this._bufferLength,
                length: this._dataLength,
                state: [
                    e[0],
                    e[1],
                    e[2],
                    e[3]
                ]
            };
        }
        setState(e) {
            let t = e.buffer, n = e.state, i = this._state, s;
            for(this._dataLength = e.length, this._bufferLength = e.buflen, i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], s = 0; s < t.length; s += 1)this._buffer8[s] = t.charCodeAt(s);
        }
        end(e = !1) {
            let t = this._bufferLength, n = this._buffer8, i = this._buffer32, s = (t >> 2) + 1;
            this._dataLength += t;
            let o = this._dataLength * 8;
            if (n[t] = 128, n[t + 1] = n[t + 2] = n[t + 3] = 0, i.set(U.buffer32Identity.subarray(s), s), t > 55 && (U._md5cycle(this._state, i), i.set(U.buffer32Identity)), o <= 4294967295) i[14] = o;
            else {
                let u = o.toString(16).match(/(.*?)(.{0,8})$/);
                if (u === null) return;
                let c = parseInt(u[2], 16), l = parseInt(u[1], 16) || 0;
                i[14] = c, i[15] = l;
            }
            return U._md5cycle(this._state, i), e ? this._state : U._hex(this._state);
        }
    };
    a(U, "Md5"), E(U, "stateIdentity", new Int32Array([
        1732584193,
        -271733879,
        -1732584194,
        271733878
    ])), E(U, "buffer32Identity", new Int32Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ])), E(U, "hexChars", "0123456789\
abcdef"), E(U, "hexOut", []), E(U, "onePassHasher", new U);
    et = U;
});
var lr = {};
ie(lr, {
    createHash: ()=>bu,
    createHmac: ()=>vu,
    randomBytes: ()=>gu
});
function gu(r) {
    return crypto.getRandomValues(d.alloc(r));
}
function bu(r) {
    if (r === "sha256") return {
        update: a(function(e) {
            return {
                digest: a(function() {
                    return d.from(Xe(e));
                }, "digest")
            };
        }, "update")
    };
    if (r === "md5") return {
        update: a(function(e) {
            return {
                digest: a(function() {
                    return typeof e == "string" ? et.hashStr(e) : et.hashByteArray(e);
                }, "digest")
            };
        }, "update")
    };
    throw new Error(`Hash type '${r}' not supported`);
}
function vu(r, e) {
    if (r !== "sha256") throw new Error(`\
Only sha256 is supported (requested: '${r}')`);
    return {
        update: a(function(t) {
            return {
                digest: a(function() {
                    typeof e == "string" && (e = new TextEncoder().encode(e)), typeof t == "string" && (t = new TextEncoder().encode(t));
                    let n = e.length;
                    if (n > 64) e = Xe(e);
                    else if (n < 64) {
                        let c = new Uint8Array(64);
                        c.set(e), e = c;
                    }
                    let i = new Uint8Array(64), s = new Uint8Array(64);
                    for(let c = 0; c < 64; c++)i[c] = 54 ^ e[c], s[c] = 92 ^ e[c];
                    let o = new Uint8Array(t.length + 64);
                    o.set(i, 0), o.set(t, 64);
                    let u = new Uint8Array(96);
                    return u.set(s, 0), u.set(Xe(o), 64), d.from(Xe(u));
                }, "digest")
            };
        }, "update")
    };
}
var fr = G(()=>{
    "use strict";
    p();
    es();
    ts();
    a(gu, "randomBytes");
    a(bu, "createHash");
    a(vu, "createHmac");
});
var tt = T((Qf, hr)=>{
    "use strict";
    p();
    hr.exports = {
        host: "localhost",
        user: m.platform === "win32" ? m.env.USERNAME : m.env.USER,
        database: void 0,
        password: null,
        connectionString: void 0,
        port: 5432,
        rows: 0,
        binary: !1,
        max: 10,
        idleTimeoutMillis: 3e4,
        client_encoding: "",
        ssl: !1,
        application_name: void 0,
        fallback_application_name: void 0,
        options: void 0,
        parseInputDatesAsUTC: !1,
        statement_timeout: !1,
        lock_timeout: !1,
        idle_in_transaction_session_timeout: !1,
        query_timeout: !1,
        connect_timeout: 0,
        keepalives: 1,
        keepalives_idle: 0
    };
    var Me = Je(), xu = Me.getTypeParser(20, "text"), Su = Me.getTypeParser(1016, "text");
    hr.exports.__defineSetter__("parseInt8", function(r) {
        Me.setTypeParser(20, "text", r ? Me.getTypeParser(23, "text") : xu), Me.setTypeParser(1016, "text", r ? Me.getTypeParser(1007, "text") : Su);
    });
});
var rt = T((Wf, ns)=>{
    "use strict";
    p();
    var Eu = (fr(), O(lr)), Au = tt();
    function Cu(r) {
        var e = r.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        return '"' + e + '"';
    }
    a(Cu, "escapeElement");
    function rs(r) {
        for(var e = "{", t = 0; t < r.length; t++)t > 0 && (e = e + ","), r[t] === null || typeof r[t] > "u" ? e = e + "NULL" : Array.isArray(r[t]) ? e = e + rs(r[t]) : r[t] instanceof d ? e += "\\\\x" + r[t].toString("hex") : e += Cu(Ct(r[t]));
        return e = e + "}", e;
    }
    a(rs, "arrayString");
    var Ct = a(function(r, e) {
        if (r == null) return null;
        if (r instanceof d) return r;
        if (ArrayBuffer.isView(r)) {
            var t = d.from(r.buffer, r.byteOffset, r.byteLength);
            return t.length === r.byteLength ? t : t.slice(r.byteOffset, r.byteOffset + r.byteLength);
        }
        return r instanceof Date ? Au.parseInputDatesAsUTC ? Tu(r) : Iu(r) : Array.isArray(r) ? rs(r) : typeof r == "object" ? _u(r, e) : r.toString();
    }, "prepareValue");
    function _u(r, e) {
        if (r && typeof r.toPostgres == "function") {
            if (e = e || [], e.indexOf(r) !== -1) throw new Error('circular reference detected while preparing "' + r + '" fo\
r query');
            return e.push(r), Ct(r.toPostgres(Ct), e);
        }
        return JSON.stringify(r);
    }
    a(_u, "prepareObject");
    function N(r, e) {
        for(r = "" + r; r.length < e;)r = "0" + r;
        return r;
    }
    a(N, "pad");
    function Iu(r) {
        var e = -r.getTimezoneOffset(), t = r.getFullYear(), n = t < 1;
        n && (t = Math.abs(t) + 1);
        var i = N(t, 4) + "-" + N(r.getMonth() + 1, 2) + "-" + N(r.getDate(), 2) + "T" + N(r.getHours(), 2) + ":" + N(r.getMinutes(), 2) + ":" + N(r.getSeconds(), 2) + "." + N(r.getMilliseconds(), 3);
        return e < 0 ? (i += "-", e *= -1) : i += "+", i += N(Math.floor(e / 60), 2) + ":" + N(e % 60, 2), n && (i += " BC"), i;
    }
    a(Iu, "dateToString");
    function Tu(r) {
        var e = r.getUTCFullYear(), t = e < 1;
        t && (e = Math.abs(e) + 1);
        var n = N(e, 4) + "-" + N(r.getUTCMonth() + 1, 2) + "-" + N(r.getUTCDate(), 2) + "T" + N(r.getUTCHours(), 2) + ":" + N(r.getUTCMinutes(), 2) + ":" + N(r.getUTCSeconds(), 2) + "." + N(r.getUTCMilliseconds(), 3);
        return n += "+00:00", t && (n += " BC"), n;
    }
    a(Tu, "dateToStringUTC");
    function Pu(r, e, t) {
        return r = typeof r == "string" ? {
            text: r
        } : r, e && (typeof e == "function" ? r.callback = e : r.values = e), t && (r.callback = t), r;
    }
    a(Pu, "normalizeQueryConfig");
    var pr = a(function(r) {
        return Eu.createHash("md5").update(r, "utf-8").digest("hex");
    }, "md5"), Bu = a(function(r, e, t) {
        var n = pr(e + r), i = pr(d.concat([
            d.from(n),
            t
        ]));
        return "md5" + i;
    }, "postgresMd5PasswordHash");
    ns.exports = {
        prepareValue: a(function(e) {
            return Ct(e);
        }, "prepareValueWrapper"),
        normalizeQueryConfig: Pu,
        postgresMd5PasswordHash: Bu,
        md5: pr
    };
});
var nt = {};
ie(nt, {
    default: ()=>ku
});
var ku, it = G(()=>{
    "use strict";
    p();
    ku = {};
});
var ds = T((th, ps)=>{
    "use strict";
    p();
    var yr = (fr(), O(lr));
    function Mu(r) {
        if (r.indexOf("SCRAM-SHA-256") === -1) throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
        let e = yr.randomBytes(18).toString("base64");
        return {
            mechanism: "SCRAM-SHA-256",
            clientNonce: e,
            response: "n,,n=*,r=" + e,
            message: "\
SASLInitialResponse"
        };
    }
    a(Mu, "startSession");
    function Uu(r, e, t) {
        if (r.message !== "SASLInitialResponse") throw new Error("SASL: Last message was not SASLInitialResponse");
        if (typeof e != "string") throw new Error("SASL: SCRAM\
-SERVER-FIRST-MESSAGE: client password must be a string");
        if (typeof t != "string") throw new Error("SAS\
L: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
        let n = qu(t);
        if (n.nonce.startsWith(r.clientNonce)) {
            if (n.nonce.length === r.clientNonce.length) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server n\
once is too short");
        } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not st\
art with client nonce");
        var i = d.from(n.salt, "base64"), s = Wu(e, i, n.iteration), o = Ue(s, "Client Key"), u = Nu(o), c = "n=*,r=" + r.clientNonce, l = "r=" + n.nonce + ",s=" + n.salt + ",i=" + n.iteration, f = "c=biws,r=" + n.nonce, y = c + "," + l + "," + f, g = Ue(u, y), A = hs(o, g), C = A.toString("base64"), D = Ue(s, "Server Key"), Y = Ue(D, y);
        r.message = "SAS\
LResponse", r.serverSignature = Y.toString("base64"), r.response = f + ",p=" + C;
    }
    a(Uu, "continueSession");
    function Du(r, e) {
        if (r.message !== "SASLResponse") throw new Error("SASL: Last message was not SASLResponse");
        if (typeof e != "string") throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
        let { serverSignature: t } = Qu(e);
        if (t !== r.serverSignature) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does\
 not match");
    }
    a(Du, "finalizeSession");
    function Ou(r) {
        if (typeof r != "string") throw new TypeError("SASL:\
 text must be a string");
        return r.split("").map((e, t)=>r.charCodeAt(t)).every((e)=>e >= 33 && e <= 43 || e >= 45 && e <= 126);
    }
    a(Ou, "isPrintableChars");
    function ls(r) {
        return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(r);
    }
    a(ls, "isBase64");
    function fs(r) {
        if (typeof r != "string") throw new TypeError("SASL: attribute p\
airs text must be a string");
        return new Map(r.split(",").map((e)=>{
            if (!/^.=/.test(e)) throw new Error("\
SASL: Invalid attribute pair entry");
            let t = e[0], n = e.substring(2);
            return [
                t,
                n
            ];
        }));
    }
    a(fs, "parseAttribute\
Pairs");
    function qu(r) {
        let e = fs(r), t = e.get("r");
        if (t) {
            if (!Ou(t)) throw new Error("SASL: SCRAM-SERVER-\
FIRST-MESSAGE: nonce must only contain printable characters");
        } else throw new Error("SASL: SCRAM-SERV\
ER-FIRST-MESSAGE: nonce missing");
        let n = e.get("s");
        if (n) {
            if (!ls(n)) throw new Error("SASL: SCRAM-SERV\
ER-FIRST-MESSAGE: salt must be base64");
        } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt\
 missing");
        let i = e.get("i");
        if (i) {
            if (!/^[1-9][0-9]*$/.test(i)) throw new Error("SASL: SCRAM-SERVER-FI\
RST-MESSAGE: invalid iteration count");
        } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: itera\
tion missing");
        let s = parseInt(i, 10);
        return {
            nonce: t,
            salt: n,
            iteration: s
        };
    }
    a(qu, "parseServerFirstMessage");
    function Qu(r) {
        let t = fs(r).get("v");
        if (t) {
            if (!ls(t)) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAG\
E: server signature must be base64");
        } else throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server \
signature is missing");
        return {
            serverSignature: t
        };
    }
    a(Qu, "parseServerFinalMessage");
    function hs(r, e) {
        if (!d.isBuffer(r)) throw new TypeError("first argument must be a Buffer");
        if (!d.isBuffer(e)) throw new TypeError("second argument must be a Buffer");
        if (r.length !== e.length) throw new Error("Buffer lengths must matc\
h");
        if (r.length === 0) throw new Error("Buffers cannot be empty");
        return d.from(r.map((t, n)=>r[n] ^ e[n]));
    }
    a(hs, "xorBuffers");
    function Nu(r) {
        return yr.createHash("sha256").update(r).digest();
    }
    a(Nu, "sha256");
    function Ue(r, e) {
        return yr.createHmac("sha256", r).update(e).digest();
    }
    a(Ue, "hmacSha256");
    function Wu(r, e, t) {
        for(var n = Ue(r, d.concat([
            e,
            d.from([
                0,
                0,
                0,
                1
            ])
        ])), i = n, s = 0; s < t - 1; s++)n = Ue(r, n), i = hs(i, n);
        return i;
    }
    a(Wu, "Hi");
    ps.exports = {
        startSession: Mu,
        continueSession: Uu,
        finalizeSession: Du
    };
});
var mr = {};
ie(mr, {
    join: ()=>ju
});
function ju(...r) {
    return r.join("/");
}
var wr = G(()=>{
    "use strict";
    p();
    a(ju, "join");
});
var gr = {};
ie(gr, {
    stat: ()=>Hu
});
function Hu(r, e) {
    e(new Error("No filesystem"));
}
var br = G(()=>{
    "use str\
ict";
    p();
    a(Hu, "stat");
});
var vr = {};
ie(vr, {
    default: ()=>$u
});
var $u, xr = G(()=>{
    "use strict";
    p();
    $u = {};
});
var ys = {};
ie(ys, {
    StringDecoder: ()=>Sr
});
var Er, Sr, ms = G(()=>{
    "use strict";
    p();
    Er = class Er {
        constructor(e){
            E(this, "td");
            this.td = new TextDecoder(e);
        }
        write(e) {
            return this.td.decode(e, {
                stream: !0
            });
        }
        end(e) {
            return this.td.decode(e);
        }
    };
    a(Er, "StringDecoder");
    Sr = Er;
});
var vs = T((fh, bs)=>{
    "use strict";
    p();
    var { Transform: Gu } = (xr(), O(vr)), { StringDecoder: Vu } = (ms(), O(ys)), ve = Symbol("last"), It = Symbol("decoder");
    function zu(r, e, t) {
        let n;
        if (this.overflow) {
            if (n = this[It].write(r).split(this.matcher), n.length === 1) return t();
            n.shift(), this.overflow = !1;
        } else this[ve] += this[It].write(r), n = this[ve].split(this.matcher);
        this[ve] = n.pop();
        for(let i = 0; i < n.length; i++)try {
            gs(this, this.mapper(n[i]));
        } catch (s) {
            return t(s);
        }
        if (this.overflow = this[ve].length > this.maxLength, this.overflow && !this.skipOverflow) {
            t(new Error("maximum buffer reached"));
            return;
        }
        t();
    }
    a(zu, "transform");
    function Ku(r) {
        if (this[ve] += this[It].end(), this[ve]) try {
            gs(this, this.mapper(this[ve]));
        } catch (e) {
            return r(e);
        }
        r();
    }
    a(Ku, "flush");
    function gs(r, e) {
        e !== void 0 && r.push(e);
    }
    a(gs, "push");
    function ws(r) {
        return r;
    }
    a(ws, "noop");
    function Yu(r, e, t) {
        switch(r = r || /\r?\n/, e = e || ws, t = t || {}, arguments.length){
            case 1:
                typeof r == "function" ? (e = r, r = /\r?\n/) : typeof r == "object" && !(r instanceof RegExp) && !r[Symbol.split] && (t = r, r = /\r?\n/);
                break;
            case 2:
                typeof r == "function" ? (t = e, e = r, r = /\r?\n/) : typeof e == "object" && (t = e, e = ws);
        }
        t = Object.assign({}, t), t.autoDestroy = !0, t.transform = zu, t.flush = Ku, t.readableObjectMode = !0;
        let n = new Gu(t);
        return n[ve] = "", n[It] = new Vu("utf8"), n.matcher = r, n.mapper = e, n.maxLength = t.maxLength, n.skipOverflow = t.skipOverflow || !1, n.overflow = !1, n._destroy = function(i, s) {
            this._writableState.errorEmitted = !1, s(i);
        }, n;
    }
    a(Yu, "split");
    bs.exports = Yu;
});
var Es = T((dh, pe)=>{
    "use strict";
    p();
    var xs = (wr(), O(mr)), Zu = (xr(), O(vr)).Stream, Ju = vs(), Ss = (it(), O(nt)), Xu = 5432, Tt = m.platform === "win32", st = m.stderr, ec = 56, tc = 7, rc = 61440, nc = 32768;
    function ic(r) {
        return (r & rc) == nc;
    }
    a(ic, "isRegFile");
    var De = [
        "host",
        "port",
        "database",
        "user",
        "password"
    ], Ar = De.length, sc = De[Ar - 1];
    function Cr() {
        var r = st instanceof Zu && st.writable === !0;
        if (r) {
            var e = Array.prototype.slice.call(arguments).concat(`
`);
            st.write(Ss.format.apply(Ss, e));
        }
    }
    a(Cr, "warn");
    Object.defineProperty(pe.exports, "isWin", {
        get: a(function() {
            return Tt;
        }, "get"),
        set: a(function(r) {
            Tt = r;
        }, "set")
    });
    pe.exports.warnTo = function(r) {
        var e = st;
        return st = r, e;
    };
    pe.exports.getFileName = function(r) {
        var e = r || m.env, t = e.PGPASSFILE || (Tt ? xs.join(e.APPDATA || "./", "\
postgresql", "pgpass.conf") : xs.join(e.HOME || "./", ".pgpass"));
        return t;
    };
    pe.exports.usePgPass = function(r, e) {
        return Object.prototype.hasOwnProperty.call(m.env, "PGPASSWORD") ? !1 : Tt ? !0 : (e = e || "<unkn>", ic(r.mode) ? r.mode & (ec | tc) ? (Cr('WARNING: password file "%s" has group or world access; permissions should be u=rw \
(0600) or less', e), !1) : !0 : (Cr('WARNING: password file "%s" is not a plain file', e), !1));
    };
    var oc = pe.exports.match = function(r, e) {
        return De.slice(0, -1).reduce(function(t, n, i) {
            return i == 1 && Number(r[n] || Xu) === Number(e[n]) ? t && !0 : t && (e[n] === "*" || e[n] === r[n]);
        }, !0);
    };
    pe.exports.getPassword = function(r, e, t) {
        var n, i = e.pipe(Ju());
        function s(c) {
            var l = ac(c);
            l && uc(l) && oc(r, l) && (n = l[sc], i.end());
        }
        a(s, "onLine");
        var o = a(function() {
            e.destroy(), t(n);
        }, "onEnd"), u = a(function(c) {
            e.destroy(), Cr("WARNING: error on reading file: %s", c), t(void 0);
        }, "onErr");
        e.on("error", u), i.on("data", s).on("end", o).on("error", u);
    };
    var ac = pe.exports.parseLine = function(r) {
        if (r.length < 11 || r.match(/^\s+#/)) return null;
        for(var e = "", t = "", n = 0, i = 0, s = 0, o = {}, u = !1, c = a(function(f, y, g) {
            var A = r.substring(y, g);
            Object.hasOwnProperty.call(m.env, "PGPASS_NO_DEESCAPE") || (A = A.replace(/\\([:\\])/g, "$1")), o[De[f]] = A;
        }, "addToObj"), l = 0; l < r.length - 1; l += 1){
            if (e = r.charAt(l + 1), t = r.charAt(l), u = n == Ar - 1, u) {
                c(n, i);
                break;
            }
            l >= 0 && e == ":" && t !== "\\" && (c(n, i, l + 1), i = l + 2, n += 1);
        }
        return o = Object.keys(o).length === Ar ? o : null, o;
    }, uc = pe.exports.isValidEntry = function(r) {
        for(var e = {
            0: function(o) {
                return o.length > 0;
            },
            1: function(o) {
                return o === "*" ? !0 : (o = Number(o), isFinite(o) && o > 0 && o < 9007199254740992 && Math.floor(o) === o);
            },
            2: function(o) {
                return o.length > 0;
            },
            3: function(o) {
                return o.length > 0;
            },
            4: function(o) {
                return o.length > 0;
            }
        }, t = 0; t < De.length; t += 1){
            var n = e[t], i = r[De[t]] || "", s = n(i);
            if (!s) return !1;
        }
        return !0;
    };
});
var Cs = T((gh, _r)=>{
    "use strict";
    p();
    var wh = (wr(), O(mr)), As = (br(), O(gr)), Pt = Es();
    _r.exports = function(r, e) {
        var t = Pt.getFileName();
        As.stat(t, function(n, i) {
            if (n || !Pt.usePgPass(i, t)) return e(void 0);
            var s = As.createReadStream(t);
            Pt.getPassword(r, s, e);
        });
    };
    _r.exports.warnTo = Pt.warnTo;
});
var _s = {};
ie(_s, {
    default: ()=>cc
});
var cc, Is = G(()=>{
    "use strict";
    p();
    cc = {};
});
var Ps = T((xh, Ts)=>{
    "use strict";
    p();
    var lc = (Zt(), O(gi)), Ir = (br(), O(gr));
    function Tr(r) {
        if (r.charAt(0) === "/") {
            var t = r.split(" ");
            return {
                host: t[0],
                database: t[1]
            };
        }
        var e = lc.parse(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(r) ? encodeURI(r).replace(/\%25(\d\d)/g, "%$1") : r, !0), t = e.query;
        for(var n in t)Array.isArray(t[n]) && (t[n] = t[n][t[n].length - 1]);
        var i = (e.auth || ":").split(":");
        if (t.user = i[0], t.password = i.splice(1).join(":"), t.port = e.port, e.protocol == "socket:") return t.host = decodeURI(e.pathname), t.database = e.query.db, t.client_encoding = e.query.encoding, t;
        t.host || (t.host = e.hostname);
        var s = e.pathname;
        if (!t.host && s && /^%2f/i.test(s)) {
            var o = s.split("/");
            t.host = decodeURIComponent(o[0]), s = o.splice(1).join("/");
        }
        switch(s && s.charAt(0) === "/" && (s = s.slice(1) || null), t.database = s && decodeURI(s), (t.ssl === "true" || t.ssl === "1") && (t.ssl = !0), t.ssl === "0" && (t.ssl = !1), (t.sslcert || t.sslkey || t.sslrootcert || t.sslmode) && (t.ssl = {}), t.sslcert && (t.ssl.cert = Ir.readFileSync(t.sslcert).toString()), t.sslkey && (t.ssl.key = Ir.readFileSync(t.sslkey).toString()), t.sslrootcert && (t.ssl.ca = Ir.readFileSync(t.sslrootcert).toString()), t.sslmode){
            case "disable":
                {
                    t.ssl = !1;
                    break;
                }
            case "prefer":
            case "require":
            case "verify-ca":
            case "verify-full":
                break;
            case "no-verify":
                {
                    t.ssl.rejectUnauthorized = !1;
                    break;
                }
        }
        return t;
    }
    a(Tr, "parse");
    Ts.exports = Tr;
    Tr.parse = Tr;
});
var Bt = T((Ah, Ls)=>{
    "use strict";
    p();
    var fc = (Is(), O(_s)), Rs = tt(), Bs = Ps().parse, H = a(function(r, e, t) {
        return t === void 0 ? t = m.env["PG" + r.toUpperCase()] : t === !1 || (t = m.env[t]), e[r] || t || Rs[r];
    }, "val"), hc = a(function() {
        switch(m.env.PGSSLMODE){
            case "disable":
                return !1;
            case "prefer":
            case "require":
            case "verify-ca":
            case "verify-full":
                return !0;
            case "\
no-verify":
                return {
                    rejectUnauthorized: !1
                };
        }
        return Rs.ssl;
    }, "readSSLConfigFromEnvironment"), Oe = a(function(r) {
        return "'" + ("" + r).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
    }, "quoteParamValue"), ne = a(function(r, e, t) {
        var n = e[t];
        n != null && r.push(t + "=" + Oe(n));
    }, "add"), Br = class Br {
        constructor(e){
            e = typeof e == "string" ? Bs(e) : e || {}, e.connectionString && (e = Object.assign({}, e, Bs(e.connectionString))), this.user = H("user", e), this.database = H("database", e), this.database === void 0 && (this.database = this.user), this.port = parseInt(H("por\
t", e), 10), this.host = H("host", e), Object.defineProperty(this, "password", {
                configurable: !0,
                enumerable: !1,
                writable: !0,
                value: H("password", e)
            }), this.binary = H("binary", e), this.options = H("options", e), this.ssl = typeof e.ssl > "u" ? hc() : e.ssl, typeof this.ssl == "string" && this.ssl === "true" && (this.ssl = !0), this.ssl === "no-verify" && (this.ssl = {
                rejectUnauthorized: !1
            }), this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", {
                enumerable: !1
            }), this.client_encoding = H("client_encoding", e), this.replication = H("replication", e), this.isDomainSocket = !(this.host || "").indexOf("/"), this.application_name = H("application_name", e, "PGAPPNAME"), this.fallback_application_name = H("fallback_application_name", e, !1), this.statement_timeout = H("statement_timeout", e, !1), this.lock_timeout = H("lock_timeout", e, !1), this.idle_in_transaction_session_timeout = H("idle_in_transaction_session_timeo\
ut", e, !1), this.query_timeout = H("query_timeout", e, !1), e.connectionTimeoutMillis === void 0 ? this.connect_timeout = m.env.PGCONNECT_TIMEOUT || 0 : this.connect_timeout = Math.floor(e.connectionTimeoutMillis / 1e3), e.keepAlive === !1 ? this.keepalives = 0 : e.keepAlive === !0 && (this.keepalives = 1), typeof e.keepAliveInitialDelayMillis == "nu\
mber" && (this.keepalives_idle = Math.floor(e.keepAliveInitialDelayMillis / 1e3));
        }
        getLibpqConnectionString(e) {
            var t = [];
            ne(t, this, "user"), ne(t, this, "password"), ne(t, this, "port"), ne(t, this, "application_name"), ne(t, this, "fallback_application_name"), ne(t, this, "connect_timeout"), ne(t, this, "options");
            var n = typeof this.ssl == "object" ? this.ssl : this.ssl ? {
                sslmode: this.ssl
            } : {};
            if (ne(t, n, "sslmode"), ne(t, n, "sslca"), ne(t, n, "s\
slkey"), ne(t, n, "sslcert"), ne(t, n, "sslrootcert"), this.database && t.push("dbname=" + Oe(this.database)), this.replication && t.push("replication=" + Oe(this.replication)), this.host && t.push("host=" + Oe(this.host)), this.isDomainSocket) return e(null, t.join(" "));
            this.client_encoding && t.push("client_encoding=" + Oe(this.client_encoding)), fc.lookup(this.host, function(i, s) {
                return i ? e(i, null) : (t.push("hostaddr=" + Oe(s)), e(null, t.join(" ")));
            });
        }
    };
    a(Br, "ConnectionParameters");
    var Pr = Br;
    Ls.exports = Pr;
});
var Ms = T((Ih, ks)=>{
    "use strict";
    p();
    var pc = Je(), Fs = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/, Lr = class Lr {
        constructor(e, t){
            this.command = null, this.rowCount = null, this.oid = null, this.rows = [], this.fields = [], this._parsers = void 0, this._types = t, this.RowCtor = null, this.rowAsArray = e === "array", this.rowAsArray && (this.parseRow = this._parseRowAsArray);
        }
        addCommandComplete(e) {
            var t;
            e.text ? t = Fs.exec(e.text) : t = Fs.exec(e.command), t && (this.command = t[1], t[3] ? (this.oid = parseInt(t[2], 10), this.rowCount = parseInt(t[3], 10)) : t[2] && (this.rowCount = parseInt(t[2], 10)));
        }
        _parseRowAsArray(e) {
            for(var t = new Array(e.length), n = 0, i = e.length; n < i; n++){
                var s = e[n];
                s !== null ? t[n] = this._parsers[n](s) : t[n] = null;
            }
            return t;
        }
        parseRow(e) {
            for(var t = {}, n = 0, i = e.length; n < i; n++){
                var s = e[n], o = this.fields[n].name;
                s !== null ? t[o] = this._parsers[n](s) : t[o] = null;
            }
            return t;
        }
        addRow(e) {
            this.rows.push(e);
        }
        addFields(e) {
            this.fields = e, this.fields.length && (this._parsers = new Array(e.length));
            for(var t = 0; t < e.length; t++){
                var n = e[t];
                this._types ? this._parsers[t] = this._types.getTypeParser(n.dataTypeID, n.format || "text") : this._parsers[t] = pc.getTypeParser(n.dataTypeID, n.format || "text");
            }
        }
    };
    a(Lr, "Result");
    var Rr = Lr;
    ks.exports = Rr;
});
var qs = T((Bh, Os)=>{
    "use strict";
    p();
    var { EventEmitter: dc } = ge(), Us = Ms(), Ds = rt(), kr = class kr extends dc {
        constructor(e, t, n){
            super(), e = Ds.normalizeQueryConfig(e, t, n), this.text = e.text, this.values = e.values, this.rows = e.rows, this.types = e.types, this.name = e.name, this.binary = e.binary, this.portal = e.portal || "", this.callback = e.callback, this._rowMode = e.rowMode, m.domain && e.callback && (this.callback = m.domain.bind(e.callback)), this._result = new Us(this._rowMode, this.types), this._results = this._result, this.isPreparedStatement = !1, this._canceledDueToError = !1, this._promise = null;
        }
        requiresPreparation() {
            return this.name || this.rows ? !0 : !this.text || !this.values ? !1 : this.values.length > 0;
        }
        _checkForMultirow() {
            this._result.command && (Array.isArray(this._results) || (this._results = [
                this._result
            ]), this._result = new Us(this._rowMode, this.types), this._results.push(this._result));
        }
        handleRowDescription(e) {
            this._checkForMultirow(), this._result.addFields(e.fields), this._accumulateRows = this.callback || !this.listeners("row").length;
        }
        handleDataRow(e) {
            let t;
            if (!this._canceledDueToError) {
                try {
                    t = this._result.parseRow(e.fields);
                } catch (n) {
                    this._canceledDueToError = n;
                    return;
                }
                this.emit("row", t, this._result), this._accumulateRows && this._result.addRow(t);
            }
        }
        handleCommandComplete(e, t) {
            this._checkForMultirow(), this._result.addCommandComplete(e), this.rows && t.sync();
        }
        handleEmptyQuery(e) {
            this.rows && e.sync();
        }
        handleError(e, t) {
            if (this._canceledDueToError && (e = this._canceledDueToError, this._canceledDueToError = !1), this.callback) return this.callback(e);
            this.emit("error", e);
        }
        handleReadyForQuery(e) {
            if (this._canceledDueToError) return this.handleError(this._canceledDueToError, e);
            if (this.callback) try {
                this.callback(null, this._results);
            } catch (t) {
                m.nextTick(()=>{
                    throw t;
                });
            }
            this.emit("end", this._results);
        }
        submit(e) {
            if (typeof this.text != "string" && typeof this.name != "string") return new Error("A query must have either text or a name. Supplying neither is unsupported.");
            let t = e.parsedStatements[this.name];
            return this.text && t && this.text !== t ? new Error(`Prepared statements must be unique - '${this.name}\
' was used for a different statement`) : this.values && !Array.isArray(this.values) ? new Error("Query val\
ues must be an array") : (this.requiresPreparation() ? this.prepare(e) : e.query(this.text), null);
        }
        hasBeenParsed(e) {
            return this.name && e.parsedStatements[this.name];
        }
        handlePortalSuspended(e) {
            this._getRows(e, this.rows);
        }
        _getRows(e, t) {
            e.execute({
                portal: this.portal,
                rows: t
            }), t ? e.flush() : e.sync();
        }
        prepare(e) {
            this.isPreparedStatement = !0, this.hasBeenParsed(e) || e.parse({
                text: this.text,
                name: this.name,
                types: this.types
            });
            try {
                e.bind({
                    portal: this.portal,
                    statement: this.name,
                    values: this.values,
                    binary: this.binary,
                    valueMapper: Ds.prepareValue
                });
            } catch (t) {
                this.handleError(t, e);
                return;
            }
            e.describe({
                type: "P",
                name: this.portal || ""
            }), this._getRows(e, this.rows);
        }
        handleCopyInResponse(e) {
            e.sendCopyFail("No source stream defined");
        }
        handleCopyData(e, t) {}
    };
    a(kr, "Query");
    var Fr = kr;
    Os.exports = Fr;
});
var ln = T((_)=>{
    "use strict";
    p();
    Object.defineProperty(_, "__esModule", {
        value: !0
    });
    _.NoticeMessage = _.DataRowMessage = _.CommandCompleteMessage = _.ReadyForQueryMessage = _.NotificationResponseMessage = _.BackendKeyDataMessage = _.AuthenticationMD5Password = _.ParameterStatusMessage = _.ParameterDescriptionMessage = _.RowDescriptionMessage = _.Field = _.CopyResponse = _.CopyDataMessage = _.DatabaseError = _.copyDone = _.emptyQuery = _.replicationStart = _.portalSuspended = _.noData = _.closeComplete = _.bindComplete = _.parseComplete = void 0;
    _.parseComplete = {
        name: "\
parseComplete",
        length: 5
    };
    _.bindComplete = {
        name: "bindComplete",
        length: 5
    };
    _.closeComplete = {
        name: "closeC\
omplete",
        length: 5
    };
    _.noData = {
        name: "noData",
        length: 5
    };
    _.portalSuspended = {
        name: "portalSuspended",
        length: 5
    };
    _.replicationStart = {
        name: "replicationStart",
        length: 4
    };
    _.emptyQuery = {
        name: "emptyQuery",
        length: 4
    };
    _.copyDone = {
        name: "copyDone",
        length: 4
    };
    var Kr = class Kr extends Error {
        constructor(e, t, n){
            super(e), this.length = t, this.name = n;
        }
    };
    a(Kr, "DatabaseError");
    var Mr = Kr;
    _.DatabaseError = Mr;
    var Yr = class Yr {
        constructor(e, t){
            this.length = e, this.chunk = t, this.name = "copyData";
        }
    };
    a(Yr, "CopyDataMessage");
    var Ur = Yr;
    _.CopyDataMessage = Ur;
    var Zr = class Zr {
        constructor(e, t, n, i){
            this.length = e, this.name = t, this.binary = n, this.columnTypes = new Array(i);
        }
    };
    a(Zr, "CopyResponse");
    var Dr = Zr;
    _.CopyResponse = Dr;
    var Jr = class Jr {
        constructor(e, t, n, i, s, o, u){
            this.name = e, this.tableID = t, this.columnID = n, this.dataTypeID = i, this.dataTypeSize = s, this.dataTypeModifier = o, this.format = u;
        }
    };
    a(Jr, "Field");
    var Or = Jr;
    _.Field = Or;
    var Xr = class Xr {
        constructor(e, t){
            this.length = e, this.fieldCount = t, this.name = "rowDescriptio\
n", this.fields = new Array(this.fieldCount);
        }
    };
    a(Xr, "RowDescriptionMessage");
    var qr = Xr;
    _.RowDescriptionMessage = qr;
    var en = class en {
        constructor(e, t){
            this.length = e, this.parameterCount = t, this.name = "parameterDescript\
ion", this.dataTypeIDs = new Array(this.parameterCount);
        }
    };
    a(en, "ParameterDescriptionMessage");
    var Qr = en;
    _.ParameterDescriptionMessage = Qr;
    var tn = class tn {
        constructor(e, t, n){
            this.length = e, this.parameterName = t, this.parameterValue = n, this.name = "parameterStatus";
        }
    };
    a(tn, "ParameterStatusMessage");
    var Nr = tn;
    _.ParameterStatusMessage = Nr;
    var rn = class rn {
        constructor(e, t){
            this.length = e, this.salt = t, this.name = "authenticationMD5Password";
        }
    };
    a(rn, "AuthenticationMD5Password");
    var Wr = rn;
    _.AuthenticationMD5Password = Wr;
    var nn = class nn {
        constructor(e, t, n){
            this.length = e, this.processID = t, this.secretKey = n, this.name = "backendKeyData";
        }
    };
    a(nn, "BackendKeyDataMes\
sage");
    var jr = nn;
    _.BackendKeyDataMessage = jr;
    var sn = class sn {
        constructor(e, t, n, i){
            this.length = e, this.processId = t, this.channel = n, this.payload = i, this.name = "notification";
        }
    };
    a(sn, "NotificationResponseMessa\
ge");
    var Hr = sn;
    _.NotificationResponseMessage = Hr;
    var on = class on {
        constructor(e, t){
            this.length = e, this.status = t, this.name = "readyForQuery";
        }
    };
    a(on, "ReadyForQueryMessage");
    var $r = on;
    _.ReadyForQueryMessage = $r;
    var an = class an {
        constructor(e, t){
            this.length = e, this.text = t, this.name = "commandComplete";
        }
    };
    a(an, "Comma\
ndCompleteMessage");
    var Gr = an;
    _.CommandCompleteMessage = Gr;
    var un = class un {
        constructor(e, t){
            this.length = e, this.fields = t, this.name = "dataRow", this.fieldCount = t.length;
        }
    };
    a(un, "DataRowMessage");
    var Vr = un;
    _.DataRowMessage = Vr;
    var cn = class cn {
        constructor(e, t){
            this.length = e, this.message = t, this.name = "notice";
        }
    };
    a(cn, "NoticeMe\
ssage");
    var zr = cn;
    _.NoticeMessage = zr;
});
var Qs = T((Rt)=>{
    "use strict";
    p();
    Object.defineProperty(Rt, "__esModule", {
        value: !0
    });
    Rt.Writer = void 0;
    var hn = class hn {
        constructor(e = 256){
            this.size = e, this.offset = 5, this.headerPosition = 0, this.buffer = d.allocUnsafe(e);
        }
        ensure(e) {
            if (this.buffer.length - this.offset < e) {
                let n = this.buffer, i = n.length + (n.length >> 1) + e;
                this.buffer = d.allocUnsafe(i), n.copy(this.buffer);
            }
        }
        addInt32(e) {
            return this.ensure(4), this.buffer[this.offset++] = e >>> 24 & 255, this.buffer[this.offset++] = e >>> 16 & 255, this.buffer[this.offset++] = e >>> 8 & 255, this.buffer[this.offset++] = e >>> 0 & 255, this;
        }
        addInt16(e) {
            return this.ensure(2), this.buffer[this.offset++] = e >>> 8 & 255, this.buffer[this.offset++] = e >>> 0 & 255, this;
        }
        addCString(e) {
            if (!e) this.ensure(1);
            else {
                let t = d.byteLength(e);
                this.ensure(t + 1), this.buffer.write(e, this.offset, "ut\
f-8"), this.offset += t;
            }
            return this.buffer[this.offset++] = 0, this;
        }
        addString(e = "") {
            let t = d.byteLength(e);
            return this.ensure(t), this.buffer.write(e, this.offset), this.offset += t, this;
        }
        add(e) {
            return this.ensure(e.length), e.copy(this.buffer, this.offset), this.offset += e.length, this;
        }
        join(e) {
            if (e) {
                this.buffer[this.headerPosition] = e;
                let t = this.offset - (this.headerPosition + 1);
                this.buffer.writeInt32BE(t, this.headerPosition + 1);
            }
            return this.buffer.slice(e ? 0 : 5, this.offset);
        }
        flush(e) {
            let t = this.join(e);
            return this.offset = 5, this.headerPosition = 0, this.buffer = d.allocUnsafe(this.size), t;
        }
    };
    a(hn, "Writer");
    var fn = hn;
    Rt.Writer = fn;
});
var Ws = T((Ft)=>{
    "use strict";
    p();
    Object.defineProperty(Ft, "__esModule", {
        value: !0
    });
    Ft.serialize = void 0;
    var pn = Qs(), F = new pn.Writer, yc = a((r)=>{
        F.addInt16(3).addInt16(0);
        for (let n of Object.keys(r))F.addCString(n).addCString(r[n]);
        F.addCString("client_encoding").addCString("UTF8");
        let e = F.addCString("").flush(), t = e.length + 4;
        return new pn.Writer().addInt32(t).add(e).flush();
    }, "startup"), mc = a(()=>{
        let r = d.allocUnsafe(8);
        return r.writeInt32BE(8, 0), r.writeInt32BE(80877103, 4), r;
    }, "requestSsl"), wc = a((r)=>F.addCString(r).flush(112), "password"), gc = a(function(r, e) {
        return F.addCString(r).addInt32(d.byteLength(e)).addString(e), F.flush(112);
    }, "sendSASLInitialResponseMessage"), bc = a(function(r) {
        return F.addString(r).flush(112);
    }, "se\
ndSCRAMClientFinalMessage"), vc = a((r)=>F.addCString(r).flush(81), "query"), Ns = [], xc = a((r)=>{
        let e = r.name || "";
        e.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", e, e.length), console.error("This can cause conflicts and silent errors e\
xecuting queries"));
        let t = r.types || Ns, n = t.length, i = F.addCString(e).addCString(r.text).addInt16(n);
        for(let s = 0; s < n; s++)i.addInt32(t[s]);
        return F.flush(80);
    }, "parse"), qe = new pn.Writer, Sc = a(function(r, e) {
        for(let t = 0; t < r.length; t++){
            let n = e ? e(r[t], t) : r[t];
            n == null ? (F.addInt16(0), qe.addInt32(-1)) : n instanceof d ? (F.addInt16(1), qe.addInt32(n.length), qe.add(n)) : (F.addInt16(0), qe.addInt32(d.byteLength(n)), qe.addString(n));
        }
    }, "\
writeValues"), Ec = a((r = {})=>{
        let e = r.portal || "", t = r.statement || "", n = r.binary || !1, i = r.values || Ns, s = i.length;
        return F.addCString(e).addCString(t), F.addInt16(s), Sc(i, r.valueMapper), F.addInt16(s), F.add(qe.flush()), F.addInt16(n ? 1 : 0), F.flush(66);
    }, "bind"), Ac = d.from([
        69,
        0,
        0,
        0,
        9,
        0,
        0,
        0,
        0,
        0
    ]), Cc = a((r)=>{
        if (!r || !r.portal && !r.rows) return Ac;
        let e = r.portal || "", t = r.rows || 0, n = d.byteLength(e), i = 4 + n + 1 + 4, s = d.allocUnsafe(1 + i);
        return s[0] = 69, s.writeInt32BE(i, 1), s.write(e, 5, "utf-8"), s[n + 5] = 0, s.writeUInt32BE(t, s.length - 4), s;
    }, "execute"), _c = a((r, e)=>{
        let t = d.allocUnsafe(16);
        return t.writeInt32BE(16, 0), t.writeInt16BE(1234, 4), t.writeInt16BE(5678, 6), t.writeInt32BE(r, 8), t.writeInt32BE(e, 12), t;
    }, "cancel"), dn = a((r, e)=>{
        let n = 4 + d.byteLength(e) + 1, i = d.allocUnsafe(1 + n);
        return i[0] = r, i.writeInt32BE(n, 1), i.write(e, 5, "utf-8"), i[n] = 0, i;
    }, "cstringMessage"), Ic = F.addCString("P").flush(68), Tc = F.addCString("S").flush(68), Pc = a((r)=>r.name ? dn(68, `${r.type}${r.name || ""}`) : r.type === "P" ? Ic : Tc, "describe"), Bc = a((r)=>{
        let e = `${r.type}${r.name || ""}`;
        return dn(67, e);
    }, "close"), Rc = a((r)=>F.add(r).flush(100), "copyData"), Lc = a((r)=>dn(102, r), "copyFail"), Lt = a((r)=>d.from([
            r,
            0,
            0,
            0,
            4
        ]), "c\
odeOnlyBuffer"), Fc = Lt(72), kc = Lt(83), Mc = Lt(88), Uc = Lt(99), Dc = {
        startup: yc,
        password: wc,
        requestSsl: mc,
        sendSASLInitialResponseMessage: gc,
        sendSCRAMClientFinalMessage: bc,
        query: vc,
        parse: xc,
        bind: Ec,
        execute: Cc,
        describe: Pc,
        close: Bc,
        flush: a(()=>Fc, "flush"),
        sync: a(()=>kc, "sync"),
        end: a(()=>Mc, "end"),
        copyData: Rc,
        copyDone: a(()=>Uc, "copyDone"),
        copyFail: Lc,
        cancel: _c
    };
    Ft.serialize = Dc;
});
var js = T((kt)=>{
    "use strict";
    p();
    Object.defineProperty(kt, "__esModule", {
        value: !0
    });
    kt.BufferReader = void 0;
    var Oc = d.allocUnsafe(0), mn = class mn {
        constructor(e = 0){
            this.offset = e, this.buffer = Oc, this.encoding = "utf\
-8";
        }
        setBuffer(e, t) {
            this.offset = e, this.buffer = t;
        }
        int16() {
            let e = this.buffer.readInt16BE(this.offset);
            return this.offset += 2, e;
        }
        byte() {
            let e = this.buffer[this.offset];
            return this.offset++, e;
        }
        int32() {
            let e = this.buffer.readInt32BE(this.offset);
            return this.offset += 4, e;
        }
        uint32() {
            let e = this.buffer.readUInt32BE(this.offset);
            return this.offset += 4, e;
        }
        string(e) {
            let t = this.buffer.toString(this.encoding, this.offset, this.offset + e);
            return this.offset += e, t;
        }
        cstring() {
            let e = this.offset, t = e;
            for(; this.buffer[t++] !== 0;);
            return this.offset = t, this.buffer.toString(this.encoding, e, t - 1);
        }
        bytes(e) {
            let t = this.buffer.slice(this.offset, this.offset + e);
            return this.offset += e, t;
        }
    };
    a(mn, "BufferReader");
    var yn = mn;
    kt.BufferReader = yn;
});
var Gs = T((Mt)=>{
    "use strict";
    p();
    Object.defineProperty(Mt, "__esModule", {
        value: !0
    });
    Mt.Parser = void 0;
    var k = ln(), qc = js(), wn = 1, Qc = 4, Hs = wn + Qc, $s = d.allocUnsafe(0), bn = class bn {
        constructor(e){
            if (this.buffer = $s, this.bufferLength = 0, this.bufferOffset = 0, this.reader = new qc.BufferReader, e?.mode === "binary") throw new Error("Binary mod\
e not supported yet");
            this.mode = e?.mode || "text";
        }
        parse(e, t) {
            this.mergeBuffer(e);
            let n = this.bufferOffset + this.bufferLength, i = this.bufferOffset;
            for(; i + Hs <= n;){
                let s = this.buffer[i], o = this.buffer.readUInt32BE(i + wn), u = wn + o;
                if (u + i <= n) {
                    let c = this.handlePacket(i + Hs, s, o, this.buffer);
                    t(c), i += u;
                } else break;
            }
            i === n ? (this.buffer = $s, this.bufferLength = 0, this.bufferOffset = 0) : (this.bufferLength = n - i, this.bufferOffset = i);
        }
        mergeBuffer(e) {
            if (this.bufferLength > 0) {
                let t = this.bufferLength + e.byteLength;
                if (t + this.bufferOffset > this.buffer.byteLength) {
                    let i;
                    if (t <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) i = this.buffer;
                    else {
                        let s = this.buffer.byteLength * 2;
                        for(; t >= s;)s *= 2;
                        i = d.allocUnsafe(s);
                    }
                    this.buffer.copy(i, 0, this.bufferOffset, this.bufferOffset + this.bufferLength), this.buffer = i, this.bufferOffset = 0;
                }
                e.copy(this.buffer, this.bufferOffset + this.bufferLength), this.bufferLength = t;
            } else this.buffer = e, this.bufferOffset = 0, this.bufferLength = e.byteLength;
        }
        handlePacket(e, t, n, i) {
            switch(t){
                case 50:
                    return k.bindComplete;
                case 49:
                    return k.parseComplete;
                case 51:
                    return k.closeComplete;
                case 110:
                    return k.noData;
                case 115:
                    return k.portalSuspended;
                case 99:
                    return k.copyDone;
                case 87:
                    return k.replicationStart;
                case 73:
                    return k.emptyQuery;
                case 68:
                    return this.parseDataRowMessage(e, n, i);
                case 67:
                    return this.parseCommandCompleteMessage(e, n, i);
                case 90:
                    return this.parseReadyForQueryMessage(e, n, i);
                case 65:
                    return this.parseNotificationMessage(e, n, i);
                case 82:
                    return this.parseAuthenticationResponse(e, n, i);
                case 83:
                    return this.parseParameterStatusMessage(e, n, i);
                case 75:
                    return this.parseBackendKeyData(e, n, i);
                case 69:
                    return this.parseErrorMessage(e, n, i, "e\
rror");
                case 78:
                    return this.parseErrorMessage(e, n, i, "notice");
                case 84:
                    return this.parseRowDescriptionMessage(e, n, i);
                case 116:
                    return this.parseParameterDescriptionMessage(e, n, i);
                case 71:
                    return this.parseCopyInMessage(e, n, i);
                case 72:
                    return this.parseCopyOutMessage(e, n, i);
                case 100:
                    return this.parseCopyData(e, n, i);
                default:
                    return new k.DatabaseError("received invalid response: " + t.toString(16), n, "error");
            }
        }
        parseReadyForQueryMessage(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.string(1);
            return new k.ReadyForQueryMessage(t, i);
        }
        parseCommandCompleteMessage(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.cstring();
            return new k.CommandCompleteMessage(t, i);
        }
        parseCopyData(e, t, n) {
            let i = n.slice(e, e + (t - 4));
            return new k.CopyDataMessage(t, i);
        }
        parseCopyInMessage(e, t, n) {
            return this.parseCopyMessage(e, t, n, "copyInResponse");
        }
        parseCopyOutMessage(e, t, n) {
            return this.parseCopyMessage(e, t, n, "copyOutRespon\
se");
        }
        parseCopyMessage(e, t, n, i) {
            this.reader.setBuffer(e, n);
            let s = this.reader.byte() !== 0, o = this.reader.int16(), u = new k.CopyResponse(t, i, s, o);
            for(let c = 0; c < o; c++)u.columnTypes[c] = this.reader.int16();
            return u;
        }
        parseNotificationMessage(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.int32(), s = this.reader.cstring(), o = this.reader.cstring();
            return new k.NotificationResponseMessage(t, i, s, o);
        }
        parseRowDescriptionMessage(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.int16(), s = new k.RowDescriptionMessage(t, i);
            for(let o = 0; o < i; o++)s.fields[o] = this.parseField();
            return s;
        }
        parseField() {
            let e = this.reader.cstring(), t = this.reader.uint32(), n = this.reader.int16(), i = this.reader.uint32(), s = this.reader.int16(), o = this.reader.int32(), u = this.reader.int16() === 0 ? "text" : "binary";
            return new k.Field(e, t, n, i, s, o, u);
        }
        parseParameterDescriptionMessage(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.int16(), s = new k.ParameterDescriptionMessage(t, i);
            for(let o = 0; o < i; o++)s.dataTypeIDs[o] = this.reader.int32();
            return s;
        }
        parseDataRowMessage(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.int16(), s = new Array(i);
            for(let o = 0; o < i; o++){
                let u = this.reader.int32();
                s[o] = u === -1 ? null : this.reader.string(u);
            }
            return new k.DataRowMessage(t, s);
        }
        parseParameterStatusMessage(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.cstring(), s = this.reader.cstring();
            return new k.ParameterStatusMessage(t, i, s);
        }
        parseBackendKeyData(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.int32(), s = this.reader.int32();
            return new k.BackendKeyDataMessage(t, i, s);
        }
        parseAuthenticationResponse(e, t, n) {
            this.reader.setBuffer(e, n);
            let i = this.reader.int32(), s = {
                name: "authenticationOk",
                length: t
            };
            switch(i){
                case 0:
                    break;
                case 3:
                    s.length === 8 && (s.name = "authenticationCleartextPassword");
                    break;
                case 5:
                    if (s.length === 12) {
                        s.name = "authen\
ticationMD5Password";
                        let o = this.reader.bytes(4);
                        return new k.AuthenticationMD5Password(t, o);
                    }
                    break;
                case 10:
                    {
                        s.name = "authenticationSASL", s.mechanisms = [];
                        let o;
                        do o = this.reader.cstring(), o && s.mechanisms.push(o);
                        while (o)
                    }
                    break;
                case 11:
                    s.name = "authenticationSASLContinue", s.data = this.reader.string(t - 8);
                    break;
                case 12:
                    s.name = "authenticationSASLFinal", s.data = this.reader.string(t - 8);
                    break;
                default:
                    throw new Error("Unknown auth\
enticationOk message type " + i);
            }
            return s;
        }
        parseErrorMessage(e, t, n, i) {
            this.reader.setBuffer(e, n);
            let s = {}, o = this.reader.string(1);
            for(; o !== "\0";)s[o] = this.reader.cstring(), o = this.reader.string(1);
            let u = s.M, c = i === "notice" ? new k.NoticeMessage(t, u) : new k.DatabaseError(u, t, i);
            return c.severity = s.S, c.code = s.C, c.detail = s.D, c.hint = s.H, c.position = s.P, c.internalPosition = s.p, c.internalQuery = s.q, c.where = s.W, c.schema = s.s, c.table = s.t, c.column = s.c, c.dataType = s.d, c.constraint = s.n, c.file = s.F, c.line = s.L, c.routine = s.R, c;
        }
    };
    a(bn, "Parser");
    var gn = bn;
    Mt.Parser = gn;
});
var vn = T((xe)=>{
    "use strict";
    p();
    Object.defineProperty(xe, "__esModule", {
        value: !0
    });
    xe.DatabaseError = xe.serialize = xe.parse = void 0;
    var Nc = ln();
    Object.defineProperty(xe, "DatabaseError", {
        enumerable: !0,
        get: a(function() {
            return Nc.DatabaseError;
        }, "get")
    });
    var Wc = Ws();
    Object.defineProperty(xe, "serialize", {
        enumerable: !0,
        get: a(function() {
            return Wc.serialize;
        }, "get")
    });
    var jc = Gs();
    function Hc(r, e) {
        let t = new jc.Parser;
        return r.on("data", (n)=>t.parse(n, e)), new Promise((n)=>r.on("end", ()=>n()));
    }
    a(Hc, "parse");
    xe.parse = Hc;
});
var Vs = {};
ie(Vs, {
    connect: ()=>$c
});
function $c({ socket: r, servername: e }) {
    return r.startTls(e), r;
}
var zs = G(()=>{
    "use strict";
    p();
    a($c, "connect");
});
var En = T((Xh, Zs)=>{
    "use strict";
    p();
    var Ks = (Fe(), O(wi)), Gc = ge().EventEmitter, { parse: Vc, serialize: Q } = vn(), Ys = Q.flush(), zc = Q.sync(), Kc = Q.end(), Sn = class Sn extends Gc {
        constructor(e){
            super(), e = e || {}, this.stream = e.stream || new Ks.Socket, this._keepAlive = e.keepAlive, this._keepAliveInitialDelayMillis = e.keepAliveInitialDelayMillis, this.lastBuffer = !1, this.parsedStatements = {}, this.ssl = e.ssl || !1, this._ending = !1, this._emitMessage = !1;
            var t = this;
            this.on("newListener", function(n) {
                n === "message" && (t._emitMessage = !0);
            });
        }
        connect(e, t) {
            var n = this;
            this._connecting = !0, this.stream.setNoDelay(!0), this.stream.connect(e, t), this.stream.once("connect", function() {
                n._keepAlive && n.stream.setKeepAlive(!0, n._keepAliveInitialDelayMillis), n.emit("connect");
            });
            let i = a(function(s) {
                n._ending && (s.code === "ECONNRESET" || s.code === "EPIPE") || n.emit("error", s);
            }, "reportStreamError");
            if (this.stream.on("error", i), this.stream.on("close", function() {
                n.emit("end");
            }), !this.ssl) return this.attachListeners(this.stream);
            this.stream.once("data", function(s) {
                var o = s.toString("utf8");
                switch(o){
                    case "S":
                        break;
                    case "\
N":
                        return n.stream.end(), n.emit("error", new Error("The server does not support SSL connections"));
                    default:
                        return n.stream.end(), n.emit("error", new Error("There was an error establishing an SSL connection"));
                }
                var u = (zs(), O(Vs));
                let c = {
                    socket: n.stream
                };
                n.ssl !== !0 && (Object.assign(c, n.ssl), "key" in n.ssl && (c.key = n.ssl.key)), Ks.isIP(t) === 0 && (c.servername = t);
                try {
                    n.stream = u.connect(c);
                } catch (l) {
                    return n.emit("error", l);
                }
                n.attachListeners(n.stream), n.stream.on("error", i), n.emit("sslconnect");
            });
        }
        attachListeners(e) {
            e.on("end", ()=>{
                this.emit("end");
            }), Vc(e, (t)=>{
                var n = t.name === "error" ? "errorMessage" : t.name;
                this._emitMessage && this.emit("message", t), this.emit(n, t);
            });
        }
        requestSsl() {
            this.stream.write(Q.requestSsl());
        }
        startup(e) {
            this.stream.write(Q.startup(e));
        }
        cancel(e, t) {
            this._send(Q.cancel(e, t));
        }
        password(e) {
            this._send(Q.password(e));
        }
        sendSASLInitialResponseMessage(e, t) {
            this._send(Q.sendSASLInitialResponseMessage(e, t));
        }
        sendSCRAMClientFinalMessage(e) {
            this._send(Q.sendSCRAMClientFinalMessage(e));
        }
        _send(e) {
            return this.stream.writable ? this.stream.write(e) : !1;
        }
        query(e) {
            this._send(Q.query(e));
        }
        parse(e) {
            this._send(Q.parse(e));
        }
        bind(e) {
            this._send(Q.bind(e));
        }
        execute(e) {
            this._send(Q.execute(e));
        }
        flush() {
            this.stream.writable && this.stream.write(Ys);
        }
        sync() {
            this._ending = !0, this._send(Ys), this._send(zc);
        }
        ref() {
            this.stream.ref();
        }
        unref() {
            this.stream.unref();
        }
        end() {
            if (this._ending = !0, !this._connecting || !this.stream.writable) {
                this.stream.end();
                return;
            }
            return this.stream.write(Kc, ()=>{
                this.stream.end();
            });
        }
        close(e) {
            this._send(Q.close(e));
        }
        describe(e) {
            this._send(Q.describe(e));
        }
        sendCopyFromChunk(e) {
            this._send(Q.copyData(e));
        }
        endCopyFrom() {
            this._send(Q.copyDone());
        }
        sendCopyFail(e) {
            this._send(Q.copyFail(e));
        }
    };
    a(Sn, "Connection");
    var xn = Sn;
    Zs.exports = xn;
});
var eo = T((np, Xs)=>{
    "use strict";
    p();
    var Yc = ge().EventEmitter, rp = (it(), O(nt)), Zc = rt(), An = ds(), Jc = Cs(), Xc = At(), el = Bt(), Js = qs(), tl = tt(), rl = En(), Cn = class Cn extends Yc {
        constructor(e){
            super(), this.connectionParameters = new el(e), this.user = this.connectionParameters.user, this.database = this.connectionParameters.database, this.port = this.connectionParameters.port, this.host = this.connectionParameters.host, Object.defineProperty(this, "password", {
                configurable: !0,
                enumerable: !1,
                writable: !0,
                value: this.connectionParameters.password
            }), this.replication = this.connectionParameters.replication;
            var t = e || {};
            this._Promise = t.Promise || b.Promise, this._types = new Xc(t.types), this._ending = !1, this._connecting = !1, this._connected = !1, this._connectionError = !1, this._queryable = !0, this.connection = t.connection || new rl({
                stream: t.stream,
                ssl: this.connectionParameters.ssl,
                keepAlive: t.keepAlive || !1,
                keepAliveInitialDelayMillis: t.keepAliveInitialDelayMillis || 0,
                encoding: this.connectionParameters.client_encoding || "utf8"
            }), this.queryQueue = [], this.binary = t.binary || tl.binary, this.processID = null, this.secretKey = null, this.ssl = this.connectionParameters.ssl || !1, this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", {
                enumerable: !1
            }), this._connectionTimeoutMillis = t.connectionTimeoutMillis || 0;
        }
        _errorAllQueries(e) {
            let t = a((n)=>{
                m.nextTick(()=>{
                    n.handleError(e, this.connection);
                });
            }, "enqueueError");
            this.activeQuery && (t(this.activeQuery), this.activeQuery = null), this.queryQueue.forEach(t), this.queryQueue.length = 0;
        }
        _connect(e) {
            var t = this, n = this.connection;
            if (this._connectionCallback = e, this._connecting || this._connected) {
                let i = new Error("Client has already been connected. You cannot reuse a client.");
                m.nextTick(()=>{
                    e(i);
                });
                return;
            }
            this._connecting = !0, this.connectionTimeoutHandle, this._connectionTimeoutMillis > 0 && (this.connectionTimeoutHandle = setTimeout(()=>{
                n._ending = !0, n.stream.destroy(new Error("timeout expir\
ed"));
            }, this._connectionTimeoutMillis)), this.host && this.host.indexOf("/") === 0 ? n.connect(this.host + "/.\
s.PGSQL." + this.port) : n.connect(this.port, this.host), n.on("connect", function() {
                t.ssl ? n.requestSsl() : n.startup(t.getStartupConf());
            }), n.on("sslconnect", function() {
                n.startup(t.getStartupConf());
            }), this._attachListeners(n), n.once("end", ()=>{
                let i = this._ending ? new Error("Connection terminated") : new Error("Connection ter\
minated unexpectedly");
                clearTimeout(this.connectionTimeoutHandle), this._errorAllQueries(i), this._ending || (this._connecting && !this._connectionError ? this._connectionCallback ? this._connectionCallback(i) : this._handleErrorEvent(i) : this._connectionError || this._handleErrorEvent(i)), m.nextTick(()=>{
                    this.emit("en\
d");
                });
            });
        }
        connect(e) {
            if (e) {
                this._connect(e);
                return;
            }
            return new this._Promise((t, n)=>{
                this._connect((i)=>{
                    i ? n(i) : t();
                });
            });
        }
        _attachListeners(e) {
            e.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this)), e.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this)), e.on("authentic\
ationSASL", this._handleAuthSASL.bind(this)), e.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this)), e.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this)), e.on("backendKeyDat\
a", this._handleBackendKeyData.bind(this)), e.on("error", this._handleErrorEvent.bind(this)), e.on("erro\
rMessage", this._handleErrorMessage.bind(this)), e.on("readyForQuery", this._handleReadyForQuery.bind(this)), e.on("notice", this._handleNotice.bind(this)), e.on("rowDescription", this._handleRowDescription.bind(this)), e.on("dataRow", this._handleDataRow.bind(this)), e.on("portalSuspended", this._handlePortalSuspended.bind(this)), e.on("emptyQuery", this._handleEmptyQuery.bind(this)), e.on("commandComplete", this._handleCommandComplete.bind(this)), e.on("parseComplete", this._handleParseComplete.bind(this)), e.on("copyInResponse", this._handleCopyInResponse.bind(this)), e.on("copyData", this._handleCopyData.bind(this)), e.on("notification", this._handleNotification.bind(this));
        }
        _checkPgPass(e) {
            let t = this.connection;
            typeof this.password == "function" ? this._Promise.resolve().then(()=>this.password()).then((n)=>{
                if (n !== void 0) {
                    if (typeof n != "string") {
                        t.emit("error", new TypeError("Password must be a string"));
                        return;
                    }
                    this.connectionParameters.password = this.password = n;
                } else this.connectionParameters.password = this.password = null;
                e();
            }).catch((n)=>{
                t.emit("error", n);
            }) : this.password !== null ? e() : Jc(this.connectionParameters, (n)=>{
                n !== void 0 && (this.connectionParameters.password = this.password = n), e();
            });
        }
        _handleAuthCleartextPassword(e) {
            this._checkPgPass(()=>{
                this.connection.password(this.password);
            });
        }
        _handleAuthMD5Password(e) {
            this._checkPgPass(()=>{
                let t = Zc.postgresMd5PasswordHash(this.user, this.password, e.salt);
                this.connection.password(t);
            });
        }
        _handleAuthSASL(e) {
            this._checkPgPass(()=>{
                this.saslSession = An.startSession(e.mechanisms), this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
            });
        }
        _handleAuthSASLContinue(e) {
            An.continueSession(this.saslSession, this.password, e.data), this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
        }
        _handleAuthSASLFinal(e) {
            An.finalizeSession(this.saslSession, e.data), this.saslSession = null;
        }
        _handleBackendKeyData(e) {
            this.processID = e.processID, this.secretKey = e.secretKey;
        }
        _handleReadyForQuery(e) {
            this._connecting && (this._connecting = !1, this._connected = !0, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback && (this._connectionCallback(null, this), this._connectionCallback = null), this.emit("connect"));
            let { activeQuery: t } = this;
            this.activeQuery = null, this.readyForQuery = !0, t && t.handleReadyForQuery(this.connection), this._pulseQueryQueue();
        }
        _handleErrorWhileConnecting(e) {
            if (!this._connectionError) {
                if (this._connectionError = !0, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback) return this._connectionCallback(e);
                this.emit("error", e);
            }
        }
        _handleErrorEvent(e) {
            if (this._connecting) return this._handleErrorWhileConnecting(e);
            this._queryable = !1, this._errorAllQueries(e), this.emit("error", e);
        }
        _handleErrorMessage(e) {
            if (this._connecting) return this._handleErrorWhileConnecting(e);
            let t = this.activeQuery;
            if (!t) {
                this._handleErrorEvent(e);
                return;
            }
            this.activeQuery = null, t.handleError(e, this.connection);
        }
        _handleRowDescription(e) {
            this.activeQuery.handleRowDescription(e);
        }
        _handleDataRow(e) {
            this.activeQuery.handleDataRow(e);
        }
        _handlePortalSuspended(e) {
            this.activeQuery.handlePortalSuspended(this.connection);
        }
        _handleEmptyQuery(e) {
            this.activeQuery.handleEmptyQuery(this.connection);
        }
        _handleCommandComplete(e) {
            this.activeQuery.handleCommandComplete(e, this.connection);
        }
        _handleParseComplete(e) {
            this.activeQuery.name && (this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text);
        }
        _handleCopyInResponse(e) {
            this.activeQuery.handleCopyInResponse(this.connection);
        }
        _handleCopyData(e) {
            this.activeQuery.handleCopyData(e, this.connection);
        }
        _handleNotification(e) {
            this.emit("notification", e);
        }
        _handleNotice(e) {
            this.emit("no\
tice", e);
        }
        getStartupConf() {
            var e = this.connectionParameters, t = {
                user: e.user,
                database: e.database
            }, n = e.application_name || e.fallback_application_name;
            return n && (t.application_name = n), e.replication && (t.replication = "" + e.replication), e.statement_timeout && (t.statement_timeout = String(parseInt(e.statement_timeout, 10))), e.lock_timeout && (t.lock_timeout = String(parseInt(e.lock_timeout, 10))), e.idle_in_transaction_session_timeout && (t.idle_in_transaction_session_timeout = String(parseInt(e.idle_in_transaction_session_timeout, 10))), e.options && (t.options = e.options), t;
        }
        cancel(e, t) {
            if (e.activeQuery === t) {
                var n = this.connection;
                this.host && this.host.indexOf("/") === 0 ? n.connect(this.host + "/.s.PGSQL." + this.port) : n.connect(this.port, this.host), n.on("connect", function() {
                    n.cancel(e.processID, e.secretKey);
                });
            } else e.queryQueue.indexOf(t) !== -1 && e.queryQueue.splice(e.queryQueue.indexOf(t), 1);
        }
        setTypeParser(e, t, n) {
            return this._types.setTypeParser(e, t, n);
        }
        getTypeParser(e, t) {
            return this._types.getTypeParser(e, t);
        }
        escapeIdentifier(e) {
            return '"' + e.replace(/"/g, '""') + '"';
        }
        escapeLiteral(e) {
            for(var t = !1, n = "'", i = 0; i < e.length; i++){
                var s = e[i];
                s === "'" ? n += s + s : s === "\\" ? (n += s + s, t = !0) : n += s;
            }
            return n += "'", t === !0 && (n = " E" + n), n;
        }
        _pulseQueryQueue() {
            if (this.readyForQuery === !0) if (this.activeQuery = this.queryQueue.shift(), this.activeQuery) {
                this.readyForQuery = !1, this.hasExecuted = !0;
                let e = this.activeQuery.submit(this.connection);
                e && m.nextTick(()=>{
                    this.activeQuery.handleError(e, this.connection), this.readyForQuery = !0, this._pulseQueryQueue();
                });
            } else this.hasExecuted && (this.activeQuery = null, this.emit("drain"));
        }
        query(e, t, n) {
            var i, s, o, u, c;
            if (e == null) throw new TypeError("Client was passed a null or undefined query");
            return typeof e.submit == "function" ? (o = e.query_timeout || this.connectionParameters.query_timeout, s = i = e, typeof t == "function" && (i.callback = i.callback || t)) : (o = this.connectionParameters.query_timeout, i = new Js(e, t, n), i.callback || (s = new this._Promise((l, f)=>{
                i.callback = (y, g)=>y ? f(y) : l(g);
            }))), o && (c = i.callback, u = setTimeout(()=>{
                var l = new Error("Query read timeout");
                m.nextTick(()=>{
                    i.handleError(l, this.connection);
                }), c(l), i.callback = ()=>{};
                var f = this.queryQueue.indexOf(i);
                f > -1 && this.queryQueue.splice(f, 1), this._pulseQueryQueue();
            }, o), i.callback = (l, f)=>{
                clearTimeout(u), c(l, f);
            }), this.binary && !i.binary && (i.binary = !0), i._result && !i._result._types && (i._result._types = this._types), this._queryable ? this._ending ? (m.nextTick(()=>{
                i.handleError(new Error("Client was closed and is not query\
able"), this.connection);
            }), s) : (this.queryQueue.push(i), this._pulseQueryQueue(), s) : (m.nextTick(()=>{
                i.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
            }), s);
        }
        ref() {
            this.connection.ref();
        }
        unref() {
            this.connection.unref();
        }
        end(e) {
            if (this._ending = !0, !this.connection._connecting) if (e) e();
            else return this._Promise.resolve();
            if (this.activeQuery || !this._queryable ? this.connection.stream.destroy() : this.connection.end(), e) this.connection.once("end", e);
            else return new this._Promise((t)=>{
                this.connection.once("end", t);
            });
        }
    };
    a(Cn, "Client");
    var Ut = Cn;
    Ut.Query = Js;
    Xs.exports = Ut;
});
var io = T((op, no)=>{
    "use strict";
    p();
    var nl = ge().EventEmitter, to = a(function() {}, "NOOP"), ro = a((r, e)=>{
        let t = r.findIndex(e);
        return t === -1 ? void 0 : r.splice(t, 1)[0];
    }, "removeWhere"), Tn = class Tn {
        constructor(e, t, n){
            this.client = e, this.idleListener = t, this.timeoutId = n;
        }
    };
    a(Tn, "IdleItem");
    var _n = Tn, Pn = class Pn {
        constructor(e){
            this.callback = e;
        }
    };
    a(Pn, "PendingItem");
    var Qe = Pn;
    function il() {
        throw new Error("Release called on cli\
ent which has already been released to the pool.");
    }
    a(il, "throwOnDoubleRelease");
    function Dt(r, e) {
        if (e) return {
            callback: e,
            result: void 0
        };
        let t, n, i = a(function(o, u) {
            o ? t(o) : n(u);
        }, "cb"), s = new r(function(o, u) {
            n = o, t = u;
        }).catch((o)=>{
            throw Error.captureStackTrace(o), o;
        });
        return {
            callback: i,
            result: s
        };
    }
    a(Dt, "promisify");
    function sl(r, e) {
        return a(function t(n) {
            n.client = e, e.removeListener("error", t), e.on("error", ()=>{
                r.log("additional client error after disconnection due to error", n);
            }), r._remove(e), r.emit("error", n, e);
        }, "i\
dleListener");
    }
    a(sl, "makeIdleListener");
    var Bn = class Bn extends nl {
        constructor(e, t){
            super(), this.options = Object.assign({}, e), e != null && "password" in e && Object.defineProperty(this.options, "password", {
                configurable: !0,
                enumerable: !1,
                writable: !0,
                value: e.password
            }), e != null && e.ssl && e.ssl.key && Object.defineProperty(this.options.ssl, "key", {
                enumerable: !1
            }), this.options.max = this.options.max || this.options.poolSize || 10, this.options.min = this.options.min || 0, this.options.maxUses = this.options.maxUses || 1 / 0, this.options.allowExitOnIdle = this.options.allowExitOnIdle || !1, this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0, this.log = this.options.log || function() {}, this.Client = this.options.Client || t || ot().Client, this.Promise = this.options.Promise || b.Promise, typeof this.options.idleTimeoutMillis > "u" && (this.options.idleTimeoutMillis = 1e4), this._clients = [], this._idle = [], this._expired = new WeakSet, this._pendingQueue = [], this._endCallback = void 0, this.ending = !1, this.ended = !1;
        }
        _isFull() {
            return this._clients.length >= this.options.max;
        }
        _isAboveMin() {
            return this._clients.length > this.options.min;
        }
        _pulseQueue() {
            if (this.log("pulse queue"), this.ended) {
                this.log("pulse queue ended");
                return;
            }
            if (this.ending) {
                this.log("pulse queue on ending"), this._idle.length && this._idle.slice().map((t)=>{
                    this._remove(t.client);
                }), this._clients.length || (this.ended = !0, this._endCallback());
                return;
            }
            if (!this._pendingQueue.length) {
                this.log("no queued requests");
                return;
            }
            if (!this._idle.length && this._isFull()) return;
            let e = this._pendingQueue.shift();
            if (this._idle.length) {
                let t = this._idle.pop();
                clearTimeout(t.timeoutId);
                let n = t.client;
                n.ref && n.ref();
                let i = t.idleListener;
                return this._acquireClient(n, e, i, !1);
            }
            if (!this._isFull()) return this.newClient(e);
            throw new Error("unexpected condition");
        }
        _remove(e) {
            let t = ro(this._idle, (n)=>n.client === e);
            t !== void 0 && clearTimeout(t.timeoutId), this._clients = this._clients.filter((n)=>n !== e), e.end(), this.emit("remove", e);
        }
        connect(e) {
            if (this.ending) {
                let i = new Error("Cannot use a poo\
l after calling end on the pool");
                return e ? e(i) : this.Promise.reject(i);
            }
            let t = Dt(this.Promise, e), n = t.result;
            if (this._isFull() || this._idle.length) {
                if (this._idle.length && m.nextTick(()=>this._pulseQueue()), !this.options.connectionTimeoutMillis) return this._pendingQueue.push(new Qe(t.callback)), n;
                let i = a((u, c, l)=>{
                    clearTimeout(o), t.callback(u, c, l);
                }, "queueCallback"), s = new Qe(i), o = setTimeout(()=>{
                    ro(this._pendingQueue, (u)=>u.callback === i), s.timedOut = !0, t.callback(new Error("timeout exceeded when trying to connect"));
                }, this.options.connectionTimeoutMillis);
                return o.unref && o.unref(), this._pendingQueue.push(s), n;
            }
            return this.newClient(new Qe(t.callback)), n;
        }
        newClient(e) {
            let t = new this.Client(this.options);
            this._clients.push(t);
            let n = sl(this, t);
            this.log("checking client timeout");
            let i, s = !1;
            this.options.connectionTimeoutMillis && (i = setTimeout(()=>{
                this.log("ending client due to timeout"), s = !0, t.connection ? t.connection.stream.destroy() : t.end();
            }, this.options.connectionTimeoutMillis)), this.log("connecting new client"), t.connect((o)=>{
                if (i && clearTimeout(i), t.on("error", n), o) this.log("client failed to connect", o), this._clients = this._clients.filter((u)=>u !== t), s && (o = new Error("Connection terminated due to connection timeout", {
                    cause: o
                })), this._pulseQueue(), e.timedOut || e.callback(o, void 0, to);
                else {
                    if (this.log("new client connected"), this.options.maxLifetimeSeconds !== 0) {
                        let u = setTimeout(()=>{
                            this.log("ending client due to expired lifetime"), this._expired.add(t), this._idle.findIndex((l)=>l.client === t) !== -1 && this._acquireClient(t, new Qe((l, f, y)=>y()), n, !1);
                        }, this.options.maxLifetimeSeconds * 1e3);
                        u.unref(), t.once("end", ()=>clearTimeout(u));
                    }
                    return this._acquireClient(t, e, n, !0);
                }
            });
        }
        _acquireClient(e, t, n, i) {
            i && this.emit("connect", e), this.emit("acquire", e), e.release = this._releaseOnce(e, n), e.removeListener("error", n), t.timedOut ? i && this.options.verify ? this.options.verify(e, e.release) : e.release() : i && this.options.verify ? this.options.verify(e, (s)=>{
                if (s) return e.release(s), t.callback(s, void 0, to);
                t.callback(void 0, e, e.release);
            }) : t.callback(void 0, e, e.release);
        }
        _releaseOnce(e, t) {
            let n = !1;
            return (i)=>{
                n && il(), n = !0, this._release(e, t, i);
            };
        }
        _release(e, t, n) {
            if (e.on("error", t), e._poolUseCount = (e._poolUseCount || 0) + 1, this.emit("release", n, e), n || this.ending || !e._queryable || e._ending || e._poolUseCount >= this.options.maxUses) {
                e._poolUseCount >= this.options.maxUses && this.log("remove expended client"), this._remove(e), this._pulseQueue();
                return;
            }
            if (this._expired.has(e)) {
                this.log("remove expired client"), this._expired.delete(e), this._remove(e), this._pulseQueue();
                return;
            }
            let s;
            this.options.idleTimeoutMillis && this._isAboveMin() && (s = setTimeout(()=>{
                this.log("remove idle client"), this._remove(e);
            }, this.options.idleTimeoutMillis), this.options.allowExitOnIdle && s.unref()), this.options.allowExitOnIdle && e.unref(), this._idle.push(new _n(e, t, s)), this._pulseQueue();
        }
        query(e, t, n) {
            if (typeof e == "function") {
                let s = Dt(this.Promise, e);
                return v(function() {
                    return s.callback(new Error("Passing a function as the first parameter to pool.query is not supporte\
d"));
                }), s.result;
            }
            typeof t == "function" && (n = t, t = void 0);
            let i = Dt(this.Promise, n);
            return n = i.callback, this.connect((s, o)=>{
                if (s) return n(s);
                let u = !1, c = a((l)=>{
                    u || (u = !0, o.release(l), n(l));
                }, "onError");
                o.once("er\
ror", c), this.log("dispatching query");
                try {
                    o.query(e, t, (l, f)=>{
                        if (this.log("query dispatched"), o.removeListener("error", c), !u) return u = !0, o.release(l), l ? n(l) : n(void 0, f);
                    });
                } catch (l) {
                    return o.release(l), n(l);
                }
            }), i.result;
        }
        end(e) {
            if (this.log("ending"), this.ending) {
                let n = new Error("Called end on pool more than once");
                return e ? e(n) : this.Promise.reject(n);
            }
            this.ending = !0;
            let t = Dt(this.Promise, e);
            return this._endCallback = t.callback, this._pulseQueue(), t.result;
        }
        get waitingCount() {
            return this._pendingQueue.length;
        }
        get idleCount() {
            return this._idle.length;
        }
        get expiredCount() {
            return this._clients.reduce((e, t)=>e + (this._expired.has(t) ? 1 : 0), 0);
        }
        get totalCount() {
            return this._clients.length;
        }
    };
    a(Bn, "Pool");
    var In = Bn;
    no.exports = In;
});
var so = {};
ie(so, {
    default: ()=>ol
});
var ol, oo = G(()=>{
    "use strict";
    p();
    ol = {};
});
var ao = T((lp, al)=>{
    al.exports = {
        name: "pg",
        version: "8.8.0",
        description: "PostgreSQL client - pure javas\
cript & libpq with the same API",
        keywords: [
            "database",
            "libpq",
            "pg",
            "postgre",
            "postgres",
            "postgresql",
            "rdbms"
        ],
        homepage: "https://github.com/brianc/node-postgres",
        repository: {
            type: "git",
            url: "git://github\
.com/brianc/node-postgres.git",
            directory: "packages/pg"
        },
        author: "Brian Carlson <brian.m.carlson@gmail\
.com>",
        main: "./lib",
        dependencies: {
            "buffer-writer": "2.0.0",
            "packet-reader": "1.0.0",
            "pg-connection-str\
ing": "^2.5.0",
            "pg-pool": "^3.5.2",
            "pg-protocol": "^1.5.0",
            "pg-types": "^2.1.0",
            pgpass: "1.x"
        },
        devDependencies: {
            async: "2.6.4",
            bluebird: "3.5.2",
            co: "4.6.0",
            "pg-copy-streams": "0.3.0"
        },
        peerDependencies: {
            "pg-native": "\
>=3.0.1"
        },
        peerDependenciesMeta: {
            "pg-native": {
                optional: !0
            }
        },
        scripts: {
            test: "make test-all"
        },
        files: [
            "li\
b",
            "SPONSORS.md"
        ],
        license: "MIT",
        engines: {
            node: ">= 8.0.0"
        },
        gitHead: "c99fb2c127ddf8d712500db2c7b9a5491\
a178655"
    };
});
var lo = T((fp, co)=>{
    "use strict";
    p();
    var uo = ge().EventEmitter, ul = (it(), O(nt)), Rn = rt(), Ne = co.exports = function(r, e, t) {
        uo.call(this), r = Rn.normalizeQueryConfig(r, e, t), this.text = r.text, this.values = r.values, this.name = r.name, this.callback = r.callback, this.state = "new", this._arrayMode = r.rowMode === "array", this._emitRowEvents = !1, this.on("newListener", (function(n) {
            n === "row" && (this._emitRowEvents = !0);
        }).bind(this));
    };
    ul.inherits(Ne, uo);
    var cl = {
        sqlState: "code",
        statementPosition: "position",
        messagePrimary: "message",
        context: "where",
        schemaName: "\
schema",
        tableName: "table",
        columnName: "column",
        dataTypeName: "dataType",
        constraintName: "constraint",
        sourceFile: "\
file",
        sourceLine: "line",
        sourceFunction: "routine"
    };
    Ne.prototype.handleError = function(r) {
        var e = this.native.pq.resultErrorFields();
        if (e) for(var t in e){
            var n = cl[t] || t;
            r[n] = e[t];
        }
        this.callback ? this.callback(r) : this.emit("error", r), this.state = "error";
    };
    Ne.prototype.then = function(r, e) {
        return this._getPromise().then(r, e);
    };
    Ne.prototype.catch = function(r) {
        return this._getPromise().catch(r);
    };
    Ne.prototype._getPromise = function() {
        return this._promise ? this._promise : (this._promise = new Promise((function(r, e) {
            this._once("end", r), this._once("error", e);
        }).bind(this)), this._promise);
    };
    Ne.prototype.submit = function(r) {
        this.state = "running";
        var e = this;
        this.native = r.native, r.native.arrayMode = this._arrayMode;
        var t = a(function(s, o, u) {
            if (r.native.arrayMode = !1, v(function() {
                e.emit("_done");
            }), s) return e.handleError(s);
            e._emitRowEvents && (u.length > 1 ? o.forEach((c, l)=>{
                c.forEach((f)=>{
                    e.emit("row", f, u[l]);
                });
            }) : o.forEach(function(c) {
                e.emit("row", c, u);
            })), e.state = "e\
nd", e.emit("end", u), e.callback && e.callback(null, u);
        }, "after");
        if (m.domain && (t = m.domain.bind(t)), this.name) {
            this.name.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query n\
ames."), console.error("You supplied %s (%s)", this.name, this.name.length), console.error("This can cau\
se conflicts and silent errors executing queries"));
            var n = (this.values || []).map(Rn.prepareValue);
            if (r.namedQueries[this.name]) {
                if (this.text && r.namedQueries[this.name] !== this.text) {
                    let s = new Error(`Prepa\
red statements must be unique - '${this.name}' was used for a different statement`);
                    return t(s);
                }
                return r.native.execute(this.name, n, t);
            }
            return r.native.prepare(this.name, this.text, n.length, function(s) {
                return s ? t(s) : (r.namedQueries[e.name] = e.text, e.native.execute(e.name, n, t));
            });
        } else if (this.values) {
            if (!Array.isArray(this.values)) {
                let s = new Error("Query values must be an array");
                return t(s);
            }
            var i = this.values.map(Rn.prepareValue);
            r.native.query(this.text, i, t);
        } else r.native.query(this.text, t);
    };
});
var yo = T((yp, po)=>{
    "use strict";
    p();
    var ll = (oo(), O(so)), fl = At(), dp = ao(), fo = ge().EventEmitter, hl = (it(), O(nt)), pl = Bt(), ho = lo(), K = po.exports = function(r) {
        fo.call(this), r = r || {}, this._Promise = r.Promise || b.Promise, this._types = new fl(r.types), this.native = new ll({
            types: this._types
        }), this._queryQueue = [], this._ending = !1, this._connecting = !1, this._connected = !1, this._queryable = !0;
        var e = this.connectionParameters = new pl(r);
        this.user = e.user, Object.defineProperty(this, "password", {
            configurable: !0,
            enumerable: !1,
            writable: !0,
            value: e.password
        }), this.database = e.database, this.host = e.host, this.port = e.port, this.namedQueries = {};
    };
    K.Query = ho;
    hl.inherits(K, fo);
    K.prototype._errorAllQueries = function(r) {
        let e = a((t)=>{
            m.nextTick(()=>{
                t.native = this.native, t.handleError(r);
            });
        }, "enqueueError");
        this._hasActiveQuery() && (e(this._activeQuery), this._activeQuery = null), this._queryQueue.forEach(e), this._queryQueue.length = 0;
    };
    K.prototype._connect = function(r) {
        var e = this;
        if (this._connecting) {
            m.nextTick(()=>r(new Error("Client has already been connected. You cannot reuse\
 a client.")));
            return;
        }
        this._connecting = !0, this.connectionParameters.getLibpqConnectionString(function(t, n) {
            if (t) return r(t);
            e.native.connect(n, function(i) {
                if (i) return e.native.end(), r(i);
                e._connected = !0, e.native.on("error", function(s) {
                    e._queryable = !1, e._errorAllQueries(s), e.emit("error", s);
                }), e.native.on("notifi\
cation", function(s) {
                    e.emit("notification", {
                        channel: s.relname,
                        payload: s.extra
                    });
                }), e.emit("connect"), e._pulseQueryQueue(!0), r();
            });
        });
    };
    K.prototype.connect = function(r) {
        if (r) {
            this._connect(r);
            return;
        }
        return new this._Promise((e, t)=>{
            this._connect((n)=>{
                n ? t(n) : e();
            });
        });
    };
    K.prototype.query = function(r, e, t) {
        var n, i, s, o, u;
        if (r == null) throw new TypeError("Client was passed a null or undefined query");
        if (typeof r.submit == "functio\
n") s = r.query_timeout || this.connectionParameters.query_timeout, i = n = r, typeof e == "function" && (r.callback = e);
        else if (s = this.connectionParameters.query_timeout, n = new ho(r, e, t), !n.callback) {
            let c, l;
            i = new this._Promise((f, y)=>{
                c = f, l = y;
            }), n.callback = (f, y)=>f ? l(f) : c(y);
        }
        return s && (u = n.callback, o = setTimeout(()=>{
            var c = new Error("Query read timeout");
            m.nextTick(()=>{
                n.handleError(c, this.connection);
            }), u(c), n.callback = ()=>{};
            var l = this._queryQueue.indexOf(n);
            l > -1 && this._queryQueue.splice(l, 1), this._pulseQueryQueue();
        }, s), n.callback = (c, l)=>{
            clearTimeout(o), u(c, l);
        }), this._queryable ? this._ending ? (n.native = this.native, m.nextTick(()=>{
            n.handleError(new Error("Client was closed and is not queryable"));
        }), i) : (this._queryQueue.push(n), this._pulseQueryQueue(), i) : (n.native = this.native, m.nextTick(()=>{
            n.handleError(new Error("Client has encountered a connectio\
n error and is not queryable"));
        }), i);
    };
    K.prototype.end = function(r) {
        var e = this;
        this._ending = !0, this._connected || this.once("connect", this.end.bind(this, r));
        var t;
        return r || (t = new this._Promise(function(n, i) {
            r = a((s)=>s ? i(s) : n(), "cb");
        })), this.native.end(function() {
            e._errorAllQueries(new Error("Connection terminated")), m.nextTick(()=>{
                e.emit("end"), r && r();
            });
        }), t;
    };
    K.prototype._hasActiveQuery = function() {
        return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
    };
    K.prototype._pulseQueryQueue = function(r) {
        if (this._connected && !this._hasActiveQuery()) {
            var e = this._queryQueue.shift();
            if (!e) {
                r || this.emit("dra\
in");
                return;
            }
            this._activeQuery = e, e.submit(this);
            var t = this;
            e.once("_done", function() {
                t._pulseQueryQueue();
            });
        }
    };
    K.prototype.cancel = function(r) {
        this._activeQuery === r ? this.native.cancel(function() {}) : this._queryQueue.indexOf(r) !== -1 && this._queryQueue.splice(this._queryQueue.indexOf(r), 1);
    };
    K.prototype.ref = function() {};
    K.prototype.unref = function() {};
    K.prototype.setTypeParser = function(r, e, t) {
        return this._types.setTypeParser(r, e, t);
    };
    K.prototype.getTypeParser = function(r, e) {
        return this._types.getTypeParser(r, e);
    };
});
var Ln = T((gp, mo)=>{
    "use strict";
    p();
    mo.exports = yo();
});
var ot = T((vp, at)=>{
    "use strict";
    p();
    var dl = eo(), yl = tt(), ml = En(), wl = io(), { DatabaseError: gl } = vn(), bl = a((r)=>{
        var e;
        return e = class extends wl {
            constructor(n){
                super(n, r);
            }
        }, a(e, "BoundPool"), e;
    }, "poolFactory"), Fn = a(function(r) {
        this.defaults = yl, this.Client = r, this.Query = this.Client.Query, this.Pool = bl(this.Client), this._pools = [], this.Connection = ml, this.types = Je(), this.DatabaseError = gl;
    }, "PG");
    typeof m.env.NODE_PG_FORCE_NATIVE < "u" ? at.exports = new Fn(Ln()) : (at.exports = new Fn(dl), Object.defineProperty(at.exports, "native", {
        configurable: !0,
        enumerable: !1,
        get () {
            var r = null;
            try {
                r = new Fn(Ln());
            } catch (e) {
                if (e.code !== "MODULE_NOT_FOUND") throw e;
            }
            return Object.defineProperty(at.exports, "native", {
                value: r
            }), r;
        }
    }));
});
p();
p();
Fe();
Zt();
p();
var pa = Object.defineProperty, da = Object.defineProperties, ya = Object.getOwnPropertyDescriptors, bi = Object.getOwnPropertySymbols, ma = Object.prototype.hasOwnProperty, wa = Object.prototype.propertyIsEnumerable, vi = a((r, e, t)=>e in r ? pa(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t, "__defNormalProp"), ga = a((r, e)=>{
    for(var t in e || (e = {}))ma.call(e, t) && vi(r, t, e[t]);
    if (bi) for (var t of bi(e))wa.call(e, t) && vi(r, t, e[t]);
    return r;
}, "__spreadValues"), ba = a((r, e)=>da(r, ya(e)), "__spreadProps"), va = 1008e3, xi = new Uint8Array(new Uint16Array([
    258
]).buffer)[0] === 2, xa = new TextDecoder, Jt = new TextEncoder, yt = Jt.encode("0123456789\
abcdef"), mt = Jt.encode("0123456789ABCDEF"), Sa = Jt.encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqr\
stuvwxyz0123456789+/");
var Si = Sa.slice();
Si[62] = 45;
Si[63] = 95;
var He, wt;
function Ea(r, { alphabet: e, scratchArr: t } = {}) {
    if (!He) if (He = new Uint16Array(256), wt = new Uint16Array(256), xi) for(let C = 0; C < 256; C++)He[C] = yt[C & 15] << 8 | yt[C >>> 4], wt[C] = mt[C & 15] << 8 | mt[C >>> 4];
    else for(let C = 0; C < 256; C++)He[C] = yt[C & 15] | yt[C >>> 4] << 8, wt[C] = mt[C & 15] | mt[C >>> 4] << 8;
    r.byteOffset % 4 !== 0 && (r = new Uint8Array(r));
    let n = r.length, i = n >>> 1, s = n >>> 2, o = t || new Uint16Array(n), u = new Uint32Array(r.buffer, r.byteOffset, s), c = new Uint32Array(o.buffer, o.byteOffset, i), l = e === "upper" ? wt : He, f = 0, y = 0, g;
    if (xi) for(; f < s;)g = u[f++], c[y++] = l[g >>> 8 & 255] << 16 | l[g & 255], c[y++] = l[g >>> 24] << 16 | l[g >>> 16 & 255];
    else for(; f < s;)g = u[f++], c[y++] = l[g >>> 24] << 16 | l[g >>> 16 & 255], c[y++] = l[g >>> 8 & 255] << 16 | l[g & 255];
    for(f <<= 2; f < n;)o[f] = l[r[f++]];
    return xa.decode(o.subarray(0, n));
}
a(Ea, "_toHex");
function Aa(r, e = {}) {
    let t = "", n = r.length, i = va >>> 1, s = Math.ceil(n / i), o = new Uint16Array(s > 1 ? i : n);
    for(let u = 0; u < s; u++){
        let c = u * i, l = c + i;
        t += Ea(r.subarray(c, l), ba(ga({}, e), {
            scratchArr: o
        }));
    }
    return t;
}
a(Aa, "_toHexChunked");
function Ei(r, e = {}) {
    return e.alphabet !== "upper" && typeof r.toHex == "function" ? r.toHex() : Aa(r, e);
}
a(Ei, "toHex");
p();
var gt = class gt {
    constructor(e, t){
        this.strings = e;
        this.values = t;
    }
    toParameterizedQuery(e = {
        query: "",
        params: []
    }) {
        let { strings: t, values: n } = this;
        for(let i = 0, s = t.length; i < s; i++)if (e.query += t[i], i < n.length) {
            let o = n[i];
            if (o instanceof Ge) e.query += o.sql;
            else if (o instanceof Ce) if (o.queryData instanceof gt) o.queryData.toParameterizedQuery(e);
            else {
                if (o.queryData.params?.length) throw new Error("This query is not composable");
                e.query += o.queryData.query;
            }
            else {
                let { params: u } = e;
                u.push(o), e.query += "$" + u.length, (o instanceof d || ArrayBuffer.isView(o)) && (e.query += "::bytea");
            }
        }
        return e;
    }
};
a(gt, "SqlTemplate");
var $e = gt, Xt = class Xt {
    constructor(e){
        this.sql = e;
    }
};
a(Xt, "UnsafeRawSql");
var Ge = Xt;
p();
function bt() {
    "undefined" < "u" && typeof document < "u" && typeof console < "u" && typeof console.warn == "func\
tion" && console.warn(`          
        ************************************************************
        *                                                          *
        *  WARNING: Running SQL directly from the browser can have *
        *  security implications. Even if your database is         *
        *  protected by Row-Level Security (RLS), use it at your   *
        *  own risk. This approach is great for fast prototyping,  *
        *  but ensure proper safeguards are in place to prevent    *
        *  misuse or execution of expensive SQL queries by your    *
        *  end users.                                              *
        *                                                          *
        *  If you've assessed the risks, suppress this message     *
        *  using the disableWarningInBrowsers configuration        *
        *  parameter.                                              *
        *                                                          *
        ************************************************************`);
}
a(bt, "warnIfBrowser");
Fe();
var as = Se(At()), us = Se(rt());
var _t = class _t extends Error {
    constructor(t){
        super(t);
        E(this, "name", "NeonDbError");
        E(this, "severity");
        E(this, "code");
        E(this, "detail");
        E(this, "hint");
        E(this, "position");
        E(this, "internalPosition");
        E(this, "internalQuery");
        E(this, "where");
        E(this, "schema");
        E(this, "table");
        E(this, "column");
        E(this, "dataType");
        E(this, "constraint");
        E(this, "file");
        E(this, "line");
        E(this, "routine");
        E(this, "sourceError");
        "captureS\
tackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, _t);
    }
};
a(_t, "NeonDbError");
var be = _t, is = "transaction() expects an array of queries, or a function returning a\
n array of queries", Ru = [
    "severity",
    "code",
    "detail",
    "hint",
    "position",
    "internalPosition",
    "internalQue\
ry",
    "where",
    "schema",
    "table",
    "column",
    "dataType",
    "constraint",
    "file",
    "line",
    "routine"
];
function Lu(r) {
    return r instanceof d ? "\\x" + Ei(r) : r;
}
a(Lu, "encodeBuffersAsBytea");
function ss(r) {
    let { query: e, params: t } = r instanceof $e ? r.toParameterizedQuery() : r;
    return {
        query: e,
        params: t.map((n)=>Lu((0, us.prepareValue)(n)))
    };
}
a(ss, "prep\
areQuery");
function cs(r, { arrayMode: e, fullResults: t, fetchOptions: n, isolationLevel: i, readOnly: s, deferrable: o, authToken: u, disableWarningInBrowsers: c } = {}) {
    if (!r) throw new Error("No database connection string was\
 provided to `neon()`. Perhaps an environment variable has not been set?");
    let l;
    try {
        l = Yt(r);
    } catch  {
        throw new Error("Database connection string provided to `neon()` is not a valid URL. Connection string: " + String(r));
    }
    let { protocol: f, username: y, hostname: g, port: A, pathname: C } = l;
    if (f !== "postgres:" && f !== "postgresql:" || !y || !g || !C) throw new Error("Database connection string format for `neon()` should be: postgresql://user:\
password@host.tld/dbname?option=value");
    function D(P, ...I) {
        if (!(Array.isArray(P) && Array.isArray(P.raw) && Array.isArray(I))) throw new Error('This function can now be called only as a tagged-template functio\
n: sql`SELECT ${value}`, not sql("SELECT $1", [value], options). For a conventional function call wi\
th value placeholders ($1, $2, etc.), use sql.query("SELECT $1", [value], options).');
        return new Ce(Y, new $e(P, I));
    }
    a(D, "templateFn"), D.query = (P, I, w)=>new Ce(Y, {
            query: P,
            params: I ?? []
        }, w), D.unsafe = (P)=>new Ge(P), D.transaction = async (P, I)=>{
        if (typeof P == "function" && (P = P(D)), !Array.isArray(P)) throw new Error(is);
        P.forEach((W)=>{
            if (!(W instanceof Ce)) throw new Error(is);
        });
        let w = P.map((W)=>W.queryData), Z = P.map((W)=>W.opts ?? {});
        return Y(w, Z, I);
    };
    async function Y(P, I, w) {
        let { fetchEndpoint: Z, fetchFunction: W } = ce, J = Array.isArray(P) ? {
            queries: P.map((ee)=>ss(ee))
        } : ss(P), X = n ?? {}, se = e ?? !1, oe = t ?? !1, R = i, j = s, le = o;
        w !== void 0 && (w.fetchOptions !== void 0 && (X = {
            ...X,
            ...w.fetchOptions
        }), w.arrayMode !== void 0 && (se = w.arrayMode), w.fullResults !== void 0 && (oe = w.fullResults), w.isolationLevel !== void 0 && (R = w.isolationLevel), w.readOnly !== void 0 && (j = w.readOnly), w.deferrable !== void 0 && (le = w.deferrable)), I !== void 0 && !Array.isArray(I) && I.fetchOptions !== void 0 && (X = {
            ...X,
            ...I.fetchOptions
        });
        let de = u;
        !Array.isArray(I) && I?.authToken !== void 0 && (de = I.authToken);
        let We = typeof Z == "function" ? Z(g, A, {
            jwtAuth: de !== void 0
        }) : Z, fe = {
            "Neon-Connection-String": r,
            "Neon-Raw-Text-Output": "tru\
e",
            "Neon-Array-Mode": "true"
        }, _e = await Fu(de);
        _e && (fe.Authorization = `Bearer ${_e}`), Array.isArray(P) && (R !== void 0 && (fe["Neon-Batch-Isolation-Level"] = R), j !== void 0 && (fe["Neon-Batch-Read-Only"] = String(j)), le !== void 0 && (fe["Neon-Batch-Deferrable"] = String(le))), c || ce.disableWarningInBrowsers || bt();
        let ye;
        try {
            ye = await (W ?? fetch)(We, {
                method: "POST",
                body: JSON.stringify(J),
                headers: fe,
                ...X
            });
        } catch (ee) {
            let M = new be(`Error connecting to database: ${ee}`);
            throw M.sourceError = ee, M;
        }
        if (ye.ok) {
            let ee = await ye.json();
            if (Array.isArray(P)) {
                let M = ee.results;
                if (!Array.isArray(M)) throw new be("Neon internal error: unexpected resu\
lt format");
                return M.map(($, me)=>{
                    let Ot = I[me] ?? {}, vo = Ot.arrayMode ?? se, xo = Ot.fullResults ?? oe;
                    return os($, {
                        arrayMode: vo,
                        fullResults: xo,
                        types: Ot.types
                    });
                });
            } else {
                let M = I ?? {}, $ = M.arrayMode ?? se, me = M.fullResults ?? oe;
                return os(ee, {
                    arrayMode: $,
                    fullResults: me,
                    types: M.types
                });
            }
        } else {
            let { status: ee } = ye;
            if (ee === 400) {
                let M = await ye.json(), $ = new be(M.message);
                for (let me of Ru)$[me] = M[me] ?? void 0;
                throw $;
            } else {
                let M = await ye.text();
                throw new be(`Server error (HTTP status ${ee}): ${M}`);
            }
        }
    }
    return a(Y, "execute"), D;
}
a(cs, "neon");
var dr = class dr {
    constructor(e, t, n){
        this.execute = e;
        this.queryData = t;
        this.opts = n;
    }
    then(e, t) {
        return this.execute(this.queryData, this.opts).then(e, t);
    }
    catch(e) {
        return this.execute(this.queryData, this.opts).catch(e);
    }
    finally(e) {
        return this.execute(this.queryData, this.opts).finally(e);
    }
};
a(dr, "NeonQueryPromise");
var Ce = dr;
function os(r, { arrayMode: e, fullResults: t, types: n }) {
    let i = new as.default(n), s = r.fields.map((c)=>c.name), o = r.fields.map((c)=>i.getTypeParser(c.dataTypeID)), u = e === !0 ? r.rows.map((c)=>c.map((l, f)=>l === null ? null : o[f](l))) : r.rows.map((c)=>Object.fromEntries(c.map((l, f)=>[
                s[f],
                l === null ? null : o[f](l)
            ])));
    return t ? (r.viaNeonFetch = !0, r.rowAsArray = e, r.rows = u, r._parsers = o, r._types = i, r) : u;
}
a(os, "processQueryResult");
async function Fu(r) {
    if (typeof r == "string") return r;
    if (typeof r == "function") try {
        return await Promise.resolve(r());
    } catch (e) {
        let t = new be("Error getting auth token.");
        throw e instanceof Error && (t = new be(`Error getting auth token: ${e.message}`)), t;
    }
}
a(Fu, "getAuthToken");
p();
var go = Se(ot());
p();
var wo = Se(ot());
var kn = class kn extends wo.Client {
    constructor(t){
        super(t);
        this.config = t;
    }
    get neonConfig() {
        return this.connection.stream;
    }
    connect(t) {
        let { neonConfig: n } = this;
        n.forceDisablePgSSL && (this.ssl = this.connection.ssl = !1), this.ssl && n.useSecureWebSocket && console.warn("SSL is enabled for both Postgres (e.g. ?sslmode=re\
quire in the connection string + forceDisablePgSSL = false) and the WebSocket tunnel (useSecureWebSo\
cket = true). Double encryption will increase latency and CPU usage. It may be appropriate to disabl\
e SSL in the Postgres connection parameters or set forceDisablePgSSL = true.");
        let i = typeof this.config != "string" && this.config?.host !== void 0 || typeof this.config != "string" && this.config?.connectionString !== void 0 || m.env.PGHOST !== void 0, s = m.env.USER ?? m.env.USERNAME;
        if (!i && this.host === "localhost" && this.user === s && this.database === s && this.password === null) throw new Error(`No database host or connection string wa\
s set, and key parameters have default values (host: localhost, user: ${s}, db: ${s}, password: null\
). Is an environment variable missing? Alternatively, if you intended to connect with these paramete\
rs, please set the host to 'localhost' explicitly.`);
        let o = super.connect(t), u = n.pipelineTLS && this.ssl, c = n.pipelineConnect === "password";
        if (!u && !n.pipelineConnect) return o;
        let l = this.connection;
        if (u && l.on("connect", ()=>l.stream.emit("data", "S")), c) {
            l.removeAllListeners("authenticationCleartextPassword"), l.removeAllListeners("readyForQuery"), l.once("readyForQuery", ()=>l.on("readyForQuery", this._handleReadyForQuery.bind(this)));
            let f = this.ssl ? "sslconnect" : "connect";
            l.on(f, ()=>{
                this.neonConfig.disableWarningInBrowsers || bt(), this._handleAuthCleartextPassword(), this._handleReadyForQuery();
            });
        }
        return o;
    }
    async _handleAuthSASLContinue(t) {
        if (typeof crypto > "u" || crypto.subtle === void 0 || crypto.subtle.importKey === void 0) throw new Error("Cann\
ot use SASL auth when `crypto.subtle` is not defined");
        let n = crypto.subtle, i = this.saslSession, s = this.password, o = t.data;
        if (i.message !== "SASLInitialResponse" || typeof s != "string" || typeof o != "string") throw new Error("SASL: protocol error");
        let u = Object.fromEntries(o.split(",").map((M)=>{
            if (!/^.=/.test(M)) throw new Error("SASL: Invalid attribute pair entry");
            let $ = M[0], me = M.substring(2);
            return [
                $,
                me
            ];
        })), c = u.r, l = u.s, f = u.i;
        if (!c || !/^[!-+--~]+$/.test(c)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing/unpri\
ntable");
        if (!l || !/^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(l)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing/not base64");
        if (!f || !/^[1-9][0-9]*$/.test(f)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: missing/invalid iteration count");
        if (!c.startsWith(i.clientNonce)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
        if (c.length === i.clientNonce.length) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too\
 short");
        let y = parseInt(f, 10), g = d.from(l, "base64"), A = new TextEncoder, C = A.encode(s), D = await n.importKey("raw", C, {
            name: "HMAC",
            hash: {
                name: "SHA-256"
            }
        }, !1, [
            "sign"
        ]), Y = new Uint8Array(await n.sign("HMAC", D, d.concat([
            g,
            d.from([
                0,
                0,
                0,
                1
            ])
        ]))), P = Y;
        for(var I = 0; I < y - 1; I++)Y = new Uint8Array(await n.sign("HMAC", D, Y)), P = d.from(P.map((M, $)=>P[$] ^ Y[$]));
        let w = P, Z = await n.importKey("raw", w, {
            name: "HMAC",
            hash: {
                name: "SHA-256"
            }
        }, !1, [
            "sign"
        ]), W = new Uint8Array(await n.sign("HMAC", Z, A.encode("Client Key"))), J = await n.digest("SHA-256", W), X = "n=*,r=" + i.clientNonce, se = "r=" + c + ",s=" + l + ",i=" + y, oe = "c=biws,r=" + c, R = X + "," + se + "," + oe, j = await n.importKey("raw", J, {
            name: "HMAC",
            hash: {
                name: "SHA-256"
            }
        }, !1, [
            "sign"
        ]);
        var le = new Uint8Array(await n.sign("HMAC", j, A.encode(R))), de = d.from(W.map((M, $)=>W[$] ^ le[$])), We = de.toString("base64");
        let fe = await n.importKey("raw", w, {
            name: "HMAC",
            hash: {
                name: "SHA-256"
            }
        }, !1, [
            "sign"
        ]), _e = await n.sign("HMAC", fe, A.encode("Server \
Key")), ye = await n.importKey("raw", _e, {
            name: "HMAC",
            hash: {
                name: "SHA-256"
            }
        }, !1, [
            "sign"
        ]);
        var ee = d.from(await n.sign("HMAC", ye, A.encode(R)));
        i.message = "SASLResponse", i.serverSignature = ee.toString("base64"), i.response = oe + ",p=" + We, this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
    }
};
a(kn, "NeonClient");
var ut = kn;
Fe();
var bo = Se(Bt());
function vl(r, e) {
    if (e) return {
        callback: e,
        result: void 0
    };
    let t, n, i = a(function(o, u) {
        o ? t(o) : n(u);
    }, "cb"), s = new r(function(o, u) {
        n = o, t = u;
    });
    return {
        callback: i,
        result: s
    };
}
a(vl, "promisify");
var Un = class Un extends go.Pool {
    constructor(){
        super(...arguments);
        E(this, "Client", ut);
        E(this, "hasFetchUnsupportedListeners", !1);
        E(this, "addListene\
r", this.on);
    }
    on(t, n) {
        return t !== "error" && (this.hasFetchUnsupportedListeners = !0), super.on(t, n);
    }
    query(t, n, i) {
        if (!ce.poolQueryViaFetch || this.hasFetchUnsupportedListeners || typeof t == "function") return super.query(t, n, i);
        typeof n == "function" && (i = n, n = void 0);
        let s = vl(this.Promise, i);
        i = s.callback;
        try {
            let o = new bo.default(this.options), u = encodeURIComponent, c = encodeURI, l = `postgresql://${u(o.user)}:${u(o.password)}@${u(o.host)}\
/${c(o.database)}`, f = typeof t == "string" ? t : t.text, y = n ?? t.values ?? [];
            cs(l, {
                fullResults: !0,
                arrayMode: t.rowMode === "array"
            }).query(f, y, {
                types: t.types ?? this.options?.types
            }).then((A)=>i(void 0, A)).catch((A)=>i(A));
        } catch (o) {
            i(o);
        }
        return s.result;
    }
};
a(Un, "NeonPool");
var Mn = Un;
Fe();
var ct = Se(ot()), kp = "mjs";
var export_DatabaseError = ct.DatabaseError;
var export_defaults = ct.defaults;
var export_escapeIdentifier = ct.escapeIdentifier;
var export_escapeLiteral = ct.escapeLiteral;
var export_types = ct.types;
;
 /*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/ }),
];

//# sourceMappingURL=node_modules_bf1762f7._.js.map