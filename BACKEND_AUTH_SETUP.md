# Backend Authentication Setup Guide

## Problem
When the frontend (Next.js on port 3000) makes requests to the backend (Node.js on port 5000), cookies are **not automatically sent** due to cross-origin restrictions.

## Solution
The frontend now sends a **JWT token** in the `Authorization` header. The JWT token contains user information that your backend can decode.

## Backend Implementation

### 1. Extract Token from Authorization Header

Your backend should check for the JWT token in the `Authorization` header:

```javascript
// Middleware or route handler
function getAuthToken(req) {
  // Check Authorization header
  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith('Bearer ')) {
    return authHeader.substring(7); // Remove 'Bearer ' prefix
  }
  
  return null;
}
```

### 2. Decode JWT Token

The token is a JWT that contains user information. **Decode it** (don't verify, as per your requirements):

```javascript
const jwt = require('jsonwebtoken');

function decodeToken(token) {
  try {
    // Decode without verification (as per your backend requirements)
    const decoded = jwt.decode(token);
    return decoded;
  } catch (error) {
    console.error('Error decoding token:', error);
    return null;
  }
}
```

**Token Payload Structure:**
```javascript
{
  userId: 123,           // User ID from users table
  email: "user@example.com",
  role: "clinician",     // User role
  type: "user",          // Token type
  iat: 1234567890,       // Issued at timestamp
  exp: 1234567890        // Expiration timestamp
}
```

### 3. Example Middleware

```javascript
const jwt = require('jsonwebtoken');

function authenticateUser(req, res, next) {
  const token = getAuthToken(req);
  
  if (!token) {
    return res.status(401).json({
      error: 'Not authenticated',
      message: 'Please login to access this resource'
    });
  }
  
  // Decode the JWT token
  const decoded = jwt.decode(token);
  
  if (!decoded || !decoded.userId) {
    return res.status(401).json({
      error: 'Invalid token',
      message: 'Please login again'
    });
  }
  
  // Optional: Check if token is expired
  if (decoded.exp && decoded.exp < Date.now() / 1000) {
    return res.status(401).json({
      error: 'Token expired',
      message: 'Please login again'
    });
  }
  
  // Attach user info to request
  req.user = {
    id: decoded.userId,
    email: decoded.email,
    role: decoded.role
  };
  
  next();
}
```

### 4. Use in Routes

```javascript
// Apply to all patient routes
app.use('/api/backend/patients', authenticateUser);

// Or apply to specific routes
app.post('/api/backend/patients/:patientId/notes', authenticateUser, async (req, res) => {
  const userId = req.user.id;
  const patientId = req.params.patientId;
  // ... rest of your logic
});
```

## CORS Configuration

Make sure your backend allows the `Authorization` header:

```javascript
const cors = require('cors');

app.use(cors({
  origin: 'http://localhost:3000', // Your Next.js frontend
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

## Testing

1. **Login** on the frontend (creates `session_token` cookie)
2. **Frontend automatically** gets token from `/api/auth/token`
3. **Frontend sends** token in `Authorization: Bearer <token>` header
4. **Backend validates** token and processes request

## Token Format

The token is a **JWT (JSON Web Token)** that contains user information in its payload. It's generated by the Next.js backend when users log in.

**Example JWT token format:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywiZW1haWwiOiJ1c2VyQGV4YW1wbGUuY29tIiwicm9sZSI6ImNsaW5pY2lhbiIsInR5cCI6InVzZXIiLCJpYXQiOjE3MDAwMDAwMDAsImV4cCI6MTcwMDYwNDgwMH0.abc123...
```

**Important:** Your backend should **decode** the JWT (not verify it) to extract the `userId` or `patientId` from the payload.

